{
  "version": 3,
  "sources": ["../node_modules/comlink/src/comlink.ts", "../node_modules/gl-matrix/esm/common.js", "../node_modules/gl-matrix/esm/mat3.js", "../node_modules/gl-matrix/esm/mat4.js", "../node_modules/gl-matrix/esm/vec3.js", "../node_modules/gl-matrix/esm/vec4.js", "../node_modules/gl-matrix/esm/vec2.js", "../src/wasm/nurbs_wrapper.js", "../src/worker/nurbs.ts", "../src/worker/face.ts", "../src/worker/ray.ts", "../src/worker/surfaces.ts", "../src/worker/edge.ts", "../src/worker/loader.ts", "../src/worker/util.ts", "../src/worker/curves.ts", "../src/worker/calculations.ts", "../src/worker/outline.ts", "../src/worker/extract_values.ts", "../src/worker/parametric_product.ts", "../src/worker/profile.ts", "../src/worker/manhole.ts", "../src/worker/draw_objects.ts", "../src/worker/collision.ts", "../src/worker/snaps.ts", "../src/worker/roads/scene.ts", "../src/worker/scene.ts", "../src/worker/service.ts"],
  "sourcesContent": ["/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map((p) => p.toString()),\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously \u00AF\\_(\u30C4)_/\u00AF\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didn\u2019t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n", "/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};", "import * as glMatrix from \"./common.js\";\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\n\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\n\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\n\nexport function translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\n\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\n\nexport var sub = subtract;", "import * as glMatrix from \"./common.js\";\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nexport var perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nexport var ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nexport var sub = subtract;", "import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();", "import * as glMatrix from \"./common.js\";\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nexport function transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();", "import * as glMatrix from \"./common.js\";\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();", "\nvar Module = (function () {\n    var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n    return (\n        function (Module) {\n            Module = Module || {};\n\n\n\n            // The Module object: Our interface to the outside world. We import\n            // and export values on it. There are various ways Module can be used:\n            // 1. Not defined. We create it here\n            // 2. A function parameter, function(Module) { ..generated code.. }\n            // 3. pre-run appended it, var Module = {}; ..generated code..\n            // 4. External script tag defines var Module.\n            // We need to check if Module already exists (e.g. case 3 above).\n            // Substitution will be replaced with actual code on later stage of the build,\n            // this way Closure Compiler will not mangle it (e.g. case 4. above).\n            // Note that if you want to run closure, and also to use Module\n            // after the generated code, you will need to define   var Module = {};\n            // before the code. Then that object will be used in the code, and you\n            // can continue to use Module afterwards as well.\n            var Module = typeof Module !== 'undefined' ? Module : {};\n\n            // Set up the promise that indicates the Module is initialized\n            var readyPromiseResolve, readyPromiseReject;\n            Module['ready'] = new Promise(function (resolve, reject) {\n                readyPromiseResolve = resolve;\n                readyPromiseReject = reject;\n            });\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_malloc')) {\n                Object.defineProperty(Module['ready'], '_malloc', { configurable: true, get: function () { abort('You are getting _malloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_malloc', { configurable: true, set: function () { abort('You are setting _malloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_free')) {\n                Object.defineProperty(Module['ready'], '_free', { configurable: true, get: function () { abort('You are getting _free on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_free', { configurable: true, set: function () { abort('You are setting _free on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_emscripten_stack_get_end')) {\n                Object.defineProperty(Module['ready'], '_emscripten_stack_get_end', { configurable: true, get: function () { abort('You are getting _emscripten_stack_get_end on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_emscripten_stack_get_end', { configurable: true, set: function () { abort('You are setting _emscripten_stack_get_end on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_emscripten_stack_get_free')) {\n                Object.defineProperty(Module['ready'], '_emscripten_stack_get_free', { configurable: true, get: function () { abort('You are getting _emscripten_stack_get_free on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_emscripten_stack_get_free', { configurable: true, set: function () { abort('You are setting _emscripten_stack_get_free on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_emscripten_stack_init')) {\n                Object.defineProperty(Module['ready'], '_emscripten_stack_init', { configurable: true, get: function () { abort('You are getting _emscripten_stack_init on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_emscripten_stack_init', { configurable: true, set: function () { abort('You are setting _emscripten_stack_init on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_stackSave')) {\n                Object.defineProperty(Module['ready'], '_stackSave', { configurable: true, get: function () { abort('You are getting _stackSave on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_stackSave', { configurable: true, set: function () { abort('You are setting _stackSave on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_stackRestore')) {\n                Object.defineProperty(Module['ready'], '_stackRestore', { configurable: true, get: function () { abort('You are getting _stackRestore on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_stackRestore', { configurable: true, set: function () { abort('You are setting _stackRestore on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_stackAlloc')) {\n                Object.defineProperty(Module['ready'], '_stackAlloc', { configurable: true, get: function () { abort('You are getting _stackAlloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_stackAlloc', { configurable: true, set: function () { abort('You are setting _stackAlloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '___wasm_call_ctors')) {\n                Object.defineProperty(Module['ready'], '___wasm_call_ctors', { configurable: true, get: function () { abort('You are getting ___wasm_call_ctors on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '___wasm_call_ctors', { configurable: true, set: function () { abort('You are setting ___wasm_call_ctors on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_fflush')) {\n                Object.defineProperty(Module['ready'], '_fflush', { configurable: true, get: function () { abort('You are getting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_fflush', { configurable: true, set: function () { abort('You are setting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '___errno_location')) {\n                Object.defineProperty(Module['ready'], '___errno_location', { configurable: true, get: function () { abort('You are getting ___errno_location on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '___errno_location', { configurable: true, set: function () { abort('You are setting ___errno_location on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_getNurbsCurve2D')) {\n                Object.defineProperty(Module['ready'], '_getNurbsCurve2D', { configurable: true, get: function () { abort('You are getting _getNurbsCurve2D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_getNurbsCurve2D', { configurable: true, set: function () { abort('You are setting _getNurbsCurve2D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_getNurbsCurve2DWithWeights')) {\n                Object.defineProperty(Module['ready'], '_getNurbsCurve2DWithWeights', { configurable: true, get: function () { abort('You are getting _getNurbsCurve2DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_getNurbsCurve2DWithWeights', { configurable: true, set: function () { abort('You are setting _getNurbsCurve2DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_evalNurbsCurve2D')) {\n                Object.defineProperty(Module['ready'], '_evalNurbsCurve2D', { configurable: true, get: function () { abort('You are getting _evalNurbsCurve2D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_evalNurbsCurve2D', { configurable: true, set: function () { abort('You are setting _evalNurbsCurve2D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_evalNurbsCurve2DWithWeights')) {\n                Object.defineProperty(Module['ready'], '_evalNurbsCurve2DWithWeights', { configurable: true, get: function () { abort('You are getting _evalNurbsCurve2DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_evalNurbsCurve2DWithWeights', { configurable: true, set: function () { abort('You are setting _evalNurbsCurve2DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_projectNurbsCurve2D')) {\n                Object.defineProperty(Module['ready'], '_projectNurbsCurve2D', { configurable: true, get: function () { abort('You are getting _projectNurbsCurve2D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_projectNurbsCurve2D', { configurable: true, set: function () { abort('You are setting _projectNurbsCurve2D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_disposeNurbsCurve2D')) {\n                Object.defineProperty(Module['ready'], '_disposeNurbsCurve2D', { configurable: true, get: function () { abort('You are getting _disposeNurbsCurve2D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_disposeNurbsCurve2D', { configurable: true, set: function () { abort('You are setting _disposeNurbsCurve2D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_disposeNurbsCurve2DWithWeights')) {\n                Object.defineProperty(Module['ready'], '_disposeNurbsCurve2DWithWeights', { configurable: true, get: function () { abort('You are getting _disposeNurbsCurve2DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_disposeNurbsCurve2DWithWeights', { configurable: true, set: function () { abort('You are setting _disposeNurbsCurve2DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_getNurbsCurve3D')) {\n                Object.defineProperty(Module['ready'], '_getNurbsCurve3D', { configurable: true, get: function () { abort('You are getting _getNurbsCurve3D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_getNurbsCurve3D', { configurable: true, set: function () { abort('You are setting _getNurbsCurve3D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_getNurbsCurve3DWithWeights')) {\n                Object.defineProperty(Module['ready'], '_getNurbsCurve3DWithWeights', { configurable: true, get: function () { abort('You are getting _getNurbsCurve3DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_getNurbsCurve3DWithWeights', { configurable: true, set: function () { abort('You are setting _getNurbsCurve3DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_evalNurbsCurve3D')) {\n                Object.defineProperty(Module['ready'], '_evalNurbsCurve3D', { configurable: true, get: function () { abort('You are getting _evalNurbsCurve3D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_evalNurbsCurve3D', { configurable: true, set: function () { abort('You are setting _evalNurbsCurve3D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_invertNurbsCurve3D')) {\n                Object.defineProperty(Module['ready'], '_invertNurbsCurve3D', { configurable: true, get: function () { abort('You are getting _invertNurbsCurve3D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_invertNurbsCurve3D', { configurable: true, set: function () { abort('You are setting _invertNurbsCurve3D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_evalNurbsCurve3DWithWeights')) {\n                Object.defineProperty(Module['ready'], '_evalNurbsCurve3DWithWeights', { configurable: true, get: function () { abort('You are getting _evalNurbsCurve3DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_evalNurbsCurve3DWithWeights', { configurable: true, set: function () { abort('You are setting _evalNurbsCurve3DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_evalNurbsCurve3dBulk')) {\n                Object.defineProperty(Module['ready'], '_evalNurbsCurve3dBulk', { configurable: true, get: function () { abort('You are getting _evalNurbsCurve3dBulk on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_evalNurbsCurve3dBulk', { configurable: true, set: function () { abort('You are setting _evalNurbsCurve3dBulk on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_disposeNurbsCurve3D')) {\n                Object.defineProperty(Module['ready'], '_disposeNurbsCurve3D', { configurable: true, get: function () { abort('You are getting _disposeNurbsCurve3D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_disposeNurbsCurve3D', { configurable: true, set: function () { abort('You are setting _disposeNurbsCurve3D on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_disposeNurbsCurve3DWithWeights')) {\n                Object.defineProperty(Module['ready'], '_disposeNurbsCurve3DWithWeights', { configurable: true, get: function () { abort('You are getting _disposeNurbsCurve3DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_disposeNurbsCurve3DWithWeights', { configurable: true, set: function () { abort('You are setting _disposeNurbsCurve3DWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_getNurbsSurface')) {\n                Object.defineProperty(Module['ready'], '_getNurbsSurface', { configurable: true, get: function () { abort('You are getting _getNurbsSurface on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_getNurbsSurface', { configurable: true, set: function () { abort('You are setting _getNurbsSurface on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_getNurbsSurfaceWithWeights')) {\n                Object.defineProperty(Module['ready'], '_getNurbsSurfaceWithWeights', { configurable: true, get: function () { abort('You are getting _getNurbsSurfaceWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_getNurbsSurfaceWithWeights', { configurable: true, set: function () { abort('You are setting _getNurbsSurfaceWithWeights on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_evalNurbsSurface')) {\n                Object.defineProperty(Module['ready'], '_evalNurbsSurface', { configurable: true, get: function () { abort('You are getting _evalNurbsSurface on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_evalNurbsSurface', { configurable: true, set: function () { abort('You are setting _evalNurbsSurface on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_evalNurbsSurfaceBulk')) {\n                Object.defineProperty(Module['ready'], '_evalNurbsSurfaceBulk', { configurable: true, get: function () { abort('You are getting _evalNurbsSurfaceBulk on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_evalNurbsSurfaceBulk', { configurable: true, set: function () { abort('You are setting _evalNurbsSurfaceBulk on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '_invertSurface')) {\n                Object.defineProperty(Module['ready'], '_invertSurface', { configurable: true, get: function () { abort('You are getting _invertSurface on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '_invertSurface', { configurable: true, set: function () { abort('You are setting _invertSurface on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '__Z19disposeNurbsSurfacePN10novo_nurbs7SurfaceIdEE')) {\n                Object.defineProperty(Module['ready'], '__Z19disposeNurbsSurfacePN10novo_nurbs7SurfaceIdEE', { configurable: true, get: function () { abort('You are getting __Z19disposeNurbsSurfacePN10novo_nurbs7SurfaceIdEE on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '__Z19disposeNurbsSurfacePN10novo_nurbs7SurfaceIdEE', { configurable: true, set: function () { abort('You are setting __Z19disposeNurbsSurfacePN10novo_nurbs7SurfaceIdEE on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], '__Z30disposeNurbsSurfaceWithWeightsPN10novo_nurbs15RationalSurfaceIdEE')) {\n                Object.defineProperty(Module['ready'], '__Z30disposeNurbsSurfaceWithWeightsPN10novo_nurbs15RationalSurfaceIdEE', { configurable: true, get: function () { abort('You are getting __Z30disposeNurbsSurfaceWithWeightsPN10novo_nurbs15RationalSurfaceIdEE on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], '__Z30disposeNurbsSurfaceWithWeightsPN10novo_nurbs15RationalSurfaceIdEE', { configurable: true, set: function () { abort('You are setting __Z30disposeNurbsSurfaceWithWeightsPN10novo_nurbs15RationalSurfaceIdEE on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            if (!Object.getOwnPropertyDescriptor(Module['ready'], 'onRuntimeInitialized')) {\n                Object.defineProperty(Module['ready'], 'onRuntimeInitialized', { configurable: true, get: function () { abort('You are getting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n                Object.defineProperty(Module['ready'], 'onRuntimeInitialized', { configurable: true, set: function () { abort('You are setting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });\n            }\n\n\n            // --pre-jses are emitted after the Module integration code, so that they can\n            // refer to Module (if they choose; they can also define Module)\n            // {{PRE_JSES}}\n\n            // Sometimes an existing Module object exists with properties\n            // meant to overwrite the default module functionality. Here\n            // we collect those properties and reapply _after_ we configure\n            // the current environment's defaults to avoid having to be so\n            // defensive during initialization.\n            var moduleOverrides = {};\n            var key;\n            for (key in Module) {\n                if (Module.hasOwnProperty(key)) {\n                    moduleOverrides[key] = Module[key];\n                }\n            }\n\n            var arguments_ = [];\n            var thisProgram = './this.program';\n            var quit_ = function (status, toThrow) {\n                throw toThrow;\n            };\n\n            // Determine the runtime environment we are in. You can customize this by\n            // setting the ENVIRONMENT setting at compile time (see settings.js).\n\n            var ENVIRONMENT_IS_WEB = false;\n            var ENVIRONMENT_IS_WORKER = true;\n            var ENVIRONMENT_IS_NODE = false;\n            var ENVIRONMENT_IS_SHELL = false;\n\n            if (Module['ENVIRONMENT']) {\n                throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');\n            }\n\n            // `/` should be present at the end if `scriptDirectory` is not empty\n            var scriptDirectory = '';\n            function locateFile(path) {\n                if (Module['locateFile']) {\n                    return Module['locateFile'](path, scriptDirectory);\n                }\n                return scriptDirectory + path;\n            }\n\n            // Hooks that are implemented differently in different runtime environments.\n            var read_,\n                readAsync,\n                readBinary,\n                setWindowTitle;\n\n            // Note that this includes Node.js workers when relevant (pthreads is enabled).\n            // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n            // ENVIRONMENT_IS_NODE.\n            if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n                if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n                    scriptDirectory = self.location.href;\n                } else if (typeof document !== 'undefined' && document.currentScript) { // web\n                    scriptDirectory = document.currentScript.src;\n                }\n                // When MODULARIZE, this JS may be executed later, after document.currentScript\n                // is gone, so we saved it, and we use it here instead of any other info.\n                if (_scriptDir) {\n                    scriptDirectory = _scriptDir;\n                }\n                // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n                // otherwise, slice off the final part of the url to find the script directory.\n                // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n                // and scriptDirectory will correctly be replaced with an empty string.\n                if (scriptDirectory.indexOf('blob:') !== 0) {\n                    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/') + 1);\n                } else {\n                    scriptDirectory = '';\n                }\n\n                if (!(typeof window === 'object' || typeof importScripts === 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n                // Differentiate the Web Worker from the Node Worker case, as reading must\n                // be done differently.\n                {\n\n                    // include: web_or_worker_shell_read.js\n\n\n                    read_ = function (url) {\n                        var xhr = new XMLHttpRequest();\n                        xhr.open('GET', url, false);\n                        xhr.send(null);\n                        return xhr.responseText;\n                    };\n\n                    if (ENVIRONMENT_IS_WORKER) {\n                        readBinary = function (url) {\n                            var xhr = new XMLHttpRequest();\n                            xhr.open('GET', url, false);\n                            xhr.responseType = 'arraybuffer';\n                            xhr.send(null);\n                            return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\n                        };\n                    }\n\n                    readAsync = function (url, onload, onerror) {\n                        var xhr = new XMLHttpRequest();\n                        xhr.open('GET', url, true);\n                        xhr.responseType = 'arraybuffer';\n                        xhr.onload = function () {\n                            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n                                onload(xhr.response);\n                                return;\n                            }\n                            onerror();\n                        };\n                        xhr.onerror = onerror;\n                        xhr.send(null);\n                    };\n\n                    // end include: web_or_worker_shell_read.js\n                }\n\n                setWindowTitle = function (title) { document.title = title };\n            } else {\n                throw new Error('environment detection error');\n            }\n\n            // Set up the out() and err() hooks, which are how we can print to stdout or\n            // stderr, respectively.\n            var out = Module['print'] || console.log.bind(console);\n            var err = Module['printErr'] || console.warn.bind(console);\n\n            // Merge back in the overrides\n            for (key in moduleOverrides) {\n                if (moduleOverrides.hasOwnProperty(key)) {\n                    Module[key] = moduleOverrides[key];\n                }\n            }\n            // Free the object hierarchy contained in the overrides, this lets the GC\n            // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n            moduleOverrides = null;\n\n            // Emit code to handle expected values on the Module object. This applies Module.x\n            // to the proper local x. This has two benefits: first, we only emit it if it is\n            // expected to arrive, and second, by using a local everywhere else that can be\n            // minified.\n\n            if (Module['arguments']) arguments_ = Module['arguments'];\n            if (!Object.getOwnPropertyDescriptor(Module, 'arguments')) {\n                Object.defineProperty(Module, 'arguments', {\n                    configurable: true,\n                    get: function () {\n                        abort('Module.arguments has been replaced with plain arguments_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)')\n                    }\n                });\n            }\n\n            if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n            if (!Object.getOwnPropertyDescriptor(Module, 'thisProgram')) {\n                Object.defineProperty(Module, 'thisProgram', {\n                    configurable: true,\n                    get: function () {\n                        abort('Module.thisProgram has been replaced with plain thisProgram (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)')\n                    }\n                });\n            }\n\n            if (Module['quit']) quit_ = Module['quit'];\n            if (!Object.getOwnPropertyDescriptor(Module, 'quit')) {\n                Object.defineProperty(Module, 'quit', {\n                    configurable: true,\n                    get: function () {\n                        abort('Module.quit has been replaced with plain quit_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)')\n                    }\n                });\n            }\n\n            // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n            // Assertions on removed incoming Module JS APIs.\n            assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\n            assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\n            assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\n            assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\n            assert(typeof Module['read'] === 'undefined', 'Module.read option was removed (modify read_ in JS)');\n            assert(typeof Module['readAsync'] === 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\n            assert(typeof Module['readBinary'] === 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\n            assert(typeof Module['setWindowTitle'] === 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');\n            assert(typeof Module['TOTAL_MEMORY'] === 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\n\n            if (!Object.getOwnPropertyDescriptor(Module, 'read')) {\n                Object.defineProperty(Module, 'read', {\n                    configurable: true,\n                    get: function () {\n                        abort('Module.read has been replaced with plain read_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)')\n                    }\n                });\n            }\n\n            if (!Object.getOwnPropertyDescriptor(Module, 'readAsync')) {\n                Object.defineProperty(Module, 'readAsync', {\n                    configurable: true,\n                    get: function () {\n                        abort('Module.readAsync has been replaced with plain readAsync (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)')\n                    }\n                });\n            }\n\n            if (!Object.getOwnPropertyDescriptor(Module, 'readBinary')) {\n                Object.defineProperty(Module, 'readBinary', {\n                    configurable: true,\n                    get: function () {\n                        abort('Module.readBinary has been replaced with plain readBinary (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)')\n                    }\n                });\n            }\n\n            if (!Object.getOwnPropertyDescriptor(Module, 'setWindowTitle')) {\n                Object.defineProperty(Module, 'setWindowTitle', {\n                    configurable: true,\n                    get: function () {\n                        abort('Module.setWindowTitle has been replaced with plain setWindowTitle (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)')\n                    }\n                });\n            }\n            var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\n            var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\n            var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\n            var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\n\n\n\n\n            var STACK_ALIGN = 16;\n\n            function alignMemory(size, factor) {\n                if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n                return Math.ceil(size / factor) * factor;\n            }\n\n            function getNativeTypeSize(type) {\n                switch (type) {\n                    case 'i1': case 'i8': return 1;\n                    case 'i16': return 2;\n                    case 'i32': return 4;\n                    case 'i64': return 8;\n                    case 'float': return 4;\n                    case 'double': return 8;\n                    default: {\n                        if (type[type.length - 1] === '*') {\n                            return 4; // A pointer\n                        } else if (type[0] === 'i') {\n                            var bits = Number(type.substr(1));\n                            assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n                            return bits / 8;\n                        } else {\n                            return 0;\n                        }\n                    }\n                }\n            }\n\n            function warnOnce(text) {\n                if (!warnOnce.shown) warnOnce.shown = {};\n                if (!warnOnce.shown[text]) {\n                    warnOnce.shown[text] = 1;\n                    err(text);\n                }\n            }\n\n            // include: runtime_functions.js\n\n\n            // Wraps a JS function as a wasm function with a given signature.\n            function convertJsFunctionToWasm(func, sig) {\n\n                // If the type reflection proposal is available, use the new\n                // \"WebAssembly.Function\" constructor.\n                // Otherwise, construct a minimal wasm module importing the JS function and\n                // re-exporting it.\n                if (typeof WebAssembly.Function === \"function\") {\n                    var typeNames = {\n                        'i': 'i32',\n                        'j': 'i64',\n                        'f': 'f32',\n                        'd': 'f64'\n                    };\n                    var type = {\n                        parameters: [],\n                        results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\n                    };\n                    for (var i = 1; i < sig.length; ++i) {\n                        type.parameters.push(typeNames[sig[i]]);\n                    }\n                    return new WebAssembly.Function(type, func);\n                }\n\n                // The module is static, with the exception of the type section, which is\n                // generated based on the signature passed in.\n                var typeSection = [\n                    0x01, // id: section,\n                    0x00, // length: 0 (placeholder)\n                    0x01, // count: 1\n                    0x60, // form: func\n                ];\n                var sigRet = sig.slice(0, 1);\n                var sigParam = sig.slice(1);\n                var typeCodes = {\n                    'i': 0x7f, // i32\n                    'j': 0x7e, // i64\n                    'f': 0x7d, // f32\n                    'd': 0x7c, // f64\n                };\n\n                // Parameters, length + signatures\n                typeSection.push(sigParam.length);\n                for (var i = 0; i < sigParam.length; ++i) {\n                    typeSection.push(typeCodes[sigParam[i]]);\n                }\n\n                // Return values, length + signatures\n                // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n                if (sigRet == 'v') {\n                    typeSection.push(0x00);\n                } else {\n                    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\n                }\n\n                // Write the overall length of the type section back into the section header\n                // (excepting the 2 bytes for the section id and length)\n                typeSection[1] = typeSection.length - 2;\n\n                // Rest of the module is static\n                var bytes = new Uint8Array([\n                    0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\n                    0x01, 0x00, 0x00, 0x00, // version: 1\n                ].concat(typeSection, [\n                    0x02, 0x07, // import section\n                    // (import \"e\" \"f\" (func 0 (type 0)))\n                    0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,\n                    0x07, 0x05, // export section\n                    // (export \"f\" (func 0 (type 0)))\n                    0x01, 0x01, 0x66, 0x00, 0x00,\n                ]));\n\n                // We can compile this wasm module synchronously because it is very small.\n                // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n                var module = new WebAssembly.Module(bytes);\n                var instance = new WebAssembly.Instance(module, {\n                    'e': {\n                        'f': func\n                    }\n                });\n                var wrappedFunc = instance.exports['f'];\n                return wrappedFunc;\n            }\n\n            var freeTableIndexes = [];\n\n            // Weak map of functions in the table to their indexes, created on first use.\n            var functionsInTableMap;\n\n            function getEmptyTableSlot() {\n                // Reuse a free index if there is one, otherwise grow.\n                if (freeTableIndexes.length) {\n                    return freeTableIndexes.pop();\n                }\n                // Grow the table\n                try {\n                    wasmTable.grow(1);\n                } catch (err) {\n                    if (!(err instanceof RangeError)) {\n                        throw err;\n                    }\n                    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';\n                }\n                return wasmTable.length - 1;\n            }\n\n            // Add a wasm function to the table.\n            function addFunctionWasm(func, sig) {\n                // Check if the function is already in the table, to ensure each function\n                // gets a unique index. First, create the map if this is the first use.\n                if (!functionsInTableMap) {\n                    functionsInTableMap = new WeakMap();\n                    for (var i = 0; i < wasmTable.length; i++) {\n                        var item = wasmTable.get(i);\n                        // Ignore null values.\n                        if (item) {\n                            functionsInTableMap.set(item, i);\n                        }\n                    }\n                }\n                if (functionsInTableMap.has(func)) {\n                    return functionsInTableMap.get(func);\n                }\n\n                // It's not in the table, add it now.\n\n                var ret = getEmptyTableSlot();\n\n                // Set the new value.\n                try {\n                    // Attempting to call this with JS function will cause of table.set() to fail\n                    wasmTable.set(ret, func);\n                } catch (err) {\n                    if (!(err instanceof TypeError)) {\n                        throw err;\n                    }\n                    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction: ' + func);\n                    var wrapped = convertJsFunctionToWasm(func, sig);\n                    wasmTable.set(ret, wrapped);\n                }\n\n                functionsInTableMap.set(func, ret);\n\n                return ret;\n            }\n\n            function removeFunction(index) {\n                functionsInTableMap.delete(wasmTable.get(index));\n                freeTableIndexes.push(index);\n            }\n\n            // 'sig' parameter is required for the llvm backend but only when func is not\n            // already a WebAssembly function.\n            function addFunction(func, sig) {\n                assert(typeof func !== 'undefined');\n\n                return addFunctionWasm(func, sig);\n            }\n\n            // end include: runtime_functions.js\n            // include: runtime_debug.js\n\n\n            // end include: runtime_debug.js\n            var tempRet0 = 0;\n\n            var setTempRet0 = function (value) {\n                tempRet0 = value;\n            };\n\n            var getTempRet0 = function () {\n                return tempRet0;\n            };\n\n\n\n            // === Preamble library stuff ===\n\n            // Documentation for the public APIs defined in this file must be updated in:\n            //    site/source/docs/api_reference/preamble.js.rst\n            // A prebuilt local version of the documentation is available at:\n            //    site/build/text/docs/api_reference/preamble.js.txt\n            // You can also build docs locally as HTML or other formats in site/\n            // An online HTML version (which may be of a different version of Emscripten)\n            //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n            var wasmBinary;\n            if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n            if (!Object.getOwnPropertyDescriptor(Module, 'wasmBinary')) {\n                Object.defineProperty(Module, 'wasmBinary', {\n                    configurable: true,\n                    get: function () {\n                        abort('Module.wasmBinary has been replaced with plain wasmBinary (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)')\n                    }\n                });\n            }\n            var noExitRuntime = Module['noExitRuntime'] || true;\n            if (!Object.getOwnPropertyDescriptor(Module, 'noExitRuntime')) {\n                Object.defineProperty(Module, 'noExitRuntime', {\n                    configurable: true,\n                    get: function () {\n                        abort('Module.noExitRuntime has been replaced with plain noExitRuntime (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)')\n                    }\n                });\n            }\n\n            if (typeof WebAssembly !== 'object') {\n                abort('no native wasm support detected');\n            }\n\n            // include: runtime_safe_heap.js\n\n\n            // In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.\n            // In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)\n\n            /** @param {number} ptr\n                @param {number} value\n                @param {string} type\n                @param {number|boolean=} noSafe */\n            function setValue(ptr, value, type, noSafe) {\n                type = type || 'i8';\n                if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n                switch (type) {\n                    case 'i1': HEAP8[((ptr) >> 0)] = value; break;\n                    case 'i8': HEAP8[((ptr) >> 0)] = value; break;\n                    case 'i16': HEAP16[((ptr) >> 1)] = value; break;\n                    case 'i32': HEAP32[((ptr) >> 2)] = value; break;\n                    case 'i64': (tempI64 = [value >>> 0, (tempDouble = value, (+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble) / 4294967296.0))), 4294967295.0)) | 0) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], HEAP32[((ptr) >> 2)] = tempI64[0], HEAP32[(((ptr) + (4)) >> 2)] = tempI64[1]); break;\n                    case 'float': HEAPF32[((ptr) >> 2)] = value; break;\n                    case 'double': HEAPF64[((ptr) >> 3)] = value; break;\n                    default: abort('invalid type for setValue: ' + type);\n                }\n            }\n\n            /** @param {number} ptr\n                @param {string} type\n                @param {number|boolean=} noSafe */\n            function getValue(ptr, type, noSafe) {\n                type = type || 'i8';\n                if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n                switch (type) {\n                    case 'i1': return HEAP8[((ptr) >> 0)];\n                    case 'i8': return HEAP8[((ptr) >> 0)];\n                    case 'i16': return HEAP16[((ptr) >> 1)];\n                    case 'i32': return HEAP32[((ptr) >> 2)];\n                    case 'i64': return HEAP32[((ptr) >> 2)];\n                    case 'float': return HEAPF32[((ptr) >> 2)];\n                    case 'double': return HEAPF64[((ptr) >> 3)];\n                    default: abort('invalid type for getValue: ' + type);\n                }\n                return null;\n            }\n\n            // end include: runtime_safe_heap.js\n            // Wasm globals\n\n            var wasmMemory;\n\n            //========================================\n            // Runtime essentials\n            //========================================\n\n            // whether we are quitting the application. no code should run after this.\n            // set in exit() and abort()\n            var ABORT = false;\n\n            // set by exit() and abort().  Passed to 'onExit' handler.\n            // NOTE: This is also used as the process return code code in shell environments\n            // but only when noExitRuntime is false.\n            var EXITSTATUS;\n\n            /** @type {function(*, string=)} */\n            function assert(condition, text) {\n                if (!condition) {\n                    abort('Assertion failed: ' + text);\n                }\n            }\n\n            // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\n            function getCFunc(ident) {\n                var func = Module['_' + ident]; // closure exported function\n                assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n                return func;\n            }\n\n            // C calling interface.\n            /** @param {string|null=} returnType\n                @param {Array=} argTypes\n                @param {Arguments|Array=} args\n                @param {Object=} opts */\n            function ccall(ident, returnType, argTypes, args, opts) {\n                // For fast lookup of conversion functions\n                var toC = {\n                    'string': function (str) {\n                        var ret = 0;\n                        if (str !== null && str !== undefined && str !== 0) { // null string\n                            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n                            var len = (str.length << 2) + 1;\n                            ret = stackAlloc(len);\n                            stringToUTF8(str, ret, len);\n                        }\n                        return ret;\n                    },\n                    'array': function (arr) {\n                        var ret = stackAlloc(arr.length);\n                        writeArrayToMemory(arr, ret);\n                        return ret;\n                    }\n                };\n\n                function convertReturnValue(ret) {\n                    if (returnType === 'string') return UTF8ToString(ret);\n                    if (returnType === 'boolean') return Boolean(ret);\n                    return ret;\n                }\n\n                var func = getCFunc(ident);\n                var cArgs = [];\n                var stack = 0;\n                assert(returnType !== 'array', 'Return type should not be \"array\".');\n                if (args) {\n                    for (var i = 0; i < args.length; i++) {\n                        var converter = toC[argTypes[i]];\n                        if (converter) {\n                            if (stack === 0) stack = stackSave();\n                            cArgs[i] = converter(args[i]);\n                        } else {\n                            cArgs[i] = args[i];\n                        }\n                    }\n                }\n                var ret = func.apply(null, cArgs);\n\n                ret = convertReturnValue(ret);\n                if (stack !== 0) stackRestore(stack);\n                return ret;\n            }\n\n            /** @param {string=} returnType\n                @param {Array=} argTypes\n                @param {Object=} opts */\n            function cwrap(ident, returnType, argTypes, opts) {\n                return function () {\n                    return ccall(ident, returnType, argTypes, arguments, opts);\n                }\n            }\n\n            // We used to include malloc/free by default in the past. Show a helpful error in\n            // builds with assertions.\n\n            var ALLOC_NORMAL = 0; // Tries to use _malloc()\n            var ALLOC_STACK = 1; // Lives for the duration of the current function call\n\n            // allocate(): This is for internal use. You can use it yourself as well, but the interface\n            //             is a little tricky (see docs right below). The reason is that it is optimized\n            //             for multiple syntaxes to save space in generated code. So you should\n            //             normally not use allocate(), and instead allocate memory using _malloc(),\n            //             initialize it with setValue(), and so forth.\n            // @slab: An array of data.\n            // @allocator: How to allocate memory, see ALLOC_*\n            /** @type {function((Uint8Array|Array<number>), number)} */\n            function allocate(slab, allocator) {\n                var ret;\n                assert(typeof allocator === 'number', 'allocate no longer takes a type argument')\n                assert(typeof slab !== 'number', 'allocate no longer takes a number as arg0')\n\n                if (allocator == ALLOC_STACK) {\n                    ret = stackAlloc(slab.length);\n                } else {\n                    ret = _malloc(slab.length);\n                }\n\n                if (slab.subarray || slab.slice) {\n                    HEAPU8.set(/** @type {!Uint8Array} */(slab), ret);\n                } else {\n                    HEAPU8.set(new Uint8Array(slab), ret);\n                }\n                return ret;\n            }\n\n            // include: runtime_strings.js\n\n\n            // runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\n\n            // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n            // a copy of that string as a Javascript String object.\n\n            var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n\n            /**\n             * @param {number} idx\n             * @param {number=} maxBytesToRead\n             * @return {string}\n             */\n            function UTF8ArrayToString(heap, idx, maxBytesToRead) {\n                var endIdx = idx + maxBytesToRead;\n                var endPtr = idx;\n                // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n                // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n                // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n                while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n                if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n                    return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n                } else {\n                    var str = '';\n                    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n                    while (idx < endPtr) {\n                        // For UTF8 byte structure, see:\n                        // http://en.wikipedia.org/wiki/UTF-8#Description\n                        // https://www.ietf.org/rfc/rfc2279.txt\n                        // https://tools.ietf.org/html/rfc3629\n                        var u0 = heap[idx++];\n                        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n                        var u1 = heap[idx++] & 63;\n                        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n                        var u2 = heap[idx++] & 63;\n                        if ((u0 & 0xF0) == 0xE0) {\n                            u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n                        } else {\n                            if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\n                            u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);\n                        }\n\n                        if (u0 < 0x10000) {\n                            str += String.fromCharCode(u0);\n                        } else {\n                            var ch = u0 - 0x10000;\n                            str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n                        }\n                    }\n                }\n                return str;\n            }\n\n            // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n            // copy of that string as a Javascript String object.\n            // maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n            //                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n            //                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n            //                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n            //                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n            //                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n            //                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n            //                 style or the other.\n            /**\n             * @param {number} ptr\n             * @param {number=} maxBytesToRead\n             * @return {string}\n             */\n            function UTF8ToString(ptr, maxBytesToRead) {\n                return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n            }\n\n            // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n            // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n            // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n            // Parameters:\n            //   str: the Javascript string to copy.\n            //   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n            //   outIdx: The starting offset in the array to begin the copying.\n            //   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n            //                    This count should include the null terminator,\n            //                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n            //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n            // Returns the number of bytes written, EXCLUDING the null terminator.\n\n            function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n                if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n                    return 0;\n\n                var startIdx = outIdx;\n                var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n                for (var i = 0; i < str.length; ++i) {\n                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n                    // See http://unicode.org/faq/utf_bom.html#utf16-3\n                    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n                    var u = str.charCodeAt(i); // possibly a lead surrogate\n                    if (u >= 0xD800 && u <= 0xDFFF) {\n                        var u1 = str.charCodeAt(++i);\n                        u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n                    }\n                    if (u <= 0x7F) {\n                        if (outIdx >= endIdx) break;\n                        heap[outIdx++] = u;\n                    } else if (u <= 0x7FF) {\n                        if (outIdx + 1 >= endIdx) break;\n                        heap[outIdx++] = 0xC0 | (u >> 6);\n                        heap[outIdx++] = 0x80 | (u & 63);\n                    } else if (u <= 0xFFFF) {\n                        if (outIdx + 2 >= endIdx) break;\n                        heap[outIdx++] = 0xE0 | (u >> 12);\n                        heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n                        heap[outIdx++] = 0x80 | (u & 63);\n                    } else {\n                        if (outIdx + 3 >= endIdx) break;\n                        if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x1FFFFF).');\n                        heap[outIdx++] = 0xF0 | (u >> 18);\n                        heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n                        heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n                        heap[outIdx++] = 0x80 | (u & 63);\n                    }\n                }\n                // Null-terminate the pointer to the buffer.\n                heap[outIdx] = 0;\n                return outIdx - startIdx;\n            }\n\n            // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n            // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n            // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n            // Returns the number of bytes written, EXCLUDING the null terminator.\n\n            function stringToUTF8(str, outPtr, maxBytesToWrite) {\n                assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n                return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n            }\n\n            // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n            function lengthBytesUTF8(str) {\n                var len = 0;\n                for (var i = 0; i < str.length; ++i) {\n                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n                    // See http://unicode.org/faq/utf_bom.html#utf16-3\n                    var u = str.charCodeAt(i); // possibly a lead surrogate\n                    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n                    if (u <= 0x7F) ++len;\n                    else if (u <= 0x7FF) len += 2;\n                    else if (u <= 0xFFFF) len += 3;\n                    else len += 4;\n                }\n                return len;\n            }\n\n            // end include: runtime_strings.js\n            // include: runtime_strings_extra.js\n\n\n            // runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.\n\n            // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n            // a copy of that string as a Javascript String object.\n\n            function AsciiToString(ptr) {\n                var str = '';\n                while (1) {\n                    var ch = HEAPU8[((ptr++) >> 0)];\n                    if (!ch) return str;\n                    str += String.fromCharCode(ch);\n                }\n            }\n\n            // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n            // null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\n            function stringToAscii(str, outPtr) {\n                return writeAsciiToMemory(str, outPtr, false);\n            }\n\n            // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n            // a copy of that string as a Javascript String object.\n\n            var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\n            function UTF16ToString(ptr, maxBytesToRead) {\n                assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n                var endPtr = ptr;\n                // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n                // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n                var idx = endPtr >> 1;\n                var maxIdx = idx + maxBytesToRead / 2;\n                // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n                // will always evaluate to true. This saves on code size.\n                while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n                endPtr = idx << 1;\n\n                if (endPtr - ptr > 32 && UTF16Decoder) {\n                    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n                } else {\n                    var str = '';\n\n                    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition\n                    // will always evaluate to true. The loop is then terminated on the first null char.\n                    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n                        var codeUnit = HEAP16[(((ptr) + (i * 2)) >> 1)];\n                        if (codeUnit == 0) break;\n                        // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n                        str += String.fromCharCode(codeUnit);\n                    }\n\n                    return str;\n                }\n            }\n\n            // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n            // null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n            // Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n            // Parameters:\n            //   str: the Javascript string to copy.\n            //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n            //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n            //                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n            //                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n            // Returns the number of bytes written, EXCLUDING the null terminator.\n\n            function stringToUTF16(str, outPtr, maxBytesToWrite) {\n                assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n                assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n                // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n                if (maxBytesToWrite === undefined) {\n                    maxBytesToWrite = 0x7FFFFFFF;\n                }\n                if (maxBytesToWrite < 2) return 0;\n                maxBytesToWrite -= 2; // Null terminator.\n                var startPtr = outPtr;\n                var numCharsToWrite = (maxBytesToWrite < str.length * 2) ? (maxBytesToWrite / 2) : str.length;\n                for (var i = 0; i < numCharsToWrite; ++i) {\n                    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n                    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n                    HEAP16[((outPtr) >> 1)] = codeUnit;\n                    outPtr += 2;\n                }\n                // Null-terminate the pointer to the HEAP.\n                HEAP16[((outPtr) >> 1)] = 0;\n                return outPtr - startPtr;\n            }\n\n            // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n            function lengthBytesUTF16(str) {\n                return str.length * 2;\n            }\n\n            function UTF32ToString(ptr, maxBytesToRead) {\n                assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n                var i = 0;\n\n                var str = '';\n                // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n                // will always evaluate to true. This saves on code size.\n                while (!(i >= maxBytesToRead / 4)) {\n                    var utf32 = HEAP32[(((ptr) + (i * 4)) >> 2)];\n                    if (utf32 == 0) break;\n                    ++i;\n                    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n                    // See http://unicode.org/faq/utf_bom.html#utf16-3\n                    if (utf32 >= 0x10000) {\n                        var ch = utf32 - 0x10000;\n                        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n                    } else {\n                        str += String.fromCharCode(utf32);\n                    }\n                }\n                return str;\n            }\n\n            // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n            // null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n            // Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n            // Parameters:\n            //   str: the Javascript string to copy.\n            //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n            //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n            //                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n            //                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n            // Returns the number of bytes written, EXCLUDING the null terminator.\n\n            function stringToUTF32(str, outPtr, maxBytesToWrite) {\n                assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n                assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n                // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n                if (maxBytesToWrite === undefined) {\n                    maxBytesToWrite = 0x7FFFFFFF;\n                }\n                if (maxBytesToWrite < 4) return 0;\n                var startPtr = outPtr;\n                var endPtr = startPtr + maxBytesToWrite - 4;\n                for (var i = 0; i < str.length; ++i) {\n                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n                    // See http://unicode.org/faq/utf_bom.html#utf16-3\n                    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n                    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n                        var trailSurrogate = str.charCodeAt(++i);\n                        codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n                    }\n                    HEAP32[((outPtr) >> 2)] = codeUnit;\n                    outPtr += 4;\n                    if (outPtr + 4 > endPtr) break;\n                }\n                // Null-terminate the pointer to the HEAP.\n                HEAP32[((outPtr) >> 2)] = 0;\n                return outPtr - startPtr;\n            }\n\n            // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n            function lengthBytesUTF32(str) {\n                var len = 0;\n                for (var i = 0; i < str.length; ++i) {\n                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n                    // See http://unicode.org/faq/utf_bom.html#utf16-3\n                    var codeUnit = str.charCodeAt(i);\n                    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n                    len += 4;\n                }\n\n                return len;\n            }\n\n            // Allocate heap space for a JS string, and write it there.\n            // It is the responsibility of the caller to free() that memory.\n            function allocateUTF8(str) {\n                var size = lengthBytesUTF8(str) + 1;\n                var ret = _malloc(size);\n                if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n                return ret;\n            }\n\n            // Allocate stack space for a JS string, and write it there.\n            function allocateUTF8OnStack(str) {\n                var size = lengthBytesUTF8(str) + 1;\n                var ret = stackAlloc(size);\n                stringToUTF8Array(str, HEAP8, ret, size);\n                return ret;\n            }\n\n            // Deprecated: This function should not be called because it is unsafe and does not provide\n            // a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n            // function stringToUTF8Array() instead, which takes in a maximum length that can be used\n            // to be secure from out of bounds writes.\n            /** @deprecated\n                @param {boolean=} dontAddNull */\n            function writeStringToMemory(string, buffer, dontAddNull) {\n                warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n\n                var /** @type {number} */ lastChar, /** @type {number} */ end;\n                if (dontAddNull) {\n                    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n                    // character that existed at the location where the null will be placed, and restore\n                    // that after the write (below).\n                    end = buffer + lengthBytesUTF8(string);\n                    lastChar = HEAP8[end];\n                }\n                stringToUTF8(string, buffer, Infinity);\n                if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n            }\n\n            function writeArrayToMemory(array, buffer) {\n                assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')\n                HEAP8.set(array, buffer);\n            }\n\n            /** @param {boolean=} dontAddNull */\n            function writeAsciiToMemory(str, buffer, dontAddNull) {\n                for (var i = 0; i < str.length; ++i) {\n                    assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);\n                    HEAP8[((buffer++) >> 0)] = str.charCodeAt(i);\n                }\n                // Null-terminate the pointer to the HEAP.\n                if (!dontAddNull) HEAP8[((buffer) >> 0)] = 0;\n            }\n\n            // end include: runtime_strings_extra.js\n            // Memory management\n\n            function alignUp(x, multiple) {\n                if (x % multiple > 0) {\n                    x += multiple - (x % multiple);\n                }\n                return x;\n            }\n\n            var HEAP,\n                /** @type {ArrayBuffer} */\n                buffer,\n                /** @type {Int8Array} */\n                HEAP8,\n                /** @type {Uint8Array} */\n                HEAPU8,\n                /** @type {Int16Array} */\n                HEAP16,\n                /** @type {Uint16Array} */\n                HEAPU16,\n                /** @type {Int32Array} */\n                HEAP32,\n                /** @type {Uint32Array} */\n                HEAPU32,\n                /** @type {Float32Array} */\n                HEAPF32,\n                /** @type {Float64Array} */\n                HEAPF64;\n\n            function updateGlobalBufferAndViews(buf) {\n                buffer = buf;\n                Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n                Module['HEAP16'] = HEAP16 = new Int16Array(buf);\n                Module['HEAP32'] = HEAP32 = new Int32Array(buf);\n                Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n                Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\n                Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n                Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\n                Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\n            }\n\n            var TOTAL_STACK = 5242880;\n            if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')\n\n            var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;\n            if (!Object.getOwnPropertyDescriptor(Module, 'INITIAL_MEMORY')) {\n                Object.defineProperty(Module, 'INITIAL_MEMORY', {\n                    configurable: true,\n                    get: function () {\n                        abort('Module.INITIAL_MEMORY has been replaced with plain INITIAL_MEMORY (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)')\n                    }\n                });\n            }\n\n            assert(INITIAL_MEMORY >= TOTAL_STACK, 'INITIAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');\n\n            // check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n            assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,\n                'JS engine does not provide full typed array support');\n\n            // If memory is defined in wasm, the user can't provide it.\n            assert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -s IMPORTED_MEMORY to define wasmMemory externally');\n            assert(INITIAL_MEMORY == 16777216, 'Detected runtime INITIAL_MEMORY setting.  Use -s IMPORTED_MEMORY to define wasmMemory dynamically');\n\n            // include: runtime_init_table.js\n            // In regular non-RELOCATABLE mode the table is exported\n            // from the wasm module and this will be assigned once\n            // the exports are available.\n            var wasmTable;\n\n            // end include: runtime_init_table.js\n            // include: runtime_stack_check.js\n\n\n            // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n            function writeStackCookie() {\n                var max = _emscripten_stack_get_end();\n                assert((max & 3) == 0);\n                // The stack grows downwards\n                HEAPU32[(max >> 2) + 1] = 0x2135467;\n                HEAPU32[(max >> 2) + 2] = 0x89BACDFE;\n                // Also test the global address 0 for integrity.\n                HEAP32[0] = 0x63736d65; /* 'emsc' */\n            }\n\n            function checkStackCookie() {\n                if (ABORT) return;\n                var max = _emscripten_stack_get_end();\n                var cookie1 = HEAPU32[(max >> 2) + 1];\n                var cookie2 = HEAPU32[(max >> 2) + 2];\n                if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {\n                    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));\n                }\n                // Also test the global address 0 for integrity.\n                if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n            }\n\n            // end include: runtime_stack_check.js\n            // include: runtime_assertions.js\n\n\n            // Endianness check\n            (function () {\n                var h16 = new Int16Array(1);\n                var h8 = new Int8Array(h16.buffer);\n                h16[0] = 0x6373;\n                if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -s SUPPORT_BIG_ENDIAN=1 to bypass)';\n            })();\n\n            // end include: runtime_assertions.js\n            var __ATPRERUN__ = []; // functions called before the runtime is initialized\n            var __ATINIT__ = []; // functions called during startup\n            var __ATMAIN__ = []; // functions called when main() is to be run\n            var __ATEXIT__ = []; // functions called during shutdown\n            var __ATPOSTRUN__ = []; // functions called after the main() is called\n\n            var runtimeInitialized = false;\n            var runtimeExited = false;\n\n            function preRun() {\n\n                if (Module['preRun']) {\n                    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n                    while (Module['preRun'].length) {\n                        addOnPreRun(Module['preRun'].shift());\n                    }\n                }\n\n                callRuntimeCallbacks(__ATPRERUN__);\n            }\n\n            function initRuntime() {\n                checkStackCookie();\n                assert(!runtimeInitialized);\n                runtimeInitialized = true;\n\n\n                callRuntimeCallbacks(__ATINIT__);\n            }\n\n            function exitRuntime() {\n                checkStackCookie();\n                runtimeExited = true;\n            }\n\n            function postRun() {\n                checkStackCookie();\n\n                if (Module['postRun']) {\n                    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n                    while (Module['postRun'].length) {\n                        addOnPostRun(Module['postRun'].shift());\n                    }\n                }\n\n                callRuntimeCallbacks(__ATPOSTRUN__);\n            }\n\n            function addOnPreRun(cb) {\n                __ATPRERUN__.unshift(cb);\n            }\n\n            function addOnInit(cb) {\n                __ATINIT__.unshift(cb);\n            }\n\n            function addOnPreMain(cb) {\n                __ATMAIN__.unshift(cb);\n            }\n\n            function addOnExit(cb) {\n            }\n\n            function addOnPostRun(cb) {\n                __ATPOSTRUN__.unshift(cb);\n            }\n\n            // include: runtime_math.js\n\n\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\n            assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n            assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n            assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n            assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n\n            // end include: runtime_math.js\n            // A counter of dependencies for calling run(). If we need to\n            // do asynchronous work before running, increment this and\n            // decrement it. Incrementing must happen in a place like\n            // Module.preRun (used by emcc to add file preloading).\n            // Note that you can add dependencies in preRun, even though\n            // it happens right before run - run will be postponed until\n            // the dependencies are met.\n            var runDependencies = 0;\n            var runDependencyWatcher = null;\n            var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n            var runDependencyTracking = {};\n\n            function getUniqueRunDependency(id) {\n                var orig = id;\n                while (1) {\n                    if (!runDependencyTracking[id]) return id;\n                    id = orig + Math.random();\n                }\n            }\n\n            function addRunDependency(id) {\n                runDependencies++;\n\n                if (Module['monitorRunDependencies']) {\n                    Module['monitorRunDependencies'](runDependencies);\n                }\n\n                if (id) {\n                    assert(!runDependencyTracking[id]);\n                    runDependencyTracking[id] = 1;\n                    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n                        // Check for missing dependencies every few seconds\n                        runDependencyWatcher = setInterval(function () {\n                            if (ABORT) {\n                                clearInterval(runDependencyWatcher);\n                                runDependencyWatcher = null;\n                                return;\n                            }\n                            var shown = false;\n                            for (var dep in runDependencyTracking) {\n                                if (!shown) {\n                                    shown = true;\n                                    err('still waiting on run dependencies:');\n                                }\n                                err('dependency: ' + dep);\n                            }\n                            if (shown) {\n                                err('(end of list)');\n                            }\n                        }, 10000);\n                    }\n                } else {\n                    err('warning: run dependency added without ID');\n                }\n            }\n\n            function removeRunDependency(id) {\n                runDependencies--;\n\n                if (Module['monitorRunDependencies']) {\n                    Module['monitorRunDependencies'](runDependencies);\n                }\n\n                if (id) {\n                    assert(runDependencyTracking[id]);\n                    delete runDependencyTracking[id];\n                } else {\n                    err('warning: run dependency removed without ID');\n                }\n                if (runDependencies == 0) {\n                    if (runDependencyWatcher !== null) {\n                        clearInterval(runDependencyWatcher);\n                        runDependencyWatcher = null;\n                    }\n                    if (dependenciesFulfilled) {\n                        var callback = dependenciesFulfilled;\n                        dependenciesFulfilled = null;\n                        callback(); // can add another dependenciesFulfilled\n                    }\n                }\n            }\n\n            Module[\"preloadedImages\"] = {}; // maps url to image data\n            Module[\"preloadedAudios\"] = {}; // maps url to audio data\n\n            /** @param {string|number=} what */\n            function abort(what) {\n                if (Module['onAbort']) {\n                    Module['onAbort'](what);\n                }\n\n                what += '';\n                err(what);\n\n                ABORT = true;\n                EXITSTATUS = 1;\n\n                var output = 'abort(' + what + ') at ' + stackTrace();\n                what = output;\n\n                // Use a wasm runtime error, because a JS error might be seen as a foreign\n                // exception, which means we'd run destructors on it. We need the error to\n                // simply make the program stop.\n                var e = new WebAssembly.RuntimeError(what);\n\n                readyPromiseReject(e);\n                // Throw the error whether or not MODULARIZE is set because abort is used\n                // in code paths apart from instantiation where an exception is expected\n                // to be thrown when abort is called.\n                throw e;\n            }\n\n            // {{MEM_INITIALIZER}}\n\n            // include: memoryprofiler.js\n\n\n            // end include: memoryprofiler.js\n            // show errors on likely calls to FS when it was not included\n            var FS = {\n                error: function () {\n                    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n                },\n                init: function () { FS.error() },\n                createDataFile: function () { FS.error() },\n                createPreloadedFile: function () { FS.error() },\n                createLazyFile: function () { FS.error() },\n                open: function () { FS.error() },\n                mkdev: function () { FS.error() },\n                registerDevice: function () { FS.error() },\n                analyzePath: function () { FS.error() },\n                loadFilesFromDB: function () { FS.error() },\n\n                ErrnoError: function ErrnoError() { FS.error() },\n            };\n            Module['FS_createDataFile'] = FS.createDataFile;\n            Module['FS_createPreloadedFile'] = FS.createPreloadedFile;\n\n            // include: URIUtils.js\n\n\n            // Prefix of data URIs emitted by SINGLE_FILE and related options.\n            var dataURIPrefix = 'data:application/octet-stream;base64,';\n\n            // Indicates whether filename is a base64 data URI.\n            function isDataURI(filename) {\n                // Prefix of data URIs emitted by SINGLE_FILE and related options.\n                return filename.startsWith(dataURIPrefix);\n            }\n\n            // Indicates whether filename is delivered via file protocol (as opposed to http/https)\n            function isFileURI(filename) {\n                return filename.startsWith('file://');\n            }\n\n            // end include: URIUtils.js\n            function createExportWrapper(name, fixedasm) {\n                return function () {\n                    var displayName = name;\n                    var asm = fixedasm;\n                    if (!fixedasm) {\n                        asm = Module['asm'];\n                    }\n                    assert(runtimeInitialized, 'native function `' + displayName + '` called before runtime initialization');\n                    assert(!runtimeExited, 'native function `' + displayName + '` called after runtime exit (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n                    if (!asm[name]) {\n                        assert(asm[name], 'exported native function `' + displayName + '` not found');\n                    }\n                    return asm[name].apply(null, arguments);\n                };\n            }\n\n            var wasmBinaryFile;\n            wasmBinaryFile = 'nurbs.wasm';\n            if (!isDataURI(wasmBinaryFile)) {\n                wasmBinaryFile = locateFile(wasmBinaryFile);\n            }\n\n            function getBinary(file) {\n                try {\n                    if (file == wasmBinaryFile && wasmBinary) {\n                        return new Uint8Array(wasmBinary);\n                    }\n                    if (readBinary) {\n                        return readBinary(file);\n                    } else {\n                        throw \"both async and sync fetching of the wasm failed\";\n                    }\n                }\n                catch (err) {\n                    abort(err);\n                }\n            }\n\n            function getBinaryPromise() {\n                // If we don't have the binary yet, try to to load it asynchronously.\n                // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\n                // See https://github.com/github/fetch/pull/92#issuecomment-140665932\n                // Cordova or Electron apps are typically loaded from a file:// url.\n                // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\n                if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n                    if (typeof fetch === 'function'\n                    ) {\n                        return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {\n                            if (!response['ok']) {\n                                throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n                            }\n                            return response['arrayBuffer']();\n                        }).catch(function () {\n                            return getBinary(wasmBinaryFile);\n                        });\n                    }\n                }\n\n                // Otherwise, getBinary should be able to get it synchronously\n                return Promise.resolve().then(function () { return getBinary(wasmBinaryFile); });\n            }\n\n            // Create the wasm instance.\n            // Receives the wasm imports, returns the exports.\n            function createWasm() {\n                // prepare imports\n                var info = {\n                    'env': asmLibraryArg,\n                    'wasi_snapshot_preview1': asmLibraryArg,\n                };\n                // Load the wasm module and create an instance of using native support in the JS engine.\n                // handle a generated wasm instance, receiving its exports and\n                // performing other necessary setup\n                /** @param {WebAssembly.Module=} module*/\n                function receiveInstance(instance, module) {\n                    var exports = instance.exports;\n\n                    Module['asm'] = exports;\n\n                    wasmMemory = Module['asm']['memory'];\n                    assert(wasmMemory, \"memory not found in wasm exports\");\n                    // This assertion doesn't hold when emscripten is run in --post-link\n                    // mode.\n                    // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.\n                    //assert(wasmMemory.buffer.byteLength === 16777216);\n                    updateGlobalBufferAndViews(wasmMemory.buffer);\n\n                    wasmTable = Module['asm']['__indirect_function_table'];\n                    assert(wasmTable, \"table not found in wasm exports\");\n\n                    addOnInit(Module['asm']['__wasm_call_ctors']);\n\n                    removeRunDependency('wasm-instantiate');\n                }\n                // we can't run yet (except in a pthread, where we have a custom sync instantiator)\n                addRunDependency('wasm-instantiate');\n\n                // Prefer streaming instantiation if available.\n                // Async compilation can be confusing when an error on the page overwrites Module\n                // (for example, if the order of elements is wrong, and the one defining Module is\n                // later), so we save Module and check it later.\n                var trueModule = Module;\n                function receiveInstantiationResult(result) {\n                    // 'result' is a ResultObject object which has both the module and instance.\n                    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n                    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n                    trueModule = null;\n                    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n                    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n                    receiveInstance(result['instance']);\n                }\n\n                function instantiateArrayBuffer(receiver) {\n                    return getBinaryPromise().then(function (binary) {\n                        var result = WebAssembly.instantiate(binary, info);\n                        return result;\n                    }).then(receiver, function (reason) {\n                        err('failed to asynchronously prepare wasm: ' + reason);\n\n                        // Warn on some common problems.\n                        if (isFileURI(wasmBinaryFile)) {\n                            err('warning: Loading from a file URI (' + wasmBinaryFile + ') is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing');\n                        }\n                        abort(reason);\n                    });\n                }\n\n                function instantiateAsync() {\n                    if (!wasmBinary &&\n                        typeof WebAssembly.instantiateStreaming === 'function' &&\n                        !isDataURI(wasmBinaryFile) &&\n                        typeof fetch === 'function') {\n                        return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {\n                            var result = WebAssembly.instantiateStreaming(response, info);\n                            return result.then(receiveInstantiationResult, function (reason) {\n                                // We expect the most common failure cause to be a bad MIME type for the binary,\n                                // in which case falling back to ArrayBuffer instantiation should work.\n                                err('wasm streaming compile failed: ' + reason);\n                                err('falling back to ArrayBuffer instantiation');\n                                return instantiateArrayBuffer(receiveInstantiationResult);\n                            });\n                        });\n                    } else {\n                        return instantiateArrayBuffer(receiveInstantiationResult);\n                    }\n                }\n\n                // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n                // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n                // to any other async startup actions they are performing.\n                if (Module['instantiateWasm']) {\n                    try {\n                        var exports = Module['instantiateWasm'](info, receiveInstance);\n                        return exports;\n                    } catch (e) {\n                        err('Module.instantiateWasm callback failed with error: ' + e);\n                        return false;\n                    }\n                }\n\n                // If instantiation fails, reject the module ready promise.\n                instantiateAsync().catch(readyPromiseReject);\n                return {}; // no exports yet; we'll fill them in later\n            }\n\n            // Globals used by JS i64 conversions (see makeSetValue)\n            var tempDouble;\n            var tempI64;\n\n            // === Body ===\n\n            var ASM_CONSTS = {\n\n            };\n\n\n\n\n\n\n            function callRuntimeCallbacks(callbacks) {\n                while (callbacks.length > 0) {\n                    var callback = callbacks.shift();\n                    if (typeof callback == 'function') {\n                        callback(Module); // Pass the module as the first argument.\n                        continue;\n                    }\n                    var func = callback.func;\n                    if (typeof func === 'number') {\n                        if (callback.arg === undefined) {\n                            wasmTable.get(func)();\n                        } else {\n                            wasmTable.get(func)(callback.arg);\n                        }\n                    } else {\n                        func(callback.arg === undefined ? null : callback.arg);\n                    }\n                }\n            }\n\n            function demangle(func) {\n                warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n                return func;\n            }\n\n            function demangleAll(text) {\n                var regex =\n                    /\\b_Z[\\w\\d_]+/g;\n                return text.replace(regex,\n                    function (x) {\n                        var y = demangle(x);\n                        return x === y ? x : (y + ' [' + x + ']');\n                    });\n            }\n\n            function jsStackTrace() {\n                var error = new Error();\n                if (!error.stack) {\n                    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n                    // so try that as a special-case.\n                    try {\n                        throw new Error();\n                    } catch (e) {\n                        error = e;\n                    }\n                    if (!error.stack) {\n                        return '(no stack trace available)';\n                    }\n                }\n                return error.stack.toString();\n            }\n\n            var runtimeKeepaliveCounter = 0;\n            function keepRuntimeAlive() {\n                return noExitRuntime || runtimeKeepaliveCounter > 0;\n            }\n\n            function stackTrace() {\n                var js = jsStackTrace();\n                if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n                return demangleAll(js);\n            }\n\n            function ___assert_fail(condition, filename, line, func) {\n                abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);\n            }\n\n            var ExceptionInfoAttrs = { DESTRUCTOR_OFFSET: 0, REFCOUNT_OFFSET: 4, TYPE_OFFSET: 8, CAUGHT_OFFSET: 12, RETHROWN_OFFSET: 13, SIZE: 16 };\n            function ___cxa_allocate_exception(size) {\n                // Thrown object is prepended by exception metadata block\n                return _malloc(size + ExceptionInfoAttrs.SIZE) + ExceptionInfoAttrs.SIZE;\n            }\n\n            function ExceptionInfo(excPtr) {\n                this.excPtr = excPtr;\n                this.ptr = excPtr - ExceptionInfoAttrs.SIZE;\n\n                this.set_type = function (type) {\n                    HEAP32[(((this.ptr) + (ExceptionInfoAttrs.TYPE_OFFSET)) >> 2)] = type;\n                };\n\n                this.get_type = function () {\n                    return HEAP32[(((this.ptr) + (ExceptionInfoAttrs.TYPE_OFFSET)) >> 2)];\n                };\n\n                this.set_destructor = function (destructor) {\n                    HEAP32[(((this.ptr) + (ExceptionInfoAttrs.DESTRUCTOR_OFFSET)) >> 2)] = destructor;\n                };\n\n                this.get_destructor = function () {\n                    return HEAP32[(((this.ptr) + (ExceptionInfoAttrs.DESTRUCTOR_OFFSET)) >> 2)];\n                };\n\n                this.set_refcount = function (refcount) {\n                    HEAP32[(((this.ptr) + (ExceptionInfoAttrs.REFCOUNT_OFFSET)) >> 2)] = refcount;\n                };\n\n                this.set_caught = function (caught) {\n                    caught = caught ? 1 : 0;\n                    HEAP8[(((this.ptr) + (ExceptionInfoAttrs.CAUGHT_OFFSET)) >> 0)] = caught;\n                };\n\n                this.get_caught = function () {\n                    return HEAP8[(((this.ptr) + (ExceptionInfoAttrs.CAUGHT_OFFSET)) >> 0)] != 0;\n                };\n\n                this.set_rethrown = function (rethrown) {\n                    rethrown = rethrown ? 1 : 0;\n                    HEAP8[(((this.ptr) + (ExceptionInfoAttrs.RETHROWN_OFFSET)) >> 0)] = rethrown;\n                };\n\n                this.get_rethrown = function () {\n                    return HEAP8[(((this.ptr) + (ExceptionInfoAttrs.RETHROWN_OFFSET)) >> 0)] != 0;\n                };\n\n                // Initialize native structure fields. Should be called once after allocated.\n                this.init = function (type, destructor) {\n                    this.set_type(type);\n                    this.set_destructor(destructor);\n                    this.set_refcount(0);\n                    this.set_caught(false);\n                    this.set_rethrown(false);\n                }\n\n                this.add_ref = function () {\n                    var value = HEAP32[(((this.ptr) + (ExceptionInfoAttrs.REFCOUNT_OFFSET)) >> 2)];\n                    HEAP32[(((this.ptr) + (ExceptionInfoAttrs.REFCOUNT_OFFSET)) >> 2)] = value + 1;\n                };\n\n                // Returns true if last reference released.\n                this.release_ref = function () {\n                    var prev = HEAP32[(((this.ptr) + (ExceptionInfoAttrs.REFCOUNT_OFFSET)) >> 2)];\n                    HEAP32[(((this.ptr) + (ExceptionInfoAttrs.REFCOUNT_OFFSET)) >> 2)] = prev - 1;\n                    assert(prev > 0);\n                    return prev === 1;\n                };\n            }\n\n            var exceptionLast = 0;\n\n            var uncaughtExceptionCount = 0;\n            function ___cxa_throw(ptr, type, destructor) {\n                var info = new ExceptionInfo(ptr);\n                // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\n                info.init(type, destructor);\n                exceptionLast = ptr;\n                uncaughtExceptionCount++;\n                throw ptr + \" - Exception catching is disabled, this exception cannot be caught. Compile with -s NO_DISABLE_EXCEPTION_CATCHING or -s EXCEPTION_CATCHING_ALLOWED=[..] to catch.\";\n            }\n\n            function _abort() {\n                abort();\n            }\n\n            function _emscripten_memcpy_big(dest, src, num) {\n                HEAPU8.copyWithin(dest, src, src + num);\n            }\n\n            function abortOnCannotGrowMemory(requestedSize) {\n                abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s INITIAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n            }\n            function _emscripten_resize_heap(requestedSize) {\n                var oldSize = HEAPU8.length;\n                requestedSize = requestedSize >>> 0;\n                abortOnCannotGrowMemory(requestedSize);\n            }\n            var ASSERTIONS = true;\n\n\n\n            /** @type {function(string, boolean=, number=)} */\n            function intArrayFromString(stringy, dontAddNull, length) {\n                var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n                var u8array = new Array(len);\n                var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n                if (dontAddNull) u8array.length = numBytesWritten;\n                return u8array;\n            }\n\n            function intArrayToString(array) {\n                var ret = [];\n                for (var i = 0; i < array.length; i++) {\n                    var chr = array[i];\n                    if (chr > 0xFF) {\n                        if (ASSERTIONS) {\n                            assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n                        }\n                        chr &= 0xFF;\n                    }\n                    ret.push(String.fromCharCode(chr));\n                }\n                return ret.join('');\n            }\n\n\n            var asmLibraryArg = {\n                \"__assert_fail\": ___assert_fail,\n                \"__cxa_allocate_exception\": ___cxa_allocate_exception,\n                \"__cxa_throw\": ___cxa_throw,\n                \"abort\": _abort,\n                \"emscripten_memcpy_big\": _emscripten_memcpy_big,\n                \"emscripten_resize_heap\": _emscripten_resize_heap\n            };\n            var asm = createWasm();\n            /** @type {function(...*):?} */\n            var ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = createExportWrapper(\"__wasm_call_ctors\");\n\n            /** @type {function(...*):?} */\n            var _getNurbsCurve2D = Module[\"_getNurbsCurve2D\"] = createExportWrapper(\"getNurbsCurve2D\");\n\n            /** @type {function(...*):?} */\n            var _getNurbsCurve2DWithWeights = Module[\"_getNurbsCurve2DWithWeights\"] = createExportWrapper(\"getNurbsCurve2DWithWeights\");\n\n            /** @type {function(...*):?} */\n            var _evalNurbsCurve2D = Module[\"_evalNurbsCurve2D\"] = createExportWrapper(\"evalNurbsCurve2D\");\n\n            /** @type {function(...*):?} */\n            var _evalNurbsCurve2DWithWeights = Module[\"_evalNurbsCurve2DWithWeights\"] = createExportWrapper(\"evalNurbsCurve2DWithWeights\");\n\n            /** @type {function(...*):?} */\n            var _projectNurbsCurve2D = Module[\"_projectNurbsCurve2D\"] = createExportWrapper(\"projectNurbsCurve2D\");\n\n            /** @type {function(...*):?} */\n            var _disposeNurbsCurve2D = Module[\"_disposeNurbsCurve2D\"] = createExportWrapper(\"disposeNurbsCurve2D\");\n\n            /** @type {function(...*):?} */\n            var _disposeNurbsCurve2DWithWeights = Module[\"_disposeNurbsCurve2DWithWeights\"] = createExportWrapper(\"disposeNurbsCurve2DWithWeights\");\n\n            /** @type {function(...*):?} */\n            var _getNurbsCurve3D = Module[\"_getNurbsCurve3D\"] = createExportWrapper(\"getNurbsCurve3D\");\n\n            /** @type {function(...*):?} */\n            var _getNurbsCurve3DWithWeights = Module[\"_getNurbsCurve3DWithWeights\"] = createExportWrapper(\"getNurbsCurve3DWithWeights\");\n\n            /** @type {function(...*):?} */\n            var _evalNurbsCurve3D = Module[\"_evalNurbsCurve3D\"] = createExportWrapper(\"evalNurbsCurve3D\");\n\n            /** @type {function(...*):?} */\n            var _invertNurbsCurve3D = Module[\"_invertNurbsCurve3D\"] = createExportWrapper(\"invertNurbsCurve3D\");\n\n            /** @type {function(...*):?} */\n            var _evalNurbsCurve3DWithWeights = Module[\"_evalNurbsCurve3DWithWeights\"] = createExportWrapper(\"evalNurbsCurve3DWithWeights\");\n\n            /** @type {function(...*):?} */\n            var _evalNurbsCurve3dBulk = Module[\"_evalNurbsCurve3dBulk\"] = createExportWrapper(\"evalNurbsCurve3dBulk\");\n\n            /** @type {function(...*):?} */\n            var _disposeNurbsCurve3D = Module[\"_disposeNurbsCurve3D\"] = createExportWrapper(\"disposeNurbsCurve3D\");\n\n            /** @type {function(...*):?} */\n            var _disposeNurbsCurve3DWithWeights = Module[\"_disposeNurbsCurve3DWithWeights\"] = createExportWrapper(\"disposeNurbsCurve3DWithWeights\");\n\n            /** @type {function(...*):?} */\n            var _getNurbsSurface = Module[\"_getNurbsSurface\"] = createExportWrapper(\"getNurbsSurface\");\n\n            /** @type {function(...*):?} */\n            var _getNurbsSurfaceWithWeights = Module[\"_getNurbsSurfaceWithWeights\"] = createExportWrapper(\"getNurbsSurfaceWithWeights\");\n\n            /** @type {function(...*):?} */\n            var _evalNurbsSurface = Module[\"_evalNurbsSurface\"] = createExportWrapper(\"evalNurbsSurface\");\n\n            /** @type {function(...*):?} */\n            var _evalNurbsSurfaceBulk = Module[\"_evalNurbsSurfaceBulk\"] = createExportWrapper(\"evalNurbsSurfaceBulk\");\n\n            /** @type {function(...*):?} */\n            var _invertSurface = Module[\"_invertSurface\"] = createExportWrapper(\"invertSurface\");\n\n            /** @type {function(...*):?} */\n            var __Z19disposeNurbsSurfacePN10novo_nurbs7SurfaceIdEE = Module[\"__Z19disposeNurbsSurfacePN10novo_nurbs7SurfaceIdEE\"] = createExportWrapper(\"_Z19disposeNurbsSurfacePN10novo_nurbs7SurfaceIdEE\");\n\n            /** @type {function(...*):?} */\n            var __Z30disposeNurbsSurfaceWithWeightsPN10novo_nurbs15RationalSurfaceIdEE = Module[\"__Z30disposeNurbsSurfaceWithWeightsPN10novo_nurbs15RationalSurfaceIdEE\"] = createExportWrapper(\"_Z30disposeNurbsSurfaceWithWeightsPN10novo_nurbs15RationalSurfaceIdEE\");\n\n            /** @type {function(...*):?} */\n            var ___errno_location = Module[\"___errno_location\"] = createExportWrapper(\"__errno_location\");\n\n            /** @type {function(...*):?} */\n            var _fflush = Module[\"_fflush\"] = createExportWrapper(\"fflush\");\n\n            /** @type {function(...*):?} */\n            var stackSave = Module[\"stackSave\"] = createExportWrapper(\"stackSave\");\n\n            /** @type {function(...*):?} */\n            var stackRestore = Module[\"stackRestore\"] = createExportWrapper(\"stackRestore\");\n\n            /** @type {function(...*):?} */\n            var stackAlloc = Module[\"stackAlloc\"] = createExportWrapper(\"stackAlloc\");\n\n            /** @type {function(...*):?} */\n            var _emscripten_stack_init = Module[\"_emscripten_stack_init\"] = function () {\n                return (_emscripten_stack_init = Module[\"_emscripten_stack_init\"] = Module[\"asm\"][\"emscripten_stack_init\"]).apply(null, arguments);\n            };\n\n            /** @type {function(...*):?} */\n            var _emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = function () {\n                return (_emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = Module[\"asm\"][\"emscripten_stack_get_free\"]).apply(null, arguments);\n            };\n\n            /** @type {function(...*):?} */\n            var _emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = function () {\n                return (_emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = Module[\"asm\"][\"emscripten_stack_get_end\"]).apply(null, arguments);\n            };\n\n            /** @type {function(...*):?} */\n            var _malloc = Module[\"_malloc\"] = createExportWrapper(\"malloc\");\n\n            /** @type {function(...*):?} */\n            var _free = Module[\"_free\"] = createExportWrapper(\"free\");\n\n\n\n\n\n            // === Auto-generated postamble setup entry stuff ===\n\n            if (!Object.getOwnPropertyDescriptor(Module, \"intArrayFromString\")) Module[\"intArrayFromString\"] = function () { abort(\"'intArrayFromString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"intArrayToString\")) Module[\"intArrayToString\"] = function () { abort(\"'intArrayToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"ccall\")) Module[\"ccall\"] = function () { abort(\"'ccall' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"cwrap\")) Module[\"cwrap\"] = function () { abort(\"'cwrap' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"setValue\")) Module[\"setValue\"] = function () { abort(\"'setValue' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getValue\")) Module[\"getValue\"] = function () { abort(\"'getValue' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"allocate\")) Module[\"allocate\"] = function () { abort(\"'allocate' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"UTF8ArrayToString\")) Module[\"UTF8ArrayToString\"] = function () { abort(\"'UTF8ArrayToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"UTF8ToString\")) Module[\"UTF8ToString\"] = function () { abort(\"'UTF8ToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8Array\")) Module[\"stringToUTF8Array\"] = function () { abort(\"'stringToUTF8Array' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8\")) Module[\"stringToUTF8\"] = function () { abort(\"'stringToUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF8\")) Module[\"lengthBytesUTF8\"] = function () { abort(\"'lengthBytesUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function () { abort(\"'stackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"addOnPreRun\")) Module[\"addOnPreRun\"] = function () { abort(\"'addOnPreRun' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"addOnInit\")) Module[\"addOnInit\"] = function () { abort(\"'addOnInit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"addOnPreMain\")) Module[\"addOnPreMain\"] = function () { abort(\"'addOnPreMain' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"addOnExit\")) Module[\"addOnExit\"] = function () { abort(\"'addOnExit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"addOnPostRun\")) Module[\"addOnPostRun\"] = function () { abort(\"'addOnPostRun' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"writeStringToMemory\")) Module[\"writeStringToMemory\"] = function () { abort(\"'writeStringToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"writeArrayToMemory\")) Module[\"writeArrayToMemory\"] = function () { abort(\"'writeArrayToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"writeAsciiToMemory\")) Module[\"writeAsciiToMemory\"] = function () { abort(\"'writeAsciiToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"addRunDependency\")) Module[\"addRunDependency\"] = function () { abort(\"'addRunDependency' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"removeRunDependency\")) Module[\"removeRunDependency\"] = function () { abort(\"'removeRunDependency' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"FS_createFolder\")) Module[\"FS_createFolder\"] = function () { abort(\"'FS_createFolder' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"FS_createPath\")) Module[\"FS_createPath\"] = function () { abort(\"'FS_createPath' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"FS_createDataFile\")) Module[\"FS_createDataFile\"] = function () { abort(\"'FS_createDataFile' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"FS_createPreloadedFile\")) Module[\"FS_createPreloadedFile\"] = function () { abort(\"'FS_createPreloadedFile' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"FS_createLazyFile\")) Module[\"FS_createLazyFile\"] = function () { abort(\"'FS_createLazyFile' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"FS_createLink\")) Module[\"FS_createLink\"] = function () { abort(\"'FS_createLink' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"FS_createDevice\")) Module[\"FS_createDevice\"] = function () { abort(\"'FS_createDevice' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"FS_unlink\")) Module[\"FS_unlink\"] = function () { abort(\"'FS_unlink' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getLEB\")) Module[\"getLEB\"] = function () { abort(\"'getLEB' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getFunctionTables\")) Module[\"getFunctionTables\"] = function () { abort(\"'getFunctionTables' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"alignFunctionTables\")) Module[\"alignFunctionTables\"] = function () { abort(\"'alignFunctionTables' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerFunctions\")) Module[\"registerFunctions\"] = function () { abort(\"'registerFunctions' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"addFunction\")) Module[\"addFunction\"] = function () { abort(\"'addFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"removeFunction\")) Module[\"removeFunction\"] = function () { abort(\"'removeFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = function () { abort(\"'getFuncWrapper' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"prettyPrint\")) Module[\"prettyPrint\"] = function () { abort(\"'prettyPrint' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = function () { abort(\"'dynCall' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getCompilerSetting\")) Module[\"getCompilerSetting\"] = function () { abort(\"'getCompilerSetting' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"print\")) Module[\"print\"] = function () { abort(\"'print' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"printErr\")) Module[\"printErr\"] = function () { abort(\"'printErr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getTempRet0\")) Module[\"getTempRet0\"] = function () { abort(\"'getTempRet0' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"setTempRet0\")) Module[\"setTempRet0\"] = function () { abort(\"'setTempRet0' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"callMain\")) Module[\"callMain\"] = function () { abort(\"'callMain' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"abort\")) Module[\"abort\"] = function () { abort(\"'abort' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"stringToNewUTF8\")) Module[\"stringToNewUTF8\"] = function () { abort(\"'stringToNewUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"setFileTime\")) Module[\"setFileTime\"] = function () { abort(\"'setFileTime' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"abortOnCannotGrowMemory\")) Module[\"abortOnCannotGrowMemory\"] = function () { abort(\"'abortOnCannotGrowMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"emscripten_realloc_buffer\")) Module[\"emscripten_realloc_buffer\"] = function () { abort(\"'emscripten_realloc_buffer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"ENV\")) Module[\"ENV\"] = function () { abort(\"'ENV' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_CODES\")) Module[\"ERRNO_CODES\"] = function () { abort(\"'ERRNO_CODES' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_MESSAGES\")) Module[\"ERRNO_MESSAGES\"] = function () { abort(\"'ERRNO_MESSAGES' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"setErrNo\")) Module[\"setErrNo\"] = function () { abort(\"'setErrNo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"inetPton4\")) Module[\"inetPton4\"] = function () { abort(\"'inetPton4' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"inetNtop4\")) Module[\"inetNtop4\"] = function () { abort(\"'inetNtop4' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"inetPton6\")) Module[\"inetPton6\"] = function () { abort(\"'inetPton6' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"inetNtop6\")) Module[\"inetNtop6\"] = function () { abort(\"'inetNtop6' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"readSockaddr\")) Module[\"readSockaddr\"] = function () { abort(\"'readSockaddr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"writeSockaddr\")) Module[\"writeSockaddr\"] = function () { abort(\"'writeSockaddr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"DNS\")) Module[\"DNS\"] = function () { abort(\"'DNS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getHostByName\")) Module[\"getHostByName\"] = function () { abort(\"'getHostByName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"GAI_ERRNO_MESSAGES\")) Module[\"GAI_ERRNO_MESSAGES\"] = function () { abort(\"'GAI_ERRNO_MESSAGES' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"Protocols\")) Module[\"Protocols\"] = function () { abort(\"'Protocols' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"Sockets\")) Module[\"Sockets\"] = function () { abort(\"'Sockets' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getRandomDevice\")) Module[\"getRandomDevice\"] = function () { abort(\"'getRandomDevice' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"traverseStack\")) Module[\"traverseStack\"] = function () { abort(\"'traverseStack' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"UNWIND_CACHE\")) Module[\"UNWIND_CACHE\"] = function () { abort(\"'UNWIND_CACHE' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"withBuiltinMalloc\")) Module[\"withBuiltinMalloc\"] = function () { abort(\"'withBuiltinMalloc' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"readAsmConstArgsArray\")) Module[\"readAsmConstArgsArray\"] = function () { abort(\"'readAsmConstArgsArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"readAsmConstArgs\")) Module[\"readAsmConstArgs\"] = function () { abort(\"'readAsmConstArgs' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"mainThreadEM_ASM\")) Module[\"mainThreadEM_ASM\"] = function () { abort(\"'mainThreadEM_ASM' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"jstoi_q\")) Module[\"jstoi_q\"] = function () { abort(\"'jstoi_q' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"jstoi_s\")) Module[\"jstoi_s\"] = function () { abort(\"'jstoi_s' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getExecutableName\")) Module[\"getExecutableName\"] = function () { abort(\"'getExecutableName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"listenOnce\")) Module[\"listenOnce\"] = function () { abort(\"'listenOnce' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"autoResumeAudioContext\")) Module[\"autoResumeAudioContext\"] = function () { abort(\"'autoResumeAudioContext' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"dynCallLegacy\")) Module[\"dynCallLegacy\"] = function () { abort(\"'dynCallLegacy' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getDynCaller\")) Module[\"getDynCaller\"] = function () { abort(\"'getDynCaller' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = function () { abort(\"'dynCall' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"callRuntimeCallbacks\")) Module[\"callRuntimeCallbacks\"] = function () { abort(\"'callRuntimeCallbacks' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"runtimeKeepaliveCounter\")) Module[\"runtimeKeepaliveCounter\"] = function () { abort(\"'runtimeKeepaliveCounter' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"keepRuntimeAlive\")) Module[\"keepRuntimeAlive\"] = function () { abort(\"'keepRuntimeAlive' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"runtimeKeepalivePush\")) Module[\"runtimeKeepalivePush\"] = function () { abort(\"'runtimeKeepalivePush' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"runtimeKeepalivePop\")) Module[\"runtimeKeepalivePop\"] = function () { abort(\"'runtimeKeepalivePop' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"callUserCallback\")) Module[\"callUserCallback\"] = function () { abort(\"'callUserCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"maybeExit\")) Module[\"maybeExit\"] = function () { abort(\"'maybeExit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"asmjsMangle\")) Module[\"asmjsMangle\"] = function () { abort(\"'asmjsMangle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"reallyNegative\")) Module[\"reallyNegative\"] = function () { abort(\"'reallyNegative' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"unSign\")) Module[\"unSign\"] = function () { abort(\"'unSign' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"reSign\")) Module[\"reSign\"] = function () { abort(\"'reSign' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"formatString\")) Module[\"formatString\"] = function () { abort(\"'formatString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"PATH\")) Module[\"PATH\"] = function () { abort(\"'PATH' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"PATH_FS\")) Module[\"PATH_FS\"] = function () { abort(\"'PATH_FS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"SYSCALLS\")) Module[\"SYSCALLS\"] = function () { abort(\"'SYSCALLS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"syscallMmap2\")) Module[\"syscallMmap2\"] = function () { abort(\"'syscallMmap2' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"syscallMunmap\")) Module[\"syscallMunmap\"] = function () { abort(\"'syscallMunmap' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getSocketFromFD\")) Module[\"getSocketFromFD\"] = function () { abort(\"'getSocketFromFD' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getSocketAddress\")) Module[\"getSocketAddress\"] = function () { abort(\"'getSocketAddress' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"JSEvents\")) Module[\"JSEvents\"] = function () { abort(\"'JSEvents' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerKeyEventCallback\")) Module[\"registerKeyEventCallback\"] = function () { abort(\"'registerKeyEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"specialHTMLTargets\")) Module[\"specialHTMLTargets\"] = function () { abort(\"'specialHTMLTargets' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"maybeCStringToJsString\")) Module[\"maybeCStringToJsString\"] = function () { abort(\"'maybeCStringToJsString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"findEventTarget\")) Module[\"findEventTarget\"] = function () { abort(\"'findEventTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"findCanvasEventTarget\")) Module[\"findCanvasEventTarget\"] = function () { abort(\"'findCanvasEventTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getBoundingClientRect\")) Module[\"getBoundingClientRect\"] = function () { abort(\"'getBoundingClientRect' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"fillMouseEventData\")) Module[\"fillMouseEventData\"] = function () { abort(\"'fillMouseEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerMouseEventCallback\")) Module[\"registerMouseEventCallback\"] = function () { abort(\"'registerMouseEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerWheelEventCallback\")) Module[\"registerWheelEventCallback\"] = function () { abort(\"'registerWheelEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerUiEventCallback\")) Module[\"registerUiEventCallback\"] = function () { abort(\"'registerUiEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerFocusEventCallback\")) Module[\"registerFocusEventCallback\"] = function () { abort(\"'registerFocusEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"fillDeviceOrientationEventData\")) Module[\"fillDeviceOrientationEventData\"] = function () { abort(\"'fillDeviceOrientationEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerDeviceOrientationEventCallback\")) Module[\"registerDeviceOrientationEventCallback\"] = function () { abort(\"'registerDeviceOrientationEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"fillDeviceMotionEventData\")) Module[\"fillDeviceMotionEventData\"] = function () { abort(\"'fillDeviceMotionEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerDeviceMotionEventCallback\")) Module[\"registerDeviceMotionEventCallback\"] = function () { abort(\"'registerDeviceMotionEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"screenOrientation\")) Module[\"screenOrientation\"] = function () { abort(\"'screenOrientation' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"fillOrientationChangeEventData\")) Module[\"fillOrientationChangeEventData\"] = function () { abort(\"'fillOrientationChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerOrientationChangeEventCallback\")) Module[\"registerOrientationChangeEventCallback\"] = function () { abort(\"'registerOrientationChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"fillFullscreenChangeEventData\")) Module[\"fillFullscreenChangeEventData\"] = function () { abort(\"'fillFullscreenChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerFullscreenChangeEventCallback\")) Module[\"registerFullscreenChangeEventCallback\"] = function () { abort(\"'registerFullscreenChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerRestoreOldStyle\")) Module[\"registerRestoreOldStyle\"] = function () { abort(\"'registerRestoreOldStyle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"hideEverythingExceptGivenElement\")) Module[\"hideEverythingExceptGivenElement\"] = function () { abort(\"'hideEverythingExceptGivenElement' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"restoreHiddenElements\")) Module[\"restoreHiddenElements\"] = function () { abort(\"'restoreHiddenElements' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"setLetterbox\")) Module[\"setLetterbox\"] = function () { abort(\"'setLetterbox' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"currentFullscreenStrategy\")) Module[\"currentFullscreenStrategy\"] = function () { abort(\"'currentFullscreenStrategy' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"restoreOldWindowedStyle\")) Module[\"restoreOldWindowedStyle\"] = function () { abort(\"'restoreOldWindowedStyle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"softFullscreenResizeWebGLRenderTarget\")) Module[\"softFullscreenResizeWebGLRenderTarget\"] = function () { abort(\"'softFullscreenResizeWebGLRenderTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"doRequestFullscreen\")) Module[\"doRequestFullscreen\"] = function () { abort(\"'doRequestFullscreen' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"fillPointerlockChangeEventData\")) Module[\"fillPointerlockChangeEventData\"] = function () { abort(\"'fillPointerlockChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerPointerlockChangeEventCallback\")) Module[\"registerPointerlockChangeEventCallback\"] = function () { abort(\"'registerPointerlockChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerPointerlockErrorEventCallback\")) Module[\"registerPointerlockErrorEventCallback\"] = function () { abort(\"'registerPointerlockErrorEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"requestPointerLock\")) Module[\"requestPointerLock\"] = function () { abort(\"'requestPointerLock' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"fillVisibilityChangeEventData\")) Module[\"fillVisibilityChangeEventData\"] = function () { abort(\"'fillVisibilityChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerVisibilityChangeEventCallback\")) Module[\"registerVisibilityChangeEventCallback\"] = function () { abort(\"'registerVisibilityChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerTouchEventCallback\")) Module[\"registerTouchEventCallback\"] = function () { abort(\"'registerTouchEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"fillGamepadEventData\")) Module[\"fillGamepadEventData\"] = function () { abort(\"'fillGamepadEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerGamepadEventCallback\")) Module[\"registerGamepadEventCallback\"] = function () { abort(\"'registerGamepadEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerBeforeUnloadEventCallback\")) Module[\"registerBeforeUnloadEventCallback\"] = function () { abort(\"'registerBeforeUnloadEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"fillBatteryEventData\")) Module[\"fillBatteryEventData\"] = function () { abort(\"'fillBatteryEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"battery\")) Module[\"battery\"] = function () { abort(\"'battery' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"registerBatteryEventCallback\")) Module[\"registerBatteryEventCallback\"] = function () { abort(\"'registerBatteryEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"setCanvasElementSize\")) Module[\"setCanvasElementSize\"] = function () { abort(\"'setCanvasElementSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getCanvasElementSize\")) Module[\"getCanvasElementSize\"] = function () { abort(\"'getCanvasElementSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"polyfillSetImmediate\")) Module[\"polyfillSetImmediate\"] = function () { abort(\"'polyfillSetImmediate' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"demangle\")) Module[\"demangle\"] = function () { abort(\"'demangle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"demangleAll\")) Module[\"demangleAll\"] = function () { abort(\"'demangleAll' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"jsStackTrace\")) Module[\"jsStackTrace\"] = function () { abort(\"'jsStackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function () { abort(\"'stackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getEnvStrings\")) Module[\"getEnvStrings\"] = function () { abort(\"'getEnvStrings' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"checkWasiClock\")) Module[\"checkWasiClock\"] = function () { abort(\"'checkWasiClock' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"flush_NO_FILESYSTEM\")) Module[\"flush_NO_FILESYSTEM\"] = function () { abort(\"'flush_NO_FILESYSTEM' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64\")) Module[\"writeI53ToI64\"] = function () { abort(\"'writeI53ToI64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Clamped\")) Module[\"writeI53ToI64Clamped\"] = function () { abort(\"'writeI53ToI64Clamped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Signaling\")) Module[\"writeI53ToI64Signaling\"] = function () { abort(\"'writeI53ToI64Signaling' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Clamped\")) Module[\"writeI53ToU64Clamped\"] = function () { abort(\"'writeI53ToU64Clamped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Signaling\")) Module[\"writeI53ToU64Signaling\"] = function () { abort(\"'writeI53ToU64Signaling' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"readI53FromI64\")) Module[\"readI53FromI64\"] = function () { abort(\"'readI53FromI64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"readI53FromU64\")) Module[\"readI53FromU64\"] = function () { abort(\"'readI53FromU64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"convertI32PairToI53\")) Module[\"convertI32PairToI53\"] = function () { abort(\"'convertI32PairToI53' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"convertU32PairToI53\")) Module[\"convertU32PairToI53\"] = function () { abort(\"'convertU32PairToI53' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"uncaughtExceptionCount\")) Module[\"uncaughtExceptionCount\"] = function () { abort(\"'uncaughtExceptionCount' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"exceptionLast\")) Module[\"exceptionLast\"] = function () { abort(\"'exceptionLast' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"exceptionCaught\")) Module[\"exceptionCaught\"] = function () { abort(\"'exceptionCaught' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"ExceptionInfoAttrs\")) Module[\"ExceptionInfoAttrs\"] = function () { abort(\"'ExceptionInfoAttrs' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"ExceptionInfo\")) Module[\"ExceptionInfo\"] = function () { abort(\"'ExceptionInfo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"CatchInfo\")) Module[\"CatchInfo\"] = function () { abort(\"'CatchInfo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"exception_addRef\")) Module[\"exception_addRef\"] = function () { abort(\"'exception_addRef' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"exception_decRef\")) Module[\"exception_decRef\"] = function () { abort(\"'exception_decRef' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"Browser\")) Module[\"Browser\"] = function () { abort(\"'Browser' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"funcWrappers\")) Module[\"funcWrappers\"] = function () { abort(\"'funcWrappers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = function () { abort(\"'getFuncWrapper' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"setMainLoop\")) Module[\"setMainLoop\"] = function () { abort(\"'setMainLoop' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"FS\")) Module[\"FS\"] = function () { abort(\"'FS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"mmapAlloc\")) Module[\"mmapAlloc\"] = function () { abort(\"'mmapAlloc' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"MEMFS\")) Module[\"MEMFS\"] = function () { abort(\"'MEMFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"TTY\")) Module[\"TTY\"] = function () { abort(\"'TTY' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"PIPEFS\")) Module[\"PIPEFS\"] = function () { abort(\"'PIPEFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"SOCKFS\")) Module[\"SOCKFS\"] = function () { abort(\"'SOCKFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"_setNetworkCallback\")) Module[\"_setNetworkCallback\"] = function () { abort(\"'_setNetworkCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"tempFixedLengthArray\")) Module[\"tempFixedLengthArray\"] = function () { abort(\"'tempFixedLengthArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"miniTempWebGLFloatBuffers\")) Module[\"miniTempWebGLFloatBuffers\"] = function () { abort(\"'miniTempWebGLFloatBuffers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"heapObjectForWebGLType\")) Module[\"heapObjectForWebGLType\"] = function () { abort(\"'heapObjectForWebGLType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"heapAccessShiftForWebGLHeap\")) Module[\"heapAccessShiftForWebGLHeap\"] = function () { abort(\"'heapAccessShiftForWebGLHeap' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"GL\")) Module[\"GL\"] = function () { abort(\"'GL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet\")) Module[\"emscriptenWebGLGet\"] = function () { abort(\"'emscriptenWebGLGet' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"computeUnpackAlignedImageSize\")) Module[\"computeUnpackAlignedImageSize\"] = function () { abort(\"'computeUnpackAlignedImageSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData\")) Module[\"emscriptenWebGLGetTexPixelData\"] = function () { abort(\"'emscriptenWebGLGetTexPixelData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform\")) Module[\"emscriptenWebGLGetUniform\"] = function () { abort(\"'emscriptenWebGLGetUniform' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"webglGetUniformLocation\")) Module[\"webglGetUniformLocation\"] = function () { abort(\"'webglGetUniformLocation' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"webglPrepareUniformLocationsBeforeFirstUse\")) Module[\"webglPrepareUniformLocationsBeforeFirstUse\"] = function () { abort(\"'webglPrepareUniformLocationsBeforeFirstUse' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"webglGetLeftBracePos\")) Module[\"webglGetLeftBracePos\"] = function () { abort(\"'webglGetLeftBracePos' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib\")) Module[\"emscriptenWebGLGetVertexAttrib\"] = function () { abort(\"'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"writeGLArray\")) Module[\"writeGLArray\"] = function () { abort(\"'writeGLArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"AL\")) Module[\"AL\"] = function () { abort(\"'AL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"SDL_unicode\")) Module[\"SDL_unicode\"] = function () { abort(\"'SDL_unicode' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"SDL_ttfContext\")) Module[\"SDL_ttfContext\"] = function () { abort(\"'SDL_ttfContext' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"SDL_audio\")) Module[\"SDL_audio\"] = function () { abort(\"'SDL_audio' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"SDL\")) Module[\"SDL\"] = function () { abort(\"'SDL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"SDL_gfx\")) Module[\"SDL_gfx\"] = function () { abort(\"'SDL_gfx' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"GLUT\")) Module[\"GLUT\"] = function () { abort(\"'GLUT' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"EGL\")) Module[\"EGL\"] = function () { abort(\"'EGL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"GLFW_Window\")) Module[\"GLFW_Window\"] = function () { abort(\"'GLFW_Window' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"GLFW\")) Module[\"GLFW\"] = function () { abort(\"'GLFW' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"GLEW\")) Module[\"GLEW\"] = function () { abort(\"'GLEW' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"IDBStore\")) Module[\"IDBStore\"] = function () { abort(\"'IDBStore' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"runAndAbortIfError\")) Module[\"runAndAbortIfError\"] = function () { abort(\"'runAndAbortIfError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"warnOnce\")) Module[\"warnOnce\"] = function () { abort(\"'warnOnce' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"stackSave\")) Module[\"stackSave\"] = function () { abort(\"'stackSave' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"stackRestore\")) Module[\"stackRestore\"] = function () { abort(\"'stackRestore' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"stackAlloc\")) Module[\"stackAlloc\"] = function () { abort(\"'stackAlloc' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"AsciiToString\")) Module[\"AsciiToString\"] = function () { abort(\"'AsciiToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"stringToAscii\")) Module[\"stringToAscii\"] = function () { abort(\"'stringToAscii' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"UTF16ToString\")) Module[\"UTF16ToString\"] = function () { abort(\"'UTF16ToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF16\")) Module[\"stringToUTF16\"] = function () { abort(\"'stringToUTF16' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF16\")) Module[\"lengthBytesUTF16\"] = function () { abort(\"'lengthBytesUTF16' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"UTF32ToString\")) Module[\"UTF32ToString\"] = function () { abort(\"'UTF32ToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF32\")) Module[\"stringToUTF32\"] = function () { abort(\"'stringToUTF32' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF32\")) Module[\"lengthBytesUTF32\"] = function () { abort(\"'lengthBytesUTF32' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8\")) Module[\"allocateUTF8\"] = function () { abort(\"'allocateUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            if (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8OnStack\")) Module[\"allocateUTF8OnStack\"] = function () { abort(\"'allocateUTF8OnStack' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\n            Module[\"writeStackCookie\"] = writeStackCookie;\n            Module[\"checkStackCookie\"] = checkStackCookie;\n            if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NORMAL\")) Object.defineProperty(Module, \"ALLOC_NORMAL\", { configurable: true, get: function () { abort(\"'ALLOC_NORMAL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\n            if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_STACK\")) Object.defineProperty(Module, \"ALLOC_STACK\", { configurable: true, get: function () { abort(\"'ALLOC_STACK' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\n\n            var calledRun;\n\n            /**\n             * @constructor\n             * @this {ExitStatus}\n             */\n            function ExitStatus(status) {\n                this.name = \"ExitStatus\";\n                this.message = \"Program terminated with exit(\" + status + \")\";\n                this.status = status;\n            }\n\n            var calledMain = false;\n\n            dependenciesFulfilled = function runCaller() {\n                // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n                if (!calledRun) run();\n                if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n            };\n\n            function stackCheckInit() {\n                // This is normally called automatically during __wasm_call_ctors but need to\n                // get these values before even running any of the ctors so we call it redundantly\n                // here.\n                // TODO(sbc): Move writeStackCookie to native to to avoid this.\n                _emscripten_stack_init();\n                writeStackCookie();\n            }\n\n            /** @type {function(Array=)} */\n            function run(args) {\n                args = args || arguments_;\n\n                if (runDependencies > 0) {\n                    return;\n                }\n\n                stackCheckInit();\n\n                preRun();\n\n                // a preRun added a dependency, run will be called later\n                if (runDependencies > 0) {\n                    return;\n                }\n\n                function doRun() {\n                    // run may have just been called through dependencies being fulfilled just in this very frame,\n                    // or while the async setStatus time below was happening\n                    if (calledRun) return;\n                    calledRun = true;\n                    Module['calledRun'] = true;\n\n                    if (ABORT) return;\n\n                    initRuntime();\n\n                    readyPromiseResolve(Module);\n                    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n                    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n\n                    postRun();\n                }\n\n                if (Module['setStatus']) {\n                    Module['setStatus']('Running...');\n                    setTimeout(function () {\n                        setTimeout(function () {\n                            Module['setStatus']('');\n                        }, 1);\n                        doRun();\n                    }, 1);\n                } else {\n                    doRun();\n                }\n                checkStackCookie();\n            }\n            Module['run'] = run;\n\n            function checkUnflushedContent() {\n                // Compiler settings do not allow exiting the runtime, so flushing\n                // the streams is not possible. but in ASSERTIONS mode we check\n                // if there was something to flush, and if so tell the user they\n                // should request that the runtime be exitable.\n                // Normally we would not even include flush() at all, but in ASSERTIONS\n                // builds we do so just for this check, and here we see if there is any\n                // content to flush, that is, we check if there would have been\n                // something a non-ASSERTIONS build would have not seen.\n                // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n                // mode (which has its own special function for this; otherwise, all\n                // the code is inside libc)\n                var oldOut = out;\n                var oldErr = err;\n                var has = false;\n                out = err = function (x) {\n                    has = true;\n                }\n                try { // it doesn't matter if it fails\n                    var flush = null;\n                    if (flush) flush();\n                } catch (e) { }\n                out = oldOut;\n                err = oldErr;\n                if (has) {\n                    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\n                    warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');\n                }\n            }\n\n            /** @param {boolean|number=} implicit */\n            function exit(status, implicit) {\n                EXITSTATUS = status;\n\n                checkUnflushedContent();\n\n                // if this is just main exit-ing implicitly, and the status is 0, then we\n                // don't need to do anything here and can just leave. if the status is\n                // non-zero, though, then we need to report it.\n                // (we may have warned about this earlier, if a situation justifies doing so)\n                if (implicit && keepRuntimeAlive() && status === 0) {\n                    return;\n                }\n\n                if (keepRuntimeAlive()) {\n                    // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n                    if (!implicit) {\n                        var msg = 'program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)';\n                        readyPromiseReject(msg);\n                        err(msg);\n                    }\n                } else {\n\n                    exitRuntime();\n\n                    if (Module['onExit']) Module['onExit'](status);\n\n                    ABORT = true;\n                }\n\n                quit_(status, new ExitStatus(status));\n            }\n\n            if (Module['preInit']) {\n                if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n                while (Module['preInit'].length > 0) {\n                    Module['preInit'].pop()();\n                }\n            }\n\n            run();\n\n\n\n\n\n\n\n            return Module.ready\n        }\n    );\n})();\n\nexport default Module;", "import type { ReadonlyVec2, ReadonlyVec3 } from \"gl-matrix\";\nimport factory from \"../wasm/nurbs_wrapper.js\";\nimport wasmUrl from \"../wasm/nurbs.wasm\";\n\n/*\nnurbs_wrapper.js\nTo work with ESbuild replace :\n\nif (typeof exports === 'object' && typeof module === 'object')\n    module.exports = Module;\nelse if (typeof define === 'function' && define['amd'])\n    define([], function () { return Module; });\nelse if (typeof exports === 'object')\n    exports[\"Module\"] = Module;\n\nwith:\nexport default Module;\n*/\n\n// https://kripken.github.io/emscripten-site/docs/api_reference/module.html\nexport async function createWasmInstance() {\n    return await factory({ locateFile: (path: string) => wasmUrl });\n}\n\nexport function makeNurbsCurve3D(instance: any, knots: number[], controlPoints: ReadonlyVec3[], weights: number[] | undefined, order: number) {\n    const degree = order - 1;\n    var knotsPtr = instance._malloc(8 * knots.length);\n    var knotsHeap = new Float64Array(instance.HEAPF64.buffer, knotsPtr, knots.length);\n    knotsHeap.set(knots);\n\n    var controlPointsPtr = instance._malloc(controlPoints.length * 24);\n    var controlPointsHeap = new Float64Array(instance.HEAPF64.buffer, controlPointsPtr, controlPoints.length * 3);\n    var ctrlPoints = new Float64Array(controlPoints.length * 3);\n    controlPoints.forEach((point, index) => {\n        ctrlPoints[index * 3] = point[0];\n        ctrlPoints[(index * 3) + 1] = point[1];\n        ctrlPoints[(index * 3) + 2] = point[2];\n    });\n    controlPointsHeap.set(ctrlPoints);\n\n    var nurbs = undefined;\n    if (weights != undefined && weights.length > 0) {\n        var weightsPtr = instance._malloc(8 * weights.length);\n        var weightsHeap = new Float64Array(instance.HEAPF64.buffer, weightsPtr, weights.length);\n        weightsHeap.set(weights);\n        nurbs = instance._getNurbsCurve3DWithWeights(degree, controlPoints.length, knotsHeap.byteOffset,\n            controlPointsHeap.byteOffset, weightsHeap.byteOffset);\n        instance._free(weightsHeap.byteOffset);\n    }\n    else {\n        nurbs = instance._getNurbsCurve3D(degree, controlPoints.length, knotsHeap.byteOffset,\n            controlPointsHeap.byteOffset, 0);\n    }\n    instance._free(knotsHeap.byteOffset);\n    instance._free(controlPointsHeap.byteOffset);\n    return nurbs;\n}\n\nexport function makeNurbsCurve2D(instance: any, knots: number[], controlPoints: ReadonlyVec2[], weights: number[] | undefined, order: number) {\n    const degree = order - 1;\n    var knotsPtr = instance._malloc(8 * knots.length);\n    var knotsHeap = new Float64Array(instance.HEAPF64.buffer, knotsPtr, knots.length);\n    knotsHeap.set(knots);\n\n    var controlPointsPtr = instance._malloc(controlPoints.length * 16);\n    var controlPointsHeap = new Float64Array(instance.HEAPF64.buffer, controlPointsPtr, controlPoints.length * 2);\n    var ctrlPoints = new Float64Array(controlPoints.length * 2);\n    controlPoints.forEach((point, index) => {\n        ctrlPoints[index * 2] = point[0];\n        ctrlPoints[(index * 2) + 1] = point[1];\n    });\n    controlPointsHeap.set(ctrlPoints);\n\n    var nurbs = undefined;\n    if (weights != undefined && weights.length > 0) {\n        var weightsPtr = instance._malloc(8 * weights.length);\n        var weightsHeap = new Float64Array(instance.HEAPF64.buffer, weightsPtr, weights.length);\n        weightsHeap.set(weights);\n        nurbs = instance._getNurbsCurve2DWithWeights(degree, controlPoints.length, knotsHeap.byteOffset,\n            controlPointsHeap.byteOffset, weightsHeap.byteOffset);\n        instance._free(weightsHeap.byteOffset);\n    }\n    else {\n        nurbs = instance._getNurbsCurve2D(degree, controlPoints.length, knotsHeap.byteOffset,\n            controlPointsHeap.byteOffset, 0);\n    }\n    instance._free(knotsHeap.byteOffset);\n    instance._free(controlPointsHeap.byteOffset);\n    return nurbs;\n}\n\n\n\nexport function makeNurbsSurface(instance: any, knots: number[], dimU: number, dimV: number, controlPoints: ReadonlyVec3[], weights: number[] | undefined, orderU: number, orderV: number) {\n    const degreeU = orderU - 1;\n    const degreeV = orderV - 1;\n    var knotsPtr = instance._malloc(8 * knots.length);\n    var knotsHeap = new Float64Array(instance.HEAPF64.buffer, knotsPtr, knots.length);\n    knotsHeap.set(knots);\n\n    var controlPointsPtr = instance._malloc(controlPoints.length * 24);\n    var controlPointsHeap = new Float64Array(instance.HEAPF64.buffer, controlPointsPtr, controlPoints.length * 3);\n    var ctrlPoints = new Float64Array(controlPoints.length * 3);\n    controlPoints.forEach((point, index) => {\n        ctrlPoints[index * 3] = point[0];\n        ctrlPoints[(index * 3) + 1] = point[1];\n        ctrlPoints[(index * 3) + 2] = point[2];\n    });\n    controlPointsHeap.set(ctrlPoints);\n\n    var nurbs = undefined;\n\n    if (weights != undefined && weights.length > 0) {\n        var weightsPtr = instance._malloc(8 * weights.length);\n        var weightsHeap = new Float64Array(instance.HEAPF64.buffer, weightsPtr, weights.length);\n        weightsHeap.set(weights);\n        nurbs = instance._getNurbsSurfaceWithWeights(degreeU, degreeV, dimU, dimV, knotsHeap.byteOffset,\n            controlPointsHeap.byteOffset, weightsHeap.byteOffset);\n        instance._free(weightsHeap.byteOffset);\n    }\n    else {\n        nurbs = instance._getNurbsSurface(degreeU, degreeV, dimU, dimV, knotsHeap.byteOffset,\n            controlPointsHeap.byteOffset, 0);\n    }\n    instance._free(knotsHeap.byteOffset);\n    instance._free(controlPointsHeap.byteOffset);\n    return nurbs;\n}", "import { ReadonlyMat4, ReadonlyVec2, vec2, glMatrix } from \"gl-matrix\";\nimport type { Curve2D } from \"./curves\";\nimport type { IndexPair, Triangulation } from \"./brep\";\nimport type { Ray } from \"./ray\";\nimport type { Surface } from \"./surfaces\";\n\nglMatrix.setMatrixArrayType(Array);\n\nconst projectedPoint = vec2.create();\nconst projectedTangent = vec2.create();\nconst beginUV = vec2.create();\nconst endUV = vec2.create();\n\nexport interface Seam {\n    vertexIndexPairs: IndexPair[]; // pairs of face vertex indices that form part of a seam, i.e. they are different in UV space, but not in 3D.\n}\n\nexport class Face {\n    constructor(readonly surface: Surface, readonly sense: 1 | -1, readonly loops: readonly (readonly Curve2D[])[], readonly triangulation: Triangulation, readonly seams: Seam[], readonly instanceIndex: number, readonly geometryTransformation?: ReadonlyMat4) {\n        // TODO: Check cone ray intersection. Seems to be an issue with sense (works if surface gets negative sense, but face doesnt).\n        // const uv = vec2.fromValues(3.14, -35);\n        // const pos = vec3.create();\n        // surface.evalPosition(pos, uv);\n        // const invUV = vec2.create();\n        // surface.invert(invUV, pos);\n        // for (const curves of loops) {\n        //     if (curves.length > 1) {\n        //         for (let i0 = 0; i0 < curves.length; i0++) {\n        //             let i1 = (i0 + 1) % curves.length;\n        //             const c0 = curves[i0];\n        //             const c1 = curves[i1];\n        //             c0.eval(c0.endParam, endUV, undefined);\n        //             c1.eval(c1.beginParam, beginUV, undefined);\n        //             const distUV = vec2.distance(beginUV, endUV);\n        //             console.assert(distUV < 1e-5);\n        //             const t = c1.project(beginUV);\n        //             const distT = Math.abs(t - c1.beginParam);\n        //             console.assert(distT < 1e-3);\n        //         }\n        //     }\n        // }\n    }\n\n    raytrace(uvOut: vec2, ray: Ray): boolean {\n        if (!this.surface.intersect(uvOut, ray)) return false;\n        // return this.isInside(uvOut);\n        return true;\n    }\n\n    isInside(uv: ReadonlyVec2): boolean {\n        const { loops, sense } = this;\n        let nearestDist = Number.MAX_VALUE;\n        let inside = true;\n        for (const curves of loops) {\n            for (const curve of curves) {\n                const t = curve.project(uv);\n                curve.eval(t, projectedPoint, projectedTangent);\n                const dist = vec2.distance(uv, projectedPoint);\n                if (dist < nearestDist) {\n                    nearestDist = dist;\n                    vec2.sub(projectedPoint, uv, projectedPoint);\n                    const [tx, ty] = projectedTangent;\n                    // rotate tangent 90 deg clockwise, such that it points away from the interior of the curve\n                    projectedTangent[0] = ty * sense;\n                    projectedTangent[1] = -tx * sense;\n                    inside = vec2.dot(projectedTangent, projectedPoint) < 0;\n                }\n            }\n        }\n        return inside;\n    }\n}\n", "import { glMatrix, ReadonlyVec2, ReadonlyVec3, vec3 } from \"gl-matrix\";\nglMatrix.setMatrixArrayType(Array);\n\nconst tmp3 = vec3.create();\n\nexport class Ray {\n    constructor(readonly origin: ReadonlyVec3, readonly direction: ReadonlyVec3) {}\n\n    eval(pointOut: vec3, t: number) {\n        vec3.scale(pointOut, this.direction, t);\n        vec3.add(pointOut, pointOut, this.origin);\n    }\n\n    invert(point: ReadonlyVec3): number {\n        vec3.sub(tmp3, point, this.origin);\n        return vec3.dot(tmp3, this.direction);\n    }\n}\n\nexport interface Intersection {\n    readonly distance: number;\n    readonly uv: ReadonlyVec2;\n}\n", "import { glMatrix, mat3, mat4, ReadonlyMat3, ReadonlyMat4, ReadonlyVec2, ReadonlyVec3, vec2, vec3 } from \"gl-matrix\";\nimport { makeNurbsSurface } from \"./nurbs\";\nimport { Ray } from \"./ray\";\n\ntype SurfaceKind = \"plane\" | \"sphere\" | \"cylinder\" | \"cone\" | \"torus\" | \"nurbs\";\nglMatrix.setMatrixArrayType(Array);\n\nexport interface Surface {\n    readonly kind: SurfaceKind;\n    readonly sense: -1 | 1;\n    evalPosition(positionOut: vec3, uv: ReadonlyVec2): void;\n    evalNormal(normalOut: vec3, uv: ReadonlyVec2): void;\n    invert(uvOut: vec2, pos: ReadonlyVec3): void;\n    intersect(uvOut: vec2, ray: Ray): boolean;\n}\n\nconst tmp3 = vec3.create();\nconst origin = vec3.create();\nconst direction = vec3.create();\nconst unitRay = new Ray(origin, direction);\n\n// solution: 0 = smallest, 1 = largest\nfunction solveQuadraticPolynomial(a: number, b: number, c: number, solution: 0 | 1 = 0) {\n    const discriminant = b * b - 4 * a * c;\n    if (discriminant < 0 || a == 0) return undefined;\n    const sign = Math.sign(a) * solution ? 1 : -1;\n    // const s0 = (-b - Math.sqrt(discriminant)) / (2 * a);\n    // const s1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n    // if (s0 == s1) console.log(s0);\n    return (-b + sign * Math.sqrt(discriminant)) / (2 * a);\n}\n\nfunction combineMatrices(m0: ReadonlyMat4 | undefined, m1: mat4 | undefined): ReadonlyMat4 | undefined {\n    if (m0 && !m1) return m0;\n    else if (!m0 && m1) return m1;\n    else if (m0 && m1) {\n        return mat4.multiply(m1, m0, m1);\n        // return mat4.multiply(m1, m1, m0);\n    }\n}\n\nfunction unitSphereMatrix(radius: number): mat4 | undefined {\n    if (radius == 1) return undefined;\n    const m = mat4.create();\n    mat4.fromScaling(m, vec3.fromValues(radius, radius, radius));\n    return m;\n}\n\nfunction unitCylinderMatrix(radius: number): mat4 | undefined {\n    if (radius == 1) return undefined;\n    const m = mat4.create();\n    mat4.fromScaling(m, vec3.fromValues(radius, radius, 1));\n    return m;\n}\n\nexport abstract class UnitSurface implements Surface {\n    // Scale from mm to meters. Applied on functions that deal with 3D coordinate (which should be in meters), such as evalPos, invert and intersect. UV coords are still in mm since open cascade uses that unit internally and conversion is non-trivial.\n    private readonly surfaceToObjectSpaceTransform: ReadonlyMat4;\n    private readonly objectToSurfaceSpaceTransform: ReadonlyMat4;\n    private readonly surfaceToObjectSpaceTransformNormal: ReadonlyMat3;\n    private readonly objectToSurfaceSpaceTransformNormal: ReadonlyMat3;\n\n    constructor(readonly kind: SurfaceKind, surfaceToObjectSpaceTransform: ReadonlyMat4 | undefined, readonly sense: -1 | 1, readonly scale: number) {\n        const transform = surfaceToObjectSpaceTransform ? mat4.clone(surfaceToObjectSpaceTransform) : mat4.create();\n        const scaleMat = mat4.fromScaling(mat4.create(), vec3.fromValues(this.scale, this.scale, this.scale));\n        mat4.multiply(transform, scaleMat, transform);\n        this.surfaceToObjectSpaceTransform = transform;\n        const objectToSurfaceSpaceTransform = mat4.invert(mat4.create(), this.surfaceToObjectSpaceTransform);\n        this.objectToSurfaceSpaceTransform = objectToSurfaceSpaceTransform;\n        let surfaceToObjectSpaceTransformNormal = mat3.fromMat4(mat3.create(), this.surfaceToObjectSpaceTransform);\n        // mat3.normalFromMat4(surfaceToObjectSpaceTransformNormal, this.surfaceToObjectSpaceTransform)\n        this.surfaceToObjectSpaceTransformNormal = surfaceToObjectSpaceTransformNormal;\n        const objectToSurfaceSpaceTransformNormal = mat3.fromMat4(mat3.create(), this.objectToSurfaceSpaceTransform);\n        // mat3.normalFromMat4(objectToSurfaceSpaceTransformNormal, this.objectToSurfaceSpaceTransform)\n        this.objectToSurfaceSpaceTransformNormal = objectToSurfaceSpaceTransformNormal;\n    }\n\n    evalPosition(positionOut: vec3, uv: ReadonlyVec2) {\n        this.unitEvalPosition(positionOut, uv);\n        vec3.transformMat4(positionOut, positionOut, this.surfaceToObjectSpaceTransform);\n    }\n\n    evalNormal(normalOut: vec3, uv: ReadonlyVec2) {\n        this.unitEvalNormal(normalOut, uv);\n        vec3.scale(normalOut, normalOut, this.sense);\n        vec3.transformMat3(normalOut, normalOut, this.surfaceToObjectSpaceTransformNormal);\n        vec3.normalize(normalOut, normalOut);\n    }\n\n    invert(uvOut: vec2, point: ReadonlyVec3) {\n        vec3.transformMat4(tmp3, point, this.objectToSurfaceSpaceTransform);\n        this.unitInvert(uvOut, tmp3);\n    }\n\n    intersect(uvOut: vec2, ray: Ray): boolean {\n        vec3.transformMat4(origin, ray.origin, this.objectToSurfaceSpaceTransform);\n        vec3.transformMat3(direction, ray.direction, this.objectToSurfaceSpaceTransformNormal); // it's okay of direction isn't a normal (length=1)\n        const t = this.unitIntersect(unitRay);\n        if (!t) return false;\n        unitRay.eval(tmp3, t);\n        this.unitInvert(uvOut, tmp3);\n        return true;\n    }\n\n    dispose(): void {}\n\n    protected abstract unitEvalPosition(positionOut: vec3, uv: ReadonlyVec2): void;\n    protected abstract unitEvalNormal(normalOut: vec3, uv: ReadonlyVec2): void;\n    protected abstract unitInvert(uvOut: vec2, point: ReadonlyVec3): void;\n    protected abstract unitIntersect(ray: Ray): number | undefined;\n}\n\nexport class Plane extends UnitSurface {\n    constructor(surfaceToObjectSpaceTransform?: ReadonlyMat4, sense: -1 | 1 = 1, scale?: number) {\n        super(\"plane\", surfaceToObjectSpaceTransform, sense, scale ?? 1);\n    }\n\n    unitEvalPosition(positionOut: vec3, uv: ReadonlyVec2) {\n        vec3.set(positionOut, uv[0], uv[1], 0);\n    }\n\n    unitEvalNormal(normalOut: vec3, uv: ReadonlyVec2 | undefined) {\n        vec3.set(normalOut, 0, 0, 1);\n    }\n\n    unitInvert(uvOut: vec2, point: ReadonlyVec3) {\n        return vec2.set(uvOut, point[0], point[1]);\n    }\n\n    unitIntersect(ray: Ray): number | undefined {\n        if (ray.direction[2] * this.sense < 0) {\n            // only intersect forward facing planes\n            const t = -ray.origin[2] / ray.direction[2];\n            return t;\n        }\n    }\n}\n\nexport class Sphere extends UnitSurface {\n    constructor(readonly radius = 1, surfaceToObjectSpaceTransform?: ReadonlyMat4, sense: -1 | 1 = 1, scale?: number) {\n        super(\"sphere\", combineMatrices(surfaceToObjectSpaceTransform, unitSphereMatrix(radius)), sense, scale ?? 1);\n    }\n\n    unitEvalPosition(positionOut: vec3, uv: ReadonlyVec2) {\n        const s = Math.cos(uv[1]);\n        vec3.set(positionOut, Math.cos(uv[0]) * s, Math.sin(uv[0]) * s, Math.sin(uv[1]));\n    }\n\n    unitEvalNormal(normalOut: vec3, uv: ReadonlyVec2) {\n        const s = Math.cos(uv[1]);\n        vec3.set(normalOut, Math.cos(uv[0]) * s, Math.sin(uv[0]) * s, Math.sin(uv[1]));\n    }\n\n    unitInvert(uvOut: vec2, point: ReadonlyVec3) {\n        vec2.set(uvOut, Math.atan2(point[1], point[0]), Math.asin(Math.max(-1, Math.min(1, point[2]))));\n    }\n\n    unitIntersect(ray: Ray) {\n        const { origin, direction } = ray;\n        const [x0, y0, z0] = origin;\n        const [dx, dy, dz] = direction;\n\n        const a = dx * dx + dy * dy + dz * dz;\n        const b = 2 * (x0 * dx + y0 * dy + z0 * dz);\n        const c = x0 * x0 + y0 * y0 + z0 * z0 - 1;\n        const t = solveQuadraticPolynomial(a, b, c, this.sense > 0 ? 0 : 1);\n        return t;\n    }\n}\n\nexport class Cylinder extends UnitSurface {\n    constructor(readonly radius = 1, surfaceToObjectSpaceTransform?: ReadonlyMat4, sense: -1 | 1 = 1, scale?: number) {\n        super(\"cylinder\", combineMatrices(surfaceToObjectSpaceTransform, unitCylinderMatrix(radius)), (sense * matrixInversion(surfaceToObjectSpaceTransform)) as -1 | 1, scale ?? 1);\n    }\n\n    unitEvalPosition(positionOut: vec3, uv: ReadonlyVec2) {\n        vec3.set(positionOut, Math.cos(uv[0]), Math.sin(uv[0]), uv[1]);\n    }\n\n    unitEvalNormal(normalOut: vec3, uv: ReadonlyVec2) {\n        vec3.set(normalOut, Math.cos(uv[0]), Math.sin(uv[0]), 0);\n    }\n\n    unitInvert(uvOut: vec2, point: ReadonlyVec3) {\n        const [x, y, z] = point;\n        let u = Math.atan2(y, x);\n        if (u < 0) u += Math.PI * 2;\n        vec2.set(uvOut, u, z);\n    }\n\n    unitIntersect(ray: Ray) {\n        const { origin, direction } = ray;\n        const [x0, y0] = origin;\n        const [dx, dy] = direction;\n        const a = dx * dx + dy * dy;\n        const b = 2 * (x0 * dx + y0 * dy);\n        const c = x0 * x0 + y0 * y0 - 1;\n        const t = solveQuadraticPolynomial(a, b, c, this.sense > 0 ? 0 : 1);\n        return t;\n    }\n}\n\nfunction unitConeMatrix(halfAngleTan: number, radius: number): mat4 | undefined {\n    if (halfAngleTan == 1) return undefined;\n    const scaleXY = 1; // Math.abs(halfAngleTan);\n    const scaleZ = 1 / halfAngleTan; // Math.sign(halfAngleTan); //Math.cos(Math.atan(halfAngleTan));\n    const s = mat4.create();\n    const t = mat4.create();\n    const m = mat4.create();\n    // z = (z + radius) / halfAngleTan;\n    mat4.fromTranslation(t, vec3.fromValues(0, 0, radius * Math.sign(halfAngleTan)));\n    mat4.fromScaling(s, vec3.fromValues(scaleXY, scaleXY, scaleZ));\n    mat4.multiply(m, s, t);\n    return m;\n}\n\nfunction matrixInversion(m?: ReadonlyMat4): 1 | -1 {\n    if (!m) return 1;\n\n    const [e00, e01, e02, e03, e10, e11, e12, e13, e20, e21, e22, e23, e30, e31, e32, e33] = m;\n    const x = vec3.fromValues(e00, e10, e20);\n    const y = vec3.fromValues(e01, e11, e21);\n    const z = vec3.fromValues(e02, e12, e22);\n    const cp = vec3.create();\n    vec3.cross(cp, x, y);\n    const dp = vec3.dot(cp, z);\n    return dp >= 0 ? 1 : -1;\n}\n\nexport class Cone extends UnitSurface {\n    readonly scaleV;\n    // readonly offsetV;\n\n    constructor(readonly radius = 1, readonly halfAngleTan = -1, surfaceToObjectSpaceTransform?: ReadonlyMat4, sense: -1 | 1 = 1, scale?: number) {\n        super(\"cone\", combineMatrices(surfaceToObjectSpaceTransform, unitConeMatrix(halfAngleTan, radius)), (sense * matrixInversion(surfaceToObjectSpaceTransform)) as -1 | 1, scale ?? 1);\n        this.scaleV = halfAngleTan * Math.cos(Math.atan(halfAngleTan));\n    }\n\n    unitEvalPosition(positionOut: vec3, uv: ReadonlyVec2) {\n        let [u, v] = uv;\n        v = v * this.scaleV + this.radius; // / Math.abs(this.halfAngleTan);\n        vec3.set(positionOut, Math.cos(u) * v, Math.sin(u) * v, v);\n    }\n\n    unitEvalNormal(normalOut: vec3, uv: ReadonlyVec2) {\n        const [u, v] = uv;\n        const s = Math.sqrt(0.5);\n        vec3.set(normalOut, Math.cos(u) * s, Math.sin(u) * s, -s);\n    }\n\n    unitInvert(uvOut: vec2, point: ReadonlyVec3) {\n        const [x, y, z] = point;\n        let u = Math.atan2(y, x);\n        if (u < 0) u += Math.PI * 2;\n        const v = (z - this.radius) / this.scaleV;\n        vec2.set(uvOut, u, v);\n    }\n\n    unitIntersect(ray: Ray) {\n        const { origin, direction } = ray;\n        const [x0, y0, z0] = origin;\n        const [dx, dy, dz] = direction;\n        const a = dx * dx + dy * dy - dz * dz;\n        const b = 2 * (x0 * dx + y0 * dy - z0 * dz);\n        const c = x0 * x0 + y0 * y0 - z0 * z0;\n        // const t = solveQuadraticPolynomial(a, b, c, 0); // perhaps just give the hit that faces the ray?\n        const t = solveQuadraticPolynomial(a, b, c, this.sense > 0 ? 0 : 1); // perhaps just give the hit that faces the ray?\n        return t;\n    }\n}\n\nexport class Torus extends UnitSurface {\n    constructor(readonly majorRadius = 1, readonly minorRadius = 0.5, surfaceToObjectSpaceTransform?: ReadonlyMat4, sense: -1 | 1 = 1, scale?: number) {\n        super(\"torus\", surfaceToObjectSpaceTransform, sense, scale ?? 1);\n    }\n\n    unitEvalPosition(positionOut: vec3, uv: ReadonlyVec2) {\n        const [u, v] = uv;\n        const { majorRadius, minorRadius } = this;\n        const r = majorRadius + Math.cos(v) * minorRadius;\n        vec3.set(positionOut, Math.cos(u) * r, Math.sin(u) * r, Math.sin(v) * minorRadius);\n    }\n\n    unitEvalNormal(normalOut: vec3, uv: ReadonlyVec2) {\n        const [u, v] = uv;\n        vec3.set(normalOut, Math.cos(u) * Math.cos(v), Math.sin(u) * Math.cos(v), Math.sin(v));\n    }\n\n    unitInvert(uvOut: vec2, point: ReadonlyVec3) {\n        const [x, y, z] = point;\n        let u = Math.atan2(y, x);\n        if (u < 0) u += Math.PI * 2;\n        let v = Math.atan2(z, Math.sqrt(x * x + y * y) - this.majorRadius);\n        if (v < 0) v += Math.PI * 2;\n        vec2.set(uvOut, u, v);\n    }\n\n    unitIntersect(ray: Ray) {\n        // TODO: handle inverted torus\n        return intersectTorus(ray, this.majorRadius, this.minorRadius);\n    }\n}\n\ntype Pointer = number;\n\nexport class Nurbs extends UnitSurface {\n    readonly kind = \"nurbs\";\n    ptr: Pointer = 0;\n    constructor(readonly orders: [number, number], readonly dim: [number, number], readonly controlPoints: ReadonlyVec3[], readonly knots: number[], readonly weights: number[] | undefined, readonly sense: -1 | 1, private readonly wasmInstance: any, private readonly buffer: Float64Array, scale?: number) {\n        super(\"nurbs\", undefined, sense, scale ?? 1);\n    }\n\n    dispose() {\n        if (this.weights) {\n            this.wasmInstance._disposeNurbsSurface(this.ptr);\n        } else {\n            this.wasmInstance._disposeNurbsSurfaceWithWeights(this.ptr);\n        }\n    }\n\n    unitEvalPosition(positionOut: vec3, uv: ReadonlyVec2) {\n        if (this.ptr === 0) {\n            this.ptr = makeNurbsSurface(this.wasmInstance, this.knots, this.dim[0], this.dim[1], this.controlPoints, this.weights, this.orders[0], this.orders[1]);\n        }\n        if (this.weights) {\n            this.wasmInstance._evalNurbsSurfaceWithWeights(this.ptr, uv[0], uv[1], this.buffer.byteOffset, undefined);\n        } else {\n            this.wasmInstance._evalNurbsSurface(this.ptr, uv[0], uv[1], this.buffer.byteOffset, undefined);\n        }\n        const [x, y, z] = this.buffer.subarray(0, 3);\n        vec3.set(positionOut, x, y, z);\n    }\n\n    unitEvalNormal(normalOut: vec3, uv: ReadonlyVec2) {\n        if (this.ptr === 0) {\n            this.ptr = makeNurbsSurface(this.wasmInstance, this.knots, this.dim[0], this.dim[1], this.controlPoints, this.weights, this.orders[0], this.orders[1]);\n        }\n        if (this.weights) {\n            this.wasmInstance._evalNurbsSurfaceWithWeights(this.ptr, uv[0], uv[1], undefined, this.buffer.byteOffset + 24);\n        } else {\n            this.wasmInstance._evalNurbsSurface(this.ptr, uv[0], uv[1], undefined, this.buffer.byteOffset + 24);\n        }\n        const [x, y, z] = this.buffer.subarray(3, 6);\n        vec3.set(normalOut, -x, -y, -z);\n    }\n\n    unitInvert(uvOut: vec2, pos: ReadonlyVec3) {\n        if (this.ptr === 0) {\n            this.ptr = makeNurbsSurface(this.wasmInstance, this.knots, this.dim[0], this.dim[1], this.controlPoints, this.weights, this.orders[0], this.orders[1]);\n        }\n        this.wasmInstance._invertSurface(this.ptr, pos[0], pos[1], pos[2], this.buffer.byteOffset);\n        const [u, v] = this.buffer.subarray(0, 2);\n        vec2.set(uvOut, u, v);\n    }\n    unitIntersect(ray: Ray) {\n        return undefined;\n    }\n}\n\n// f(x) = (|x|\u00B2 + R\u00B2 - r\u00B2)\u00B2 - 4\u00B7R\u00B2\u00B7|xy|\u00B2 = 0\nfunction intersectTorus(ray: Ray, majorRadius: number, minorRadius: number) {\n    const { origin, direction } = ray;\n    let po = 1.0;\n\n    const Ra2 = majorRadius * majorRadius;\n    const ra2 = minorRadius * minorRadius;\n\n    const m = vec3.dot(origin, origin);\n    const n = vec3.dot(origin, direction);\n\n    // bounding sphere\n    {\n        const h = n * n - m + (majorRadius + minorRadius) * (majorRadius + minorRadius);\n        if (h < 0.0) return undefined;\n        //const t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n\n    // find quartic equation\n    const k = (m - ra2 - Ra2) / 2.0;\n    let k3 = n;\n    let k2 = n * n + Ra2 * direction[2] * direction[2] + k;\n    let k1 = k * n + Ra2 * origin[2] * direction[2];\n    let k0 = k * k + Ra2 * origin[2] * origin[2] - Ra2 * ra2;\n\n    // prevent |c1| from being too close to zero\n    if (Math.abs(k3 * (k3 * k3 - k2) + k1) < 0.01) {\n        po = -1.0;\n        const tmp = k1;\n        k1 = k3;\n        k3 = tmp;\n        k0 = 1.0 / k0;\n        k1 = k1 * k0;\n        k2 = k2 * k0;\n        k3 = k3 * k0;\n    }\n\n    let c2 = 2.0 * k2 - 3.0 * k3 * k3;\n    let c1 = k3 * (k3 * k3 - k2) + k1;\n    let c0 = k3 * (k3 * (-3.0 * k3 * k3 + 4.0 * k2) - 8.0 * k1) + 4.0 * k0;\n\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n\n    const Q = c2 * c2 + c0;\n    const R = 3.0 * c0 * c2 - c2 * c2 * c2 - c1 * c1;\n\n    let h = R * R - Q * Q * Q;\n    let z = 0.0;\n    if (h < 0.0) {\n        // 4 intersections\n        const sQ = Math.sqrt(Q);\n        z = 2.0 * sQ * Math.cos(Math.acos(R / (sQ * Q)) / 3.0);\n    } else {\n        // 2 intersections\n        const sQ = Math.pow(Math.sqrt(h) + Math.abs(R), 1.0 / 3.0);\n        z = Math.sign(R) * Math.abs(sQ + Q / sQ);\n    }\n    z = c2 - z;\n\n    let d1 = z - 3.0 * c2;\n    let d2 = z * z - 3.0 * c0;\n    if (Math.abs(d1) < 1.0e-4) {\n        if (d2 < 0.0) return undefined;\n        d2 = Math.sqrt(d2);\n    } else {\n        if (d1 < 0.0) return undefined;\n        d1 = Math.sqrt(d1 / 2.0);\n        d2 = c1 / d1;\n    }\n\n    //----------------------------------\n\n    let result = Number.MAX_VALUE;\n\n    h = d1 * d1 - z + d2;\n    if (h > 0.0) {\n        h = Math.sqrt(h);\n        let t1 = -d1 - h - k3;\n        t1 = po < 0.0 ? 2.0 / t1 : t1;\n        let t2 = -d1 + h - k3;\n        t2 = po < 0.0 ? 2.0 / t2 : t2;\n        if (t1 > 0.0) result = t1;\n        if (t2 > 0.0) result = Math.min(result, t2);\n    }\n\n    h = d1 * d1 - z - d2;\n    if (h > 0.0) {\n        h = Math.sqrt(h);\n        let t1 = d1 - h - k3;\n        t1 = po < 0.0 ? 2.0 / t1 : t1;\n        let t2 = d1 + h - k3;\n        t2 = po < 0.0 ? 2.0 / t2 : t2;\n        if (t1 > 0.0) result = Math.min(result, t1);\n        if (t2 > 0.0) result = Math.min(result, t2);\n    }\n\n    if (result != Number.MAX_VALUE) return result;\n}\n", "import type { ReadonlyMat4 } from \"gl-matrix\";\nimport type { Curve3D } from \"./curves\";\n\nexport class Edge {\n    constructor(\n        readonly curve: Curve3D,\n        readonly geometryTransformation: ReadonlyMat4,\n        readonly instanceIndex: number\n    ) { }\n}", "import { mat4, glMatrix, vec2, vec3 } from \"gl-matrix\";\n// import cubeJson from \"../public/cube.json\";\n// import cylinderJson from \"../public/cylinder.json\";\n// import coneJson from \"../public/cone.json\";\n// import tubeJson from \"../public/tube.json\";\nimport {\n  Arc2D,\n  Arc3D,\n  Curve2D,\n  Curve3D,\n  Line2D,\n  Line3D,\n  LineStrip3D,\n  NurbsCurve2D,\n  NurbsCurve3D,\n} from \"./curves\";\nimport { Face, Seam } from \"./face\";\nimport type {\n  ProductData,\n  IndexPair,\n  SurfaceData,\n  FaceData,\n  InstanceData,\n  AABB2,\n  CurveSegmentData,\n  EdgeData,\n} from \"./brep\";\nimport { Cone, Cylinder, Nurbs, Plane, Surface, Torus } from \"./surfaces\";\nimport { createWasmInstance } from \"./nurbs\";\nimport { Edge } from \"./edge\";\n\nglMatrix.setMatrixArrayType(Array);\n\nexport function matFromInstance(instance: InstanceData): mat4 {\n  if (instance.transformation !== undefined) {\n    return mat4.fromValues(\n      ...(instance.transformation as Parameters<typeof mat4.fromValues>)\n    );\n  }\n  return mat4.identity(mat4.create());\n}\n\nexport const geometryFactory = createGeometryFactory();\n\n// type FixedSizeArray<N extends number, T> = N extends 0 ? never[] : {\n//     // 0: T;\n//     length: N;\n// } & ReadonlyArray<T>;\n\n// type GeometryData = typeof box | typeof cylinder;\n// type HalfEdgeData = GeometryData[\"halfEdges\"][number];\n// type Curve2DData = GeometryData[\"curves2d\"][number];\n\n// type Index = number;\n// type IndexPair = readonly [number, number];\n\n// interface GeometryData {\n//     readonly faces: readonly FaceData[];\n//     readonly loops: readonly LoopData[];\n//     readonly edges: readonly EdgeData[];\n//     readonly halfEdges: readonly HalfEdgeData[];\n//     readonly surfaces: readonly SurfaceData[];\n//     readonly curves2d: readonly Curve2DData[];\n// }\n\n// interface FaceData {\n//     readonly surface: Index;\n//     readonly outerLoop: Index;\n//     readonly innerLoops?: readonly Index[];\n//     readonly facing: -1 | 1;\n// }\n\n// interface LoopData {\n//     readonly halfEdges: readonly Index[];\n// }\n\n// interface EdgeData {\n//     readonly curve3d: Index;\n//     readonly parameterBounds: readonly [number, number];\n//     readonly halfEdges: IndexPair;\n//     readonly vertices?: IndexPair;\n//     readonly arcLength: number;\n//     readonly aabb: {\n//         readonly min: ReadonlyVec3;\n//         readonly max: ReadonlyVec3;\n//     };\n//     readonly tesselationParameters: readonly number[];\n// }\n\n// interface HalfEdgeData {\n//     readonly curve2d: number;\n//     readonly parameterBounds: readonly [number, number];\n//     readonly direction: -1 | 1;\n// }\n\n// interface PlaneData {\n//     readonly kind: \"plane\";\n//     readonly sense: -1 | 1;\n//     readonly transform: FixedSizeArray<number, 16>;\n// };\n\n// interface CylinderData {\n//     readonly kind: \"cylinder\";\n//     readonly sense: -1 | 1;\n//     readonly transform: FixedSizeArray<number, 16>;\n//     readonly radius: number;\n// };\n\n// type SurfaceData = PlaneData | CylinderData;\n\n// interface Line2DData {\n//     readonly kind: \"line\";\n//     readonly origin: ReadonlyVec2;\n//     readonly direction: ReadonlyVec2;\n// }\n\n// interface Circle2DData {\n//     readonly kind: \"circle\";\n//     readonly origin: ReadonlyVec2;\n//     readonly radius: number;\n// }\n\n// type Curve2DData = Line2DData | Circle2DData;\n\n// const cube = cubeJson as unknown as GeometryData;\n// const cylinder = cylinderJson as unknown as GeometryData;\n// const cone = coneJson as unknown as GeometryData;\n// const tube = tubeJson as unknown as GeometryData;\n\n// export { cube, cylinder, cone, tube };\n\nexport function unitToScale(unit: string) {\n  switch (unit) {\n    case \"mm\":\n      return 1 / 1000;\n    case \"cm\":\n      return 1 / 100;\n    case \"in\":\n      return 0.0254;\n    default:\n      return 1;\n  }\n}\n\nexport async function createGeometryFactory() {\n  const wasmInstance = await createWasmInstance();\n  var dataPtr = wasmInstance._malloc(48);\n  var dataHeap = new Float64Array(wasmInstance.HEAPF64.buffer, dataPtr, 6);\n  return new GeometryFactory(wasmInstance, dataHeap);\n}\n\nexport function crawlInstance(\n  product: ProductData,\n  instanceData: InstanceData,\n  includeInnerFaces: boolean,\n  faceFunc: (faceIdx: number) => void\n) {\n  const geometryData = product.geometries[instanceData.geometry as number];\n  if (geometryData.shells) {\n    for (const shellIdx of geometryData.shells) {\n      const shell = product.shells[shellIdx];\n      for (const faceIdx of shell.faces) {\n        faceFunc(faceIdx);\n      }\n    }\n  }\n  if (geometryData.solids) {\n    for (const solidIdx of geometryData.solids) {\n      const solid = product.solids[solidIdx];\n      for (const faceIdx of product.shells[solid.outerShell].faces) {\n        faceFunc(faceIdx);\n      }\n      if (solid.innerShells) {\n        for (const innerShellIdx of solid.innerShells) {\n          const shell = product.shells[innerShellIdx];\n          for (const faceIdx of shell.faces) {\n            faceFunc(faceIdx);\n          }\n        }\n      }\n    }\n  }\n}\n\nexport class GeometryFactory {\n  constructor(\n    private readonly wasmInstance: any,\n    private readonly buffer: Float64Array\n  ) { }\n\n  getCurve2D(data: ProductData, halfEdgeIndex: number): Curve2D {\n    const halfEdgeData = data.halfEdges[halfEdgeIndex];\n    let [beginParam, endParam] = halfEdgeData.parameterBounds;\n    let sense: 1 | -1 = 1;\n    if (halfEdgeData.direction < 0) {\n      sense = -1; // this is only used for negating tangents.\n      [beginParam, endParam] = [endParam, beginParam]; // flip parameters\n    }\n    const curveData = data.curves2D[halfEdgeData.curve2D];\n    switch (curveData.kind) {\n      case \"line\": {\n        const origin = vec2.fromValues(\n          ...(curveData.origin as Parameters<typeof vec2.fromValues>)\n        );\n        const direction = vec2.fromValues(\n          ...(curveData.direction as Parameters<typeof vec2.fromValues>)\n        );\n        return new Line2D(origin, direction, beginParam, endParam, sense);\n      }\n      case \"circle\": {\n        const origin = vec2.fromValues(\n          ...(curveData.origin as Parameters<typeof vec2.fromValues>)\n        );\n        const { radius } = curveData;\n        return new Arc2D(origin, radius, beginParam, endParam, sense);\n      }\n      case \"nurbs\": {\n        const { order, controlPoints, knots, weights } = curveData;\n        return new NurbsCurve2D(\n          order,\n          controlPoints,\n          knots,\n          weights,\n          beginParam,\n          endParam,\n          sense,\n          this.wasmInstance,\n          this.buffer\n        );\n      }\n      default:\n        throw Error(`Unsupported curve type!`);\n    }\n  }\n\n  getCurve3D(data: ProductData, halfEdgeIndex: number): Curve3D | undefined {\n    const halfEdgeData = data.halfEdges[halfEdgeIndex];\n    return this.getCurve3DFromEdge(\n      data,\n      halfEdgeData.edge,\n      halfEdgeData.direction\n    );\n  }\n\n  getHalfEdgeAABB(data: ProductData, halfEdgeIndex: number): AABB2 | undefined {\n    const curve = this.getCurve2D(data, halfEdgeIndex);\n    const points: vec2[] = [];\n\n    switch (curve.kind) {\n      case \"line\":\n        points.push(vec2.create());\n        points.push(vec2.create());\n        curve.eval(curve.beginParam, points[0], undefined);\n        curve.eval(curve.endParam, points[1], undefined);\n        break;\n      case \"arc\":\n        points.push(vec2.create());\n        points.push(vec2.create());\n        curve.eval(curve.beginParam, points[0], undefined);\n        curve.eval(curve.endParam, points[1], undefined);\n        const paramOffset = curve.endParam > 2 * Math.PI ? -Math.PI * 2 : 0;\n        for (let i = 1; i < 4; ++i) {\n          const param = (Math.PI / 2) * i + paramOffset;\n          if (param >= curve.beginParam && param <= curve.endParam) {\n            const point = vec2.create();\n            curve.eval(param, point, undefined);\n            points.push(point);\n          }\n        }\n        break;\n      //TODO begin and end + max 4 tangents coords\n      default:\n        return undefined;\n    }\n    const min = vec2.copy(vec2.create(), points[0]);\n    const max = vec2.copy(vec2.create(), points[0]);\n    for (let i = 1; i < points.length; ++i) {\n      vec2.min(min, min, points[i]);\n      vec2.max(max, max, points[i]);\n    }\n    return { min, max };\n  }\n\n  private getCurve3DFromEdgeOrSegment(\n    data: ProductData,\n    segmentData: CurveSegmentData | EdgeData\n  ) {\n    if (segmentData.curve3D != undefined) {\n      let [beginParam, endParam] = segmentData.parameterBounds;\n      const curveData = data.curves3D[segmentData.curve3D];\n      switch (curveData.kind) {\n        case \"line\": {\n          const origin = vec3.fromValues(\n            ...(curveData.origin as Parameters<typeof vec3.fromValues>)\n          );\n          const direction = vec3.fromValues(\n            ...(curveData.direction as Parameters<typeof vec3.fromValues>)\n          );\n          return new Line3D(\n            origin,\n            direction,\n            beginParam,\n            endParam,\n            1,\n            segmentData.tesselationParameters\n          );\n        }\n        case \"circle\": {\n          const origin = vec3.fromValues(\n            ...(curveData.origin as Parameters<typeof vec3.fromValues>)\n          );\n          const { radius, axisX, axisY } = curveData;\n          return new Arc3D(\n            origin,\n            axisX,\n            axisY,\n            radius,\n            beginParam,\n            endParam,\n            1,\n            segmentData.tesselationParameters\n          );\n        }\n        case \"nurbs\": {\n          const { order, controlPoints, knots, weights } = curveData;\n          return new NurbsCurve3D(\n            order,\n            controlPoints,\n            knots,\n            weights,\n            beginParam,\n            endParam,\n            1,\n            segmentData.tesselationParameters,\n            this.wasmInstance,\n            this.buffer\n          );\n        }\n        case \"lineStrip\": {\n          return new LineStrip3D(\n            curveData.vertices,\n            beginParam,\n            endParam,\n            segmentData.tesselationParameters\n          );\n        }\n        default:\n          throw Error(`Unsupported curve type!`);\n      }\n    }\n  }\n\n  getCurve3DFromSegment(data: ProductData, segmentIndex: number) {\n    return this.getCurve3DFromEdgeOrSegment(\n      data,\n      data.curveSegments[segmentIndex]\n    );\n  }\n\n  getCurve3DFromEdge(\n    data: ProductData,\n    edgeIndex: number,\n    sense: 1 | -1 = 1\n  ): Curve3D | undefined {\n    return this.getCurve3DFromEdgeOrSegment(data, data.edges[edgeIndex]);\n  }\n\n  getSurface(data: SurfaceData, sense: -1 | 1, scale?: number): Surface {\n    switch (data.kind) {\n      case \"plane\": {\n        const transform = mat4.fromValues(\n          ...(data.transform as Parameters<typeof mat4.fromValues>)\n        );\n        return new Plane(transform, sense, scale);\n      }\n      case \"cylinder\": {\n        const transform = mat4.fromValues(\n          ...(data.transform as Parameters<typeof mat4.fromValues>)\n        );\n        return new Cylinder(data.radius, transform, sense, scale);\n      }\n      case \"cone\": {\n        const transform = mat4.fromValues(\n          ...(data.transform as Parameters<typeof mat4.fromValues>)\n        );\n        return new Cone(\n          data.radius,\n          data.halfAngleTan,\n          transform,\n          sense,\n          scale\n        );\n      }\n      case \"torus\": {\n        const transform = mat4.fromValues(\n          ...(data.transform as Parameters<typeof mat4.fromValues>)\n        );\n        return new Torus(\n          data.majorRadius,\n          data.minorRadius,\n          transform,\n          sense,\n          scale\n        );\n      }\n      case \"nurbs\": {\n        return new Nurbs(\n          data.orders,\n          data.dim,\n          data.controlPoints,\n          data.knots,\n          data.weights,\n          sense,\n          this.wasmInstance,\n          this.buffer,\n          scale\n        );\n      }\n      default:\n        throw Error(`Unsupported surface type!`);\n    }\n  }\n\n  makeFace(\n    face: FaceData,\n    instance: InstanceData,\n    instanceIndex: number,\n    product: ProductData,\n    curves2D: Curve2D[]\n  ) {\n    const loops = [face.outerLoop, ...(face.innerLoops ?? [])];\n    const virtualEdges = new Set<number>();\n    const faceCurves2D = loops.map((l) => {\n      return product.loops[l].halfEdges.map((e) => {\n        const halfEdge = product.halfEdges[e];\n        const edgeIndex = halfEdge.edge;\n        const edge = product.edges[edgeIndex];\n        if (edge.virtual) {\n          virtualEdges.add(edgeIndex);\n        }\n        return curves2D[e];\n      });\n    });\n    const seams: Seam[] = [];\n    for (const ei of virtualEdges) {\n      const edge = product.edges[ei];\n      const [a, b] = edge.halfEdges;\n      if (b != null) {\n        console.assert(product.halfEdges[a].face == product.halfEdges[b].face); // confirm that this is indeed a virtual edge.\n        const ia = product.halfEdges[a].faceVertexIndices;\n        const ib = product.halfEdges[b].faceVertexIndices;\n        console.assert(ia.length == ib.length);\n        // mark pairs of vertices on opposite side of virtual edge to be merged into one\n        const vertexIndexPairs: IndexPair[] = [];\n        for (let i = 0; i < ia.length; i++) {\n          // vertexIndexPairs.push([ia[i], ib[ib.length - i - 1]]);\n          vertexIndexPairs.push([ia[i], ib[i]]);\n        }\n        seams.push({ vertexIndexPairs });\n      }\n    }\n    const surface = this.getSurface(\n      product.surfaces[face.surface],\n      face.facing\n    );\n    return new Face(\n      surface,\n      face.facing,\n      faceCurves2D,\n      face.triangulation,\n      seams,\n      instanceIndex,\n      instance.transformation ? matFromInstance(instance) : undefined\n    );\n  }\n\n  getFaces(product: ProductData) {\n    const curves2D = product.halfEdges.map((_, i) => {\n      return this.getCurve2D(product, i);\n    }); // we map curve2D as 1:1 with halfedges\n    const faces: Face[] = [];\n\n    for (let i = 0; i < product.instances.length; ++i) {\n      const instance = product.instances[i];\n\n      const faceFunc = (faceIdx: number) => {\n        faces.push(\n          this.makeFace(product.faces[faceIdx], instance, i, product, curves2D)\n        );\n      };\n\n      if (typeof instance.geometry == \"number\") {\n        //check geom is number\n        crawlInstance(product, instance, true, faceFunc);\n      }\n    }\n\n    return faces;\n  }\n\n  getCurvesFromEdges(product: ProductData, edgeInstances: number[]) {\n    const curves = new Array<Edge | undefined>();\n    for (let i = 0; i < product.edges.length; ++i) {\n      const curve = this.getCurve3DFromEdge(product, i);\n      const edgeData = product.edges[i];\n      if (curve && !edgeData.virtual) {\n        const instance = product.instances[edgeInstances[i]];\n        const transform = mat4.create();\n        if (instance.transformation) {\n          mat4.mul(transform, transform, matFromInstance(instance));\n        }\n        curves.push(new Edge(curve, transform, edgeInstances[i]));\n      } else {\n        curves.push(undefined);\n      }\n    }\n    return curves;\n  }\n\n  getEdges(product: ProductData) {\n    const edgeInstances = new Array<number>(product.edges.length);\n\n    for (let i = 0; i < product.instances.length; ++i) {\n      const addFaceEdges = (faceIdx: number) => {\n        const face = product.faces[faceIdx];\n        const loops = [face.outerLoop, ...(face.innerLoops ?? [])];\n        for (const loopIdx of loops) {\n          const loop = product.loops[loopIdx];\n          for (const halfEdgeIdx of loop.halfEdges) {\n            const halfEdge = product.halfEdges[halfEdgeIdx];\n            edgeInstances[halfEdge.edge] = i;\n          }\n        }\n      };\n\n      const instance = product.instances[i];\n      if (typeof instance.geometry == \"number\") {\n        //check geom is number\n        crawlInstance(product, instance, true, addFaceEdges);\n      }\n    }\n    return this.getCurvesFromEdges(product, edgeInstances);\n  }\n}\n", "import {\n  vec3,\n  glMatrix,\n  ReadonlyVec3,\n  ReadonlyVec2,\n  mat4,\n  vec2,\n} from \"gl-matrix\";\nimport type { CylinderData, ProductData } from \"./brep\";\nimport { cylinderCenterLine } from \"./calculations\";\nimport type { Arc3D } from \"./curves\";\nimport { matFromInstance } from \"./loader\";\nglMatrix.setMatrixArrayType(Array);\n\nexport async function swapCylinderImpl(product: ProductData, faceIdx: number, instanceIdx: number, to: \"inner\" | \"outer\"): Promise<number | undefined> {\n  const faceData = product.faces[faceIdx];\n  const surfaceData = product.surfaces[faceData.surface];\n\n  if (surfaceData.kind == \"cylinder\") {\n    const cylinderData = surfaceData as CylinderData;\n    const mat = matFromInstance(product.instances[instanceIdx]);\n    const [cylinderOrigo, cylinderEnd] = await cylinderCenterLine(\n      product,\n      faceData,\n      cylinderData,\n      mat,\n      \"center\"\n    );\n    let selectedIdx: number | undefined = undefined;\n    let currentRadius = surfaceData.radius;\n    const loopShell = async (shellIdx: number) => {\n      const shell = product.shells[shellIdx];\n      for (const currentFaceIdx of shell.faces) {\n        if (currentFaceIdx != faceIdx) {\n          const face = product.faces[currentFaceIdx];\n          const surface = product.surfaces[face.surface];\n          if (surface.kind == \"cylinder\") {\n            if (\n              (to == \"outer\" && surface.radius > currentRadius) ||\n              (to == \"inner\" && surface.radius < currentRadius)\n            ) {\n              const [currentCylinderOrigo, currentCylinderEnd] =\n                await cylinderCenterLine(\n                  product,\n                  face,\n                  surface,\n                  mat,\n                  \"center\"\n                );\n              if (\n                vec3.dist(currentCylinderOrigo, cylinderOrigo) < 0.01 &&\n                vec3.dist(currentCylinderEnd, cylinderEnd) < 0.01\n              ) {\n                selectedIdx = currentFaceIdx;\n                currentRadius = surface.radius;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    for (const instance of product.instances) {\n      const geom = product.geometries[instance.geometry as number];\n      if (geom.shells) {\n        for (const shellIdx of geom.shells) {\n          await loopShell(shellIdx);\n        }\n      }\n      if (geom.solids) {\n        for (const solidIdx of geom.solids) {\n          const solid = product.solids[solidIdx];\n          await loopShell(solid.outerShell);\n        }\n      }\n    }\n    return selectedIdx;\n  }\n}\n\nexport function closestPointToLine(\n  point: ReadonlyVec3,\n  lineStart: ReadonlyVec3,\n  lineEnd: ReadonlyVec3,\n  projectedPoint?: vec3\n): { pos: vec3; parameter: number } {\n  const lineVec = vec3.sub(vec3.create(), lineEnd, lineStart);\n  const startToP = vec3.sub(vec3.create(), point, lineStart);\n  const t = vec3.dot(lineVec, startToP) / vec3.dot(lineVec, lineVec);\n  if (projectedPoint) {\n    vec3.lerp(projectedPoint, lineStart, lineEnd, t);\n  }\n  if (t < 0) {\n    return { pos: lineStart as vec3, parameter: 0 };\n  }\n  if (t > 1) {\n    return { pos: lineEnd as vec3, parameter: 1 };\n  }\n  return { pos: vec3.lerp(vec3.create(), lineStart, lineEnd, t), parameter: t };\n}\n\nexport function getProfile(\n  vertices: ReadonlyVec3[],\n  tesselationParameters: readonly number[] | undefined,\n  transform: mat4 | undefined\n): ReadonlyVec2[] {\n  const profile: ReadonlyVec2[] = [];\n  let prev = transform\n    ? vec3.transformMat4(vec3.create(), vertices[0], transform)\n    : vertices[0];\n  let len = 0;\n  profile.push(\n    tesselationParameters\n      ? vec2.fromValues(tesselationParameters[0], prev[2])\n      : vec2.fromValues(len, prev[2])\n  );\n  for (let i = 1; i < vertices.length; ++i) {\n    const p = transform\n      ? vec3.transformMat4(vec3.create(), vertices[i], transform)\n      : vertices[i];\n    if (tesselationParameters) {\n      profile.push(vec2.fromValues(tesselationParameters[i], p[2]));\n    } else {\n      len += vec2.distance(\n        vec2.fromValues(prev[0], prev[1]),\n        vec2.fromValues(p[0], p[1])\n      );\n      profile.push(vec2.fromValues(len, p[2]));\n    }\n    prev = p;\n  }\n  return profile;\n}\n\nexport function reduceLineStrip(lineStrip: ReadonlyVec3[]): ReadonlyVec3[] {\n  const reducedStrip: ReadonlyVec3[] = [];\n  if (lineStrip.length > 0) {\n    let prevPoint = lineStrip[0];\n    reducedStrip.push(prevPoint);\n    for (let i = 0; i < lineStrip.length; ++i) {\n      const currentPoint = lineStrip[i];\n      if (vec3.distance(prevPoint, currentPoint) > 0.005) {\n        reducedStrip.push(currentPoint);\n      }\n      prevPoint = currentPoint;\n    }\n  }\n  return reducedStrip;\n}\n\nexport class Downloader {\n  activeDownloads = 0;\n  private abortController = new AbortController();\n  public static downloadImageFallback?: (url: string) => Promise<ImageData>;\n\n  constructor(public baseUrl?: URL) { }\n\n  abort() {\n    this.abortController.abort();\n    this.abortController = new AbortController(); // we probably want to reuse this object, so create another abort controller.\n  }\n\n  async request(\n    filename: string,\n    abortController: AbortController | undefined\n  ) {\n    const url = new URL(filename, this.baseUrl);\n    if (!url.search) url.search = this.baseUrl?.search ?? \"\";\n    const signal = (abortController ?? this.abortController).signal;\n    const response = await fetch(url.toString(), { mode: \"cors\", signal });\n    if (!response.ok) {\n      throw new Error(`HTTP Error: ${response.status}: ${response.statusText}`);\n    }\n    return response;\n  }\n\n  async downloadJson(\n    filename: string,\n    abortController?: AbortController\n  ): Promise<any> {\n    try {\n      this.activeDownloads++;\n      const response = await this.request(filename, abortController);\n      return await response.json();\n    } finally {\n      this.activeDownloads--;\n    }\n  }\n\n  async downloadArrayBuffer(\n    filename: string,\n    abortController?: AbortController\n  ): Promise<ArrayBuffer> {\n    try {\n      this.activeDownloads++;\n      const response = await this.request(filename, abortController);\n      return await response.arrayBuffer();\n    } finally {\n      this.activeDownloads--;\n    }\n  }\n\n  async downloadBlob(\n    filename: string,\n    abortController?: AbortController\n  ): Promise<Blob> {\n    try {\n      this.activeDownloads++;\n      const response = await this.request(filename, abortController);\n      return await response.blob();\n    } finally {\n      this.activeDownloads--;\n    }\n  }\n\n  async downloadImage(\n    filename: string,\n    abortController?: AbortController\n  ): Promise<ImageBitmap | ImageData> {\n    try {\n      this.activeDownloads++;\n      if (Downloader.downloadImageFallback) {\n        const url =\n          typeof filename == \"string\"\n            ? new URL(filename, this.baseUrl)\n            : filename;\n        url.search = this.baseUrl?.search ?? \"\";\n        const image = await Downloader.downloadImageFallback(url.toString());\n        if (abortController?.signal.aborted) {\n          throw { name: \"AbortError\", message: \"\" };\n        }\n        return image;\n      } else {\n        const blob = await this.downloadBlob(filename, abortController);\n        // const image = await createImageBitmap(blob, { premultiplyAlpha: \"none\", colorSpaceConversion: \"none\" });\n        const image = await createImageBitmap(blob);\n        return image;\n      }\n    } finally {\n      this.activeDownloads--;\n    }\n  }\n\n  async downloadImageFromBlob(\n    blob: Blob,\n    abortController?: AbortController\n  ): Promise<ImageBitmap | ImageData> {\n    try {\n      this.activeDownloads++;\n      if (Downloader.downloadImageFallback) {\n        const url = URL.createObjectURL(blob);\n        const image = await Downloader.downloadImageFallback(url.toString());\n        URL.revokeObjectURL(url);\n        if (abortController?.signal.aborted) {\n          throw { name: \"AbortError\", message: \"\" };\n        }\n        return image;\n      } else {\n        // const image = await createImageBitmap(blob, { premultiplyAlpha: \"none\", colorSpaceConversion: \"none\" });\n        const image = await createImageBitmap(blob);\n        return image;\n      }\n    } finally {\n      this.activeDownloads--;\n    }\n  }\n}\n", "import {\n  glMatrix,\n  mat3,\n  mat4,\n  ReadonlyVec2,\n  ReadonlyVec3,\n  vec2,\n  vec3,\n} from \"gl-matrix\";\nimport { makeNurbsCurve2D, makeNurbsCurve3D } from \"./nurbs\";\nimport { closestPointToLine, getProfile } from \"./util\";\nglMatrix.setMatrixArrayType(Array);\n\ntype CurveKind = \"line\" | \"arc\" | \"nurbs\" | \"lineStrip\";\n\n// TODO: Use 2D p-curves?\n// TODO: Triangulate (delauney) p-space?\n// or even tetrahedron tesselation of 3D face?\n\nexport interface LineSegment3D {\n  dir: vec3;\n  start: vec3;\n  end: vec3;\n}\n\nexport function lineToSegment(line: Line3D, mat: mat4): LineSegment3D {\n  const start = vec3.create();\n  const end = vec3.create();\n  const dir = vec3.create();\n  line.eval(line.beginParam, start, dir);\n  line.eval(line.endParam, end, undefined);\n  vec3.transformMat4(start, start, mat);\n  vec3.transformMat4(end, end, mat);\n\n  const normalMat = mat3.normalFromMat4(mat3.create(), mat);\n  vec3.transformMat3(dir, dir, normalMat);\n  vec3.normalize(dir, dir);\n  return { dir, start, end };\n}\n\nexport class Disposable {\n  dispose(): void {}\n}\n\nexport interface Curve3D {\n  readonly kind: CurveKind;\n  tesselationParameters: readonly number[];\n  sense: number;\n  // eval(position: vec2, t: number): void;\n  eval(t: number, point: vec3 | undefined, tangent: vec3 | undefined): void;\n  // project(pos: ReadonlyVec3): number;\n  invert(pos: ReadonlyVec3): number;\n  // signedDistance(point: ReadonlyVec2): number; // signed distance from point to curve (along x/u axis?)\n  // intersectCount(point: ReadonlyVec2): number;\n}\n\nexport interface Curve2D {\n  readonly kind: CurveKind;\n  readonly beginParam: number;\n  readonly endParam: number;\n  // eval(position: vec2, t: number): void;\n  eval(t: number, point: vec2 | undefined, tangent: vec2 | undefined): void;\n  project(pos: ReadonlyVec2): number;\n  // invert(pos: ReadonlyVec2): number;\n  // signedDistance(point: ReadonlyVec2): number; // signed distance from point to curve (along x/u axis?)\n  // intersectCount(point: ReadonlyVec2): number;\n}\n\n/*\n\nforeach curve\n  if ray intersects curve\n    count++\n\nvisible = (count % 2) == 1\n\n*/\n\nexport class LineStrip3D implements Curve3D {\n  readonly kind = \"lineStrip\";\n  readonly sense = 1;\n  constructor(\n    readonly vertices: ReadonlyVec3[],\n    readonly beginParam: number,\n    readonly endParam: number,\n    readonly tesselationParameters: readonly number[]\n  ) {}\n  eval(t: number, point: vec3 | undefined, tangent: vec3 | undefined): void {\n    const { vertices, endParam, beginParam, tesselationParameters } = this;\n    let segIndex = 0;\n    if (t >= endParam) {\n      segIndex = tesselationParameters.length - 1;\n    } else if (t <= beginParam) {\n      segIndex = 0;\n    } else {\n      while (t < endParam && segIndex < tesselationParameters.length - 1) {\n        if (t < tesselationParameters[segIndex + 1]) {\n          break;\n        }\n        ++segIndex;\n      }\n    }\n\n    const start = vertices[segIndex];\n    const dir =\n      segIndex < vertices.length - 1\n        ? vec3.subtract(vec3.create(), vertices[segIndex + 1], start)\n        : vec3.subtract(vec3.create(), vertices[segIndex - 1], start);\n    vec3.normalize(dir, dir);\n    if (point) {\n      const segStartParam = tesselationParameters[segIndex];\n      const localParam = t - segStartParam;\n      vec3.scale(point, dir, localParam);\n      vec3.add(point, point, start);\n    }\n    if (tangent) {\n      vec3.copy(tangent, dir);\n    }\n  }\n  invert(pos: ReadonlyVec3): number {\n    const { vertices, tesselationParameters } = this;\n    let smallestDist = Number.MAX_VALUE;\n    let closestParameter = 0;\n    for (let i = 0; i < vertices.length - 1; ++i) {\n      const p = closestPointToLine(pos, vertices[i], vertices[i + 1]);\n      const dist = vec3.dist(p.pos, pos);\n      if (dist < smallestDist) {\n        smallestDist = dist;\n        const segLength =\n          tesselationParameters[i + 1] - tesselationParameters[i];\n        closestParameter = tesselationParameters[i] + segLength * p.parameter;\n      }\n    }\n    return closestParameter;\n  }\n\n  toSegments(transform: mat4): LineSegment3D[] {\n    const { vertices, tesselationParameters } = this;\n    const segments: LineSegment3D[] = [];\n    for (let i = 1; i < tesselationParameters.length; ++i) {\n      const start = vec3.transformMat4(\n        vec3.create(),\n        vertices[i - 1],\n        transform\n      );\n      const end = vec3.transformMat4(vec3.create(), vertices[i], transform);\n      const dir = vec3.sub(vec3.create(), end, start);\n      vec3.normalize(dir, dir);\n      segments.push({ start, end, dir });\n    }\n    return segments;\n  }\n  toProfile(transform: mat4): ReadonlyVec2[] {\n    const { vertices, tesselationParameters } = this;\n    return getProfile(vertices, tesselationParameters, transform);\n  }\n}\n\nexport class Line3D extends Disposable implements Curve3D {\n  readonly kind = \"line\";\n\n  constructor(\n    readonly origin: ReadonlyVec3,\n    readonly direction: ReadonlyVec3,\n    readonly beginParam: number,\n    readonly endParam: number,\n    readonly sense: -1 | 1,\n    readonly tesselationParameters: readonly number[]\n  ) {\n    super();\n  }\n\n  eval(t: number, point: vec3 | undefined, tangent: vec3 | undefined) {\n    const { origin, direction, sense, beginParam, endParam } = this;\n    if (point) {\n      vec3.scale(point, direction, t);\n      vec3.add(point, point, origin);\n    }\n    if (tangent) {\n      if (sense > 0) vec3.copy(tangent, direction);\n      else vec3.negate(tangent, direction);\n    }\n  }\n  invert(pos: ReadonlyVec3) {\n    const start = vec3.create();\n    this.eval(this.beginParam, start, undefined);\n    const end = vec3.create();\n    this.eval(this.endParam, end, undefined);\n\n    const len = vec3.dist(start, end);\n    const pointToStart = vec3.create();\n    vec3.subtract(pointToStart, pos, start);\n\n    const distAlongLine = vec3.dot(this.direction, pointToStart);\n    const fraction = distAlongLine / len;\n    return this.beginParam + (this.endParam - this.beginParam) * fraction;\n  }\n}\n\nexport class Arc3D extends Disposable implements Curve3D {\n  readonly kind = \"arc\";\n  readonly tmp = vec3.create();\n\n  constructor(\n    readonly origin: ReadonlyVec3,\n    readonly axisX: ReadonlyVec3,\n    readonly axisY: ReadonlyVec3,\n    readonly radius: number,\n    readonly beginParam: number,\n    readonly endParam: number,\n    readonly sense: -1 | 1,\n    readonly tesselationParameters: readonly number[]\n  ) {\n    super();\n  }\n\n  eval(t: number, point: vec3 | undefined, tangent: vec3 | undefined) {\n    const { sense } = this;\n    const x = Math.cos(t);\n    const y = Math.sin(t);\n    if (point) {\n      const { origin, radius, axisX, axisY, tmp } = this;\n      vec3.scale(tmp, axisX, x * radius);\n      vec3.add(point, origin, tmp);\n      vec3.scale(tmp, axisY, y * radius);\n      vec3.add(point, point, tmp);\n    }\n    if (tangent) {\n      const { axisX, axisY, tmp } = this;\n      vec3.scale(tangent, axisX, x * sense);\n      vec3.scale(tmp, axisY, -y * sense);\n      vec3.add(tangent, tmp, tangent);\n    }\n  }\n\n  invert(pos: ReadonlyVec3) {\n    const a = pointAtAngle(pos, this);\n    if (a > this.endParam || a < this.beginParam) {\n      let disEnd = a - this.endParam;\n      if (disEnd < 0) {\n        disEnd += 2 * Math.PI;\n      }\n      let disStart = this.beginParam - a;\n      if (disStart < 0) {\n        disStart += 2 * Math.PI;\n      }\n      if (disEnd < disStart) {\n        return this.endParam;\n      }\n      return this.beginParam;\n    }\n    return a;\n  }\n}\n\nexport function pointAtAngle(point: ReadonlyVec3, arc3d: Arc3D) {\n  const planeNormal = vec3.cross(vec3.create(), arc3d.axisX, arc3d.axisY);\n  const p = vec3.sub(vec3.create(), point, arc3d.origin);\n  const d = vec3.dot(p, planeNormal);\n  const projectedPoint = vec3.scaleAndAdd(\n    vec3.create(),\n    point,\n    planeNormal,\n    -d\n  );\n  const dir = vec3.sub(vec3.create(), projectedPoint, arc3d.origin);\n  vec3.normalize(dir, dir);\n  const pointOnArc = vec3.scaleAndAdd(\n    vec3.create(),\n    arc3d.origin,\n    dir,\n    arc3d.radius\n  );\n  vec3.sub(pointOnArc, pointOnArc, arc3d.origin);\n  const x = vec3.dot(pointOnArc, arc3d.axisX);\n  const y = vec3.dot(pointOnArc, arc3d.axisY);\n  let a = Math.atan2(y, x);\n  if (a < 0) {\n    a += 2 * Math.PI;\n  }\n  return a;\n}\n\ntype Pointer = number;\n\nexport class NurbsCurve3D extends Disposable implements Curve3D {\n  readonly kind = \"nurbs\";\n  ptr: Pointer = 0;\n\n  constructor(\n    readonly order: number,\n    readonly controlPoints: ReadonlyVec3[],\n    readonly knots: number[],\n    readonly weights: number[] | undefined,\n    readonly beginParam: number,\n    readonly endParam: number,\n    readonly sense: -1 | 1,\n    readonly tesselationParameters: readonly number[],\n    private readonly wasmInstance: any,\n    private readonly buffer: Float64Array\n  ) {\n    super();\n  }\n\n  dispose() {\n    if (this.weights) {\n      this.wasmInstance._disposeNurbsCurve3DWithWeights(this.ptr);\n    } else {\n      this.wasmInstance._disposeNurbsCurve3D(this.ptr);\n    }\n  }\n\n  eval(t: number, point: vec3 | undefined, tangent: vec3 | undefined) {\n    if (this.ptr === 0) {\n      this.ptr = makeNurbsCurve3D(\n        this.wasmInstance,\n        this.knots,\n        this.controlPoints,\n        this.weights,\n        this.order\n      );\n    }\n    if (this.weights) {\n      this.wasmInstance._evalNurbsCurve3DWithWeights(\n        this.ptr,\n        t,\n        point ? this.buffer.byteOffset : undefined,\n        tangent ? this.buffer.byteOffset + 24 : undefined\n      );\n    } else {\n      this.wasmInstance._evalNurbsCurve3D(\n        this.ptr,\n        t,\n        point ? this.buffer.byteOffset : undefined,\n        tangent ? this.buffer.byteOffset + 24 : undefined\n      );\n    }\n    if (point != undefined) {\n      const [x, y, z] = this.buffer.subarray(0, 3);\n      vec3.set(point, x, y, z);\n    }\n    if (tangent != undefined) {\n      const [x, y, z] = this.buffer.subarray(3, 6);\n      vec3.set(tangent, x, y, z);\n    }\n  }\n\n  invert(point: ReadonlyVec3) {\n    if (this.ptr === 0) {\n      const ctrlPt2d = this.controlPoints.map((p) =>\n        vec2.fromValues(p[0] / Math.PI, p[1] / 500)\n      );\n      this.ptr = makeNurbsCurve2D(\n        this.wasmInstance,\n        this.knots,\n        ctrlPt2d,\n        this.weights,\n        this.order\n      );\n    }\n    return this.wasmInstance._invertNurbsCurve3D(\n      this.ptr,\n      point[0],\n      point[1],\n      point[2]\n    );\n  }\n}\n\nexport class Line2D extends Disposable implements Curve2D {\n  readonly kind = \"line\";\n\n  constructor(\n    readonly origin: ReadonlyVec2,\n    readonly direction: ReadonlyVec2,\n    readonly beginParam: number,\n    readonly endParam: number,\n    readonly sense: -1 | 1\n  ) {\n    super();\n  }\n\n  eval(t: number, point: vec2 | undefined, tangent: vec2 | undefined) {\n    const { origin, direction } = this;\n    if (point) {\n      vec2.scale(point, direction, t);\n      vec2.add(point, point, origin);\n    }\n    if (tangent) {\n      if (this.sense > 0) {\n        vec2.copy(tangent, direction);\n      } else {\n        vec2.negate(tangent, direction);\n      }\n    }\n  }\n\n  project(point: ReadonlyVec2): number {\n    const [x, y] = point;\n    const { origin, direction, beginParam, endParam } = this;\n    const dx = x - origin[0];\n    const dy = y - origin[1];\n    let t = dx * direction[0] + dy * direction[1]; // dot product yields projection parameter\n    // clamp to range\n    const centerParam = (beginParam + endParam) / 2;\n    const extent = Math.abs(endParam - beginParam) / 2;\n    const minParam = centerParam - extent;\n    const maxParam = centerParam + extent;\n    t = Math.max(minParam, Math.min(maxParam, t));\n    return t;\n    // // find projected point\n    // const px = origin[0] + direction[0] * t;\n    // const py = origin[1] - direction[1] * t;\n    // const pdx = x - px;\n    // const pdy = y - py;\n    // return pdy * direction[0] - pdx * direction[1]; // cross product yields signed distance from line\n  }\n\n  // intersectCount(point: ReadonlyVec2) {\n  //     const [x, y] = point;\n  //     if (x > this.minX && y >= this.minY && y < this.maxY) {\n  //         const { begin, end } = this;\n  //         const t = (y - begin[1]) / (end[1] - begin[1]);\n  //         const lx = begin[0] + this.deltaX * t;\n  //         if (x > lx) {\n  //             return 1;\n  //         }\n  //     }\n  //     return 0;\n  // }\n}\n\nexport class NurbsCurve2D extends Disposable implements Curve2D {\n  readonly kind = \"nurbs\";\n  ptr: Pointer = 0;\n\n  constructor(\n    readonly order: number,\n    readonly controlPoints: ReadonlyVec2[],\n    readonly knots: number[],\n    readonly weights: number[] | undefined,\n    readonly beginParam: number,\n    readonly endParam: number,\n    readonly sense: -1 | 1,\n    private readonly wasmInstance: any,\n    private readonly buffer: Float64Array\n  ) {\n    super();\n  }\n\n  eval(t: number, point: vec2 | undefined, tangent: vec2 | undefined) {\n    if (this.ptr === 0) {\n      const ctrlPt2d = this.controlPoints.map((p) =>\n        vec2.fromValues(p[0] / Math.PI, p[1] / 500)\n      );\n      this.ptr = makeNurbsCurve2D(\n        this.wasmInstance,\n        this.knots,\n        ctrlPt2d,\n        this.weights,\n        this.order\n      );\n    }\n    if (this.weights) {\n      this.wasmInstance._evalNurbsCurve2DWithWeights(\n        this.ptr,\n        t,\n        point ? this.buffer.byteOffset : undefined,\n        tangent ? this.buffer.byteOffset + 24 : undefined\n      );\n    } else {\n      this.wasmInstance._evalNurbsCurve2D(\n        this.ptr,\n        t,\n        point ? this.buffer.byteOffset : undefined,\n        tangent ? this.buffer.byteOffset + 24 : undefined\n      );\n    }\n    if (point != undefined) {\n      const [x, y] = this.buffer.subarray(0, 2);\n      vec2.set(point, x, y);\n    }\n    if (tangent != undefined) {\n      const [x, y] = this.buffer.subarray(3, 5);\n      vec2.set(tangent, x, y);\n    }\n  }\n\n  project(point: ReadonlyVec2): number {\n    if (this.ptr === 0) {\n      const ctrlPt2d = this.controlPoints.map((p) =>\n        vec2.fromValues(p[0] / Math.PI, p[1] / 500)\n      );\n      this.ptr = makeNurbsCurve2D(\n        this.wasmInstance,\n        this.knots,\n        ctrlPt2d,\n        this.weights,\n        this.order\n      );\n    }\n    return this.wasmInstance._projectNurbsCurve2D(this.ptr, point[0], point[1]);\n  }\n\n  dispose() {\n    if (this.weights) {\n      this.wasmInstance._disposeNurbsCurve2DWithWeights(this.ptr);\n    } else {\n      this.wasmInstance._disposeNurbsCurve2D(this.ptr);\n    }\n  }\n}\n\nconst pi2 = Math.PI * 2;\n\nexport class Arc2D implements Curve2D {\n  readonly kind = \"arc\";\n\n  constructor(\n    readonly origin: ReadonlyVec2,\n    readonly radius: number,\n    readonly beginParam: number,\n    readonly endParam: number,\n    readonly sense: 1 | -1\n  ) {}\n\n  eval(t: number, point: vec2 | undefined, tangent: vec2 | undefined) {\n    const x = Math.cos(t);\n    const y = Math.sin(t);\n    if (point) {\n      const { origin, radius } = this;\n      point[0] = x * radius + origin[0];\n      point[1] = y * radius + origin[1];\n    }\n    if (tangent) {\n      const { sense } = this;\n      tangent[0] = -y * sense;\n      tangent[1] = x * sense;\n    }\n  }\n\n  project(point: ReadonlyVec2): number {\n    const [x, y] = point;\n    const { origin, beginParam, endParam } = this;\n    let t = Math.atan2(y - origin[1], x - origin[0]);\n    if (t < 0) t += pi2;\n    // clamp to range\n    const centerParam = (beginParam + endParam) / 2;\n    const extent = Math.abs(endParam - beginParam) / 2;\n    const minParam = centerParam - extent;\n    const maxParam = centerParam + extent;\n    while (t < centerParam - Math.PI) t += pi2;\n    while (t > centerParam + Math.PI) t -= pi2;\n    t = Math.max(minParam, Math.min(maxParam, t));\n\n    return t;\n  }\n\n  // isVectorInParamRange(x: number, y: number) {\n  //     return x * this.rangeVec[0] + y * this.rangeVec[1] >= this.rangeCos;\n  // }\n\n  // intersectCount(point: ReadonlyVec2) {\n  //     const [x, y] = point;\n  //     const { origin, radius } = this;\n  //     let cnt = 0;\n  //     if (y >= this.minY && y < this.maxY) {\n  //         const uy = Math.min(1, (y - origin[1]) / radius);\n  //         const ux = Math.sqrt(1 - uy * uy);\n  //         // is point right of origin?\n  //         if (x > origin[0]) {\n  //             if (this.isVectorInParamRange(ux, uy) && x > ux) {\n  //                 cnt++;\n  //             }\n  //         }\n  //         if (x > origin[0] - radius) {\n  //             if (this.isVectorInParamRange(-ux, uy) && x > -ux) {\n  //                 cnt++;\n  //             }\n  //         }\n\n  //     }\n  //     return cnt;\n  // }\n}\n", "import {\n  glMatrix,\n  mat3,\n  mat4,\n  ReadonlyMat4,\n  ReadonlyVec3,\n  vec2,\n  vec3,\n} from \"gl-matrix\";\nimport type {\n  AABB3,\n  CylinderData,\n  EdgeData,\n  FaceData,\n  ProductData,\n} from \"./brep\";\nimport {\n  Arc3D,\n  Curve3D,\n  Line3D,\n  LineSegment3D,\n  LineStrip3D,\n  lineToSegment,\n  pointAtAngle,\n} from \"./curves\";\nimport { geometryFactory, matFromInstance } from \"./loader\";\nimport type { Plane } from \"./surfaces\";\nimport { closestPointToLine } from \"./util\";\nimport { unitToScale } from \"./loader\";\nimport type {\n  CylinerMeasureType,\n  DuoMeasurementValues,\n  MeasureSettings,\n} from \"@novorender/measure-api\";\n\nglMatrix.setMatrixArrayType(Array);\n\nconst epsilon = 0.0001;\n\nexport function isInsideAABB(point: vec3, aabb: AABB3, epsilon = 0): boolean {\n  for (let i = 0; i < 3; ++i) {\n    if (\n      point[i] - aabb.min[i] + epsilon < 0 ||\n      aabb.max[i] - point[i] + epsilon < 0\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function cylinderLength(\n  product: ProductData,\n  cylinderFace: FaceData,\n  origo: vec3,\n  dir: vec3\n): number {\n  const loopData = product.loops[cylinderFace.outerLoop];\n  //const halfEdges = loopData.halfEdges.map((i) => product.halfEdges[i]);\n  // //First try with seam\n  // for (const halfEdge of halfEdges) {\n  //     const edge = product.edges[halfEdge.edge];\n  //     if (edge.virtual) {\n  //         return (edge.parameterBounds[1] - edge.parameterBounds[0]) * halfEdge.direction;\n  //     }\n  // }\n  const circleOrigins: ReadonlyVec3[] = [];\n  for (const halfEdge of loopData.halfEdges) {\n    const halfEdgeData = product.halfEdges[halfEdge];\n    const edgeData = product.edges[halfEdgeData.edge];\n    if (edgeData.curve3D !== undefined) {\n      const curveData = product.curves3D[edgeData.curve3D];\n      if (curveData.kind == \"circle\") {\n        circleOrigins.push(curveData.origin);\n      }\n    }\n  }\n  if (circleOrigins.length == 2) {\n    let sense = 1;\n    const other = vec3.equals(circleOrigins[0], origo)\n      ? circleOrigins[1]\n      : circleOrigins[0];\n    if (vec3.dot(dir, vec3.sub(vec3.create(), other, origo)) < 0) {\n      sense = -1;\n    }\n    return sense * vec3.dist(circleOrigins[0], circleOrigins[1]);\n  }\n  return 0;\n}\n\nfunction fullCircle(edge: EdgeData): boolean {\n  const paramLength = Math.abs(\n    edge.parameterBounds[1] - edge.parameterBounds[0]\n  );\n  return Math.abs(paramLength - 2 * Math.PI) < epsilon;\n}\n\nexport function fullCircleCylinder(\n  product: ProductData,\n  cylinderFace: FaceData\n): boolean {\n  const loopData = product.loops[cylinderFace.outerLoop];\n  const halfEdges = loopData.halfEdges.map((i) => product.halfEdges[i]);\n  let noArcs = 0;\n  for (const halfEdge of halfEdges) {\n    const edge = product.edges[halfEdge.edge];\n    if (edge.curve3D !== undefined) {\n      const curve = product.curves3D[edge.curve3D];\n      if (curve.kind == \"circle\") {\n        noArcs++;\n        if (!fullCircle(edge)) {\n          return false;\n        }\n      }\n    }\n  }\n  return noArcs == 2;\n}\n\nexport async function cylinderCenterLine(\n  product: ProductData,\n  cylinderFace: FaceData,\n  cylinderData: CylinderData,\n  instanceMat: ReadonlyMat4,\n  measureType?: CylinerMeasureType\n): Promise<[vec3, vec3]> {\n  const scale = unitToScale(product.units);\n  const cylinderMtx = mat4.fromValues(\n    ...(cylinderData.transform as Parameters<typeof mat4.fromValues>)\n  );\n  const cylinderOrigo = mat4.getTranslation(vec3.create(), cylinderMtx);\n  const cylinderDir = vec3.fromValues(\n    cylinderMtx[8],\n    cylinderMtx[9],\n    cylinderMtx[10]\n  );\n  const cyliderLen = cylinderLength(\n    product,\n    cylinderFace,\n    cylinderOrigo,\n    cylinderDir\n  );\n  const cylinderEnd = vec3.add(\n    vec3.create(),\n    cylinderOrigo,\n    vec3.scale(vec3.create(), cylinderDir, cyliderLen)\n  );\n  vec3.transformMat4(cylinderOrigo, cylinderOrigo, instanceMat);\n  vec3.transformMat4(cylinderEnd, cylinderEnd, instanceMat);\n\n  if (measureType == \"bottom\" || measureType == \"top\") {\n    //top or bottom\n    const dir = vec3.sub(vec3.create(), cylinderEnd, cylinderOrigo);\n    vec3.normalize(dir, dir);\n    const up = glMatrix.equals(\n      Math.abs(vec3.dot(vec3.fromValues(0, 0, 1), dir)),\n      1\n    )\n      ? vec3.fromValues(0, 1, 0)\n      : vec3.fromValues(0, 0, 1);\n\n    const right = vec3.cross(vec3.create(), up, dir);\n    vec3.cross(up, dir, right);\n    vec3.normalize(up, up);\n    if (measureType == \"top\") {\n      vec3.scaleAndAdd(cylinderOrigo, cylinderOrigo, up, cylinderData.radius * scale);\n      vec3.scaleAndAdd(cylinderEnd, cylinderEnd, up, cylinderData.radius * scale);\n    } else {\n      vec3.scaleAndAdd(cylinderOrigo, cylinderOrigo, up, -cylinderData.radius * scale);\n      vec3.scaleAndAdd(cylinderEnd, cylinderEnd, up, -cylinderData.radius * scale);\n    }\n  }\n\n  return [cylinderOrigo, cylinderEnd];\n}\n\nexport function closestPointsToIntersection(\n  startA: ReadonlyVec3,\n  endA: ReadonlyVec3,\n  startB: ReadonlyVec3,\n  endB: ReadonlyVec3\n): vec3 {\n  const dirA = vec3.sub(vec3.create(), endA, startA);\n  const lenA = vec3.len(dirA);\n  vec3.normalize(dirA, dirA);\n  const dirB = vec3.sub(vec3.create(), endB, startB);\n  vec3.normalize(dirB, dirB);\n  const dp = vec3.dot(dirA, dirB);\n  const cp = vec3.len(vec3.cross(vec3.create(), dirA, dirB));\n\n  function intersectionPoint(\n    a: ReadonlyVec3,\n    da: ReadonlyVec3,\n    p: ReadonlyVec3,\n    l: number\n  ): vec3 {\n    const ab = vec3.sub(vec3.create(), p, a);\n    const ta = vec3.dot(ab, da);\n    const pa = vec3.scaleAndAdd(vec3.create(), a, da, ta);\n    const d = vec3.dist(pa, p);\n    const tb = (d * dp) / cp;\n    const t = Math.min(l, Math.max(ta + tb, 0));\n    return vec3.scaleAndAdd(vec3.create(), a, da, t);\n  }\n\n  return intersectionPoint(startA, dirA, startB, lenA);\n}\n\nexport function closestProjectedPoints(\n  startA: ReadonlyVec3,\n  endA: ReadonlyVec3,\n  startB: ReadonlyVec3,\n  endB: ReadonlyVec3\n): [number, vec3, vec3] {\n  let pointA = vec3.create();\n  let pointB = vec3.create();\n\n  const { pos: p1 } = closestPointToLine(startB, startA, endA);\n  const { pos: p2 } = closestPointToLine(endB, startA, endA);\n  const { pos: p3 } = closestPointToLine(startA, startB, endB);\n  const { pos: p4 } = closestPointToLine(endA, startB, endB);\n\n  const d1 = vec3.length(vec3.sub(vec3.create(), startB, p1));\n  const d2 = vec3.length(vec3.sub(vec3.create(), p2, endB));\n  const d3 = vec3.length(vec3.sub(vec3.create(), startA, p3));\n  const d4 = vec3.length(vec3.sub(vec3.create(), p4, endA));\n\n  let pointChosen: \"a\" | \"b\" = \"a\";\n  let distance = 0;\n  if (d1 < d2 && d1 < d3 && d1 < d4) {\n    distance = d1;\n    pointA = p1;\n    pointB = startB as vec3;\n  } else if (d2 < d3 && d2 < d4) {\n    distance = d2;\n    pointA = p2;\n    pointB = endB as vec3;\n  } else if (d3 < d4) {\n    distance = d3;\n    pointA = startA as vec3;\n    pointB = p3;\n    pointChosen = \"b\"\n  } else {\n    distance = d3;\n    pointA = endA as vec3;\n    pointB = p4;\n    pointChosen = \"b\"\n  }\n  if (pointChosen == \"a\") {\n    const { pos: p5 } = closestPointToLine(pointA, startB, endB);\n    const testDist = vec3.dist(p5, pointA);\n    if (testDist < distance) {\n      pointB = p5;\n      distance = testDist;\n    }\n  } else {\n    const { pos: p5 } = closestPointToLine(pointB, startA, endA);\n    const testDist = vec3.dist(p5, pointB);\n    if (testDist < distance) {\n      pointA = p5;\n      distance = testDist;\n    }\n  }\n\n  return [distance, pointA, pointB];\n}\n\nexport function decomposePlane(\n  product: ProductData,\n  faceData: FaceData,\n  instanceIdx: number,\n  plane: Plane,\n  centerPoint = false\n): [vec3, vec3] {\n  const mat = matFromInstance(product.instances[instanceIdx]);\n  const normalMat = mat3.normalFromMat4(mat3.create(), mat);\n\n  const uv = vec2.fromValues(0, 0);\n  const planePoint = vec3.create();\n  const planeNorm = vec3.create();\n  if (centerPoint) {\n    vec3.add(planePoint, faceData.aabb.max, faceData.aabb.min);\n    vec3.scale(planePoint, planePoint, 0.5);\n  } else {\n    plane.evalPosition(planePoint, uv);\n  }\n  plane.evalNormal(planeNorm, uv);\n  vec3.transformMat4(planePoint, planePoint, mat);\n  vec3.transformMat3(planeNorm, planeNorm, normalMat);\n  vec3.normalize(planeNorm, planeNorm);\n  return [planePoint, planeNorm];\n}\n\nfunction lineToLineMeasure(segA: LineSegment3D, segB: LineSegment3D): DuoMeasurementValues {\n  const parallel =\n    vec3.equals(segA.dir, segB.dir) ||\n    vec3.equals(segA.dir, vec3.negate(segB.dir, segB.dir));\n\n  let [distance, pointA, pointB] = closestProjectedPoints(\n    segA.start,\n    segA.end,\n    segB.start,\n    segB.end\n  );\n  const diff = vec3.sub(vec3.create(), pointA, pointB);\n  if (!parallel) {\n    const crossPoint = closestPointsToIntersection(\n      segA.start,\n      segA.end,\n      segB.start,\n      segB.end\n    );\n    const { pos: crossPointA } = closestPointToLine(\n      crossPoint,\n      segA.start,\n      segA.end\n    );\n    const { pos: crossPointB } = closestPointToLine(\n      crossPoint,\n      segB.start,\n      segB.end\n    );\n    if (distance > vec3.dist(crossPointA, crossPointB)) {\n      pointA = crossPointA;\n      pointB = crossPointB;\n      vec3.sub(diff, crossPointB, crossPointA);\n    }\n  }\n\n  return {\n    drawKind: \"measureResult\",\n    distance: vec3.len(diff),\n    distanceX: Math.abs(diff[0]),\n    distanceY: Math.abs(diff[1]),\n    distanceZ: Math.abs(diff[2]),\n    measureInfoA: { point: pointA },\n    measureInfoB: { point: pointB }\n  };\n}\n\nfunction toMeasureValues(pointA: vec3, pointB: vec3, parameterA?: number, parameterB?: number): DuoMeasurementValues {\n  const diff = vec3.subtract(vec3.create(), pointA, pointB);\n  return {\n    drawKind: \"measureResult\",\n    distance: vec3.len(diff),\n    distanceX: Math.abs(diff[0]),\n    distanceY: Math.abs(diff[1]),\n    distanceZ: Math.abs(diff[2]),\n    measureInfoA: { point: pointA, parameter: parameterA },\n    measureInfoB: { point: pointB, parameter: parameterB }\n  };\n}\n\nfunction segmentToArcMeasure(\n  arc: Arc3D,\n  arcMat: ReadonlyMat4,\n  seg: LineSegment3D\n): DuoMeasurementValues {\n  const wsOrigin = vec3.transformMat4(vec3.create(), arc.origin, arcMat);\n  const { pos: point } = closestPointToLine(wsOrigin, seg.start, seg.end);\n  const arcInvMat = mat4.invert(mat4.create(), arcMat);\n  const pointInArcSpace = vec3.transformMat4(vec3.create(), point, arcInvMat);\n\n  const t = pointAtAngle(pointInArcSpace, arc);\n  const pointA = vec3.create();\n  const pointB = vec3.create();\n  if (t <= arc.endParam && t >= arc.beginParam) {\n    arc.eval(t, pointA, undefined);\n    vec3.transformMat4(pointA, pointA, arcMat);\n    vec3.copy(pointB, point);\n  } else {\n    const arcPointA = vec3.create();\n    arc.eval(arc.beginParam, arcPointA, undefined);\n    vec3.transformMat4(arcPointA, arcPointA, arcMat);\n    const arcPointB = vec3.create();\n    arc.eval(arc.endParam, arcPointB, undefined);\n    vec3.transformMat4(arcPointB, arcPointB, arcMat);\n    const { pos: linePointA } = closestPointToLine(\n      arcPointA,\n      seg.start,\n      seg.end\n    );\n    const { pos: linePointB } = closestPointToLine(\n      arcPointB,\n      seg.start,\n      seg.end\n    );\n\n    const da = vec3.dist(linePointA, arcPointA);\n    const db = vec3.dist(linePointB, arcPointB);\n    if (da < db) {\n      vec3.copy(pointA, arcPointA);\n      vec3.copy(pointB, linePointA);\n    } else {\n      vec3.copy(pointA, arcPointB);\n      vec3.copy(pointB, linePointB);\n    }\n  }\n  return toMeasureValues(pointA, pointB);\n}\n\nfunction closestPointToArc(point: ReadonlyVec3, arc: Arc3D, mat: ReadonlyMat4) {\n  const invMat = mat4.invert(mat4.create(), mat);\n  const localSpaceP = vec3.transformMat4(vec3.create(), point, invMat);\n  const t = arc.invert(localSpaceP);\n  const pointOnCircle = vec3.create();\n  arc.eval(t, pointOnCircle, undefined);\n  vec3.transformMat4(pointOnCircle, pointOnCircle, mat);\n  return pointOnCircle;\n}\n\nfunction getCurveToCurveMeasureValues(\n  productA: ProductData,\n  curveA: Curve3D,\n  instanceIdxA: number,\n  productB: ProductData,\n  curveB: Curve3D,\n  instanceIdxB: number\n): DuoMeasurementValues | undefined {\n  let curveDataA = { prouct: productA, curve: curveA, instance: instanceIdxA };\n  let curveDataB = { prouct: productB, curve: curveB, instance: instanceIdxB };\n  const entities = [curveDataA, curveDataB];\n  entities.sort((a, b) => a.curve!.kind.localeCompare(b.curve!.kind));\n  [curveDataA, curveDataB] = entities;\n  const kindCombo = `${curveDataA.curve!.kind}_${curveDataB.curve!.kind}`;\n  const matA = matFromInstance(\n    curveDataA.prouct.instances[curveDataA.instance]\n  );\n  const matB = matFromInstance(\n    curveDataB.prouct.instances[curveDataB.instance]\n  );\n  switch (kindCombo) {\n    case \"line_line\": {\n      const values = lineToLineMeasure(\n        lineToSegment(curveDataA.curve as Line3D, matA),\n        lineToSegment(curveDataB.curve as Line3D, matB)\n      );\n      return values;\n    }\n    case \"arc_arc\": {\n      const arcA = curveDataA.curve as Arc3D;\n      const arcB = curveDataB.curve as Arc3D;\n      const wsOriginA = vec3.transformMat4(vec3.create(), arcA.origin, matA);\n      const wsOriginB = vec3.transformMat4(vec3.create(), arcB.origin, matB);\n      const closestPointA = closestPointToArc(wsOriginA, arcB, matB);\n      const closestPointB = closestPointToArc(wsOriginB, arcA, matA);\n      return toMeasureValues(closestPointA, closestPointB);\n    }\n    case \"arc_line\": {\n      const arc = curveDataA.curve as Arc3D;\n      const line = curveDataB.curve as Line3D;\n      return segmentToArcMeasure(arc, matA, lineToSegment(line, matA));\n    }\n    case \"arc_lineStrip\": {\n      const arc = curveDataA.curve as Arc3D;\n      const strip = curveDataB.curve as LineStrip3D;\n      const segments = strip.toSegments(matB);\n      let minDist = 1000000;\n      let bestMeasureValues: undefined | DuoMeasurementValues = undefined;\n      for (const seg of segments) {\n        const measureValue = segmentToArcMeasure(arc, matA, seg);\n        if (measureValue.distance && measureValue.distance < minDist) {\n          bestMeasureValues = measureValue;\n          minDist = measureValue.distance;\n        }\n      }\n      return bestMeasureValues;\n    }\n    case \"line_lineStrip\": {\n      const segmentA = lineToSegment(curveDataA.curve as Line3D, matA);\n      const strip = curveDataB.curve as LineStrip3D;\n      const segments = strip.toSegments(matB);\n      let minDist = 1000000;\n      let bestMeasureValues: undefined | DuoMeasurementValues = undefined;\n      for (const seg of segments) {\n        const measureValue = lineToLineMeasure(segmentA, seg);\n        if (measureValue.distance && measureValue.distance < minDist) {\n          bestMeasureValues = measureValue;\n          minDist = measureValue.distance;\n        }\n      }\n      if (\n        bestMeasureValues &&\n        bestMeasureValues.measureInfoA?.point &&\n        bestMeasureValues.measureInfoB?.point\n      ) {\n        const tb = strip.invert(bestMeasureValues.measureInfoB.point);\n        return { ...bestMeasureValues, measureInfoB: { point: bestMeasureValues.measureInfoB.point, parameter: tb } };\n      }\n    }\n    case \"lineStrip_lineStrip\": {\n      const stripA = curveDataA.curve as LineStrip3D;\n      const segmentsA = stripA.toSegments(matA);\n\n      const stripB = curveDataB.curve as LineStrip3D;\n      const segmentsB = stripB.toSegments(matB);\n      let minDist = 1000000;\n      let bestMeasureValues: undefined | DuoMeasurementValues = undefined;\n      for (const segA of segmentsA) {\n        for (const segB of segmentsB) {\n          const measureValue = lineToLineMeasure(segA, segB);\n          if (measureValue.distance && measureValue.distance < minDist) {\n            bestMeasureValues = measureValue;\n            minDist = measureValue.distance;\n          }\n        }\n      }\n      if (\n        bestMeasureValues &&\n        bestMeasureValues.measureInfoA?.point &&\n        bestMeasureValues.measureInfoB?.point\n      ) {\n        const ta = stripA.invert(bestMeasureValues.measureInfoA.point);\n        const tb = stripB.invert(bestMeasureValues.measureInfoB.point);\n        return { ...bestMeasureValues, measureInfoA: { point: bestMeasureValues.measureInfoA.point, parameter: ta }, measureInfoB: { point: bestMeasureValues.measureInfoB.point, parameter: tb } };\n      }\n      return bestMeasureValues;\n    }\n  }\n}\n\nexport async function getEdgeToEdgeMeasureValues(\n  productA: ProductData,\n  edgeIdxA: number,\n  instanceIdxA: number,\n  productB: ProductData,\n  edgeIdxB: number,\n  instanceIdxB: number\n): Promise<DuoMeasurementValues | undefined> {\n  let edgeCurveA = (await geometryFactory).getCurve3DFromEdge(\n    productA,\n    edgeIdxA\n  );\n  let edgeCurveB = (await geometryFactory).getCurve3DFromEdge(\n    productB,\n    edgeIdxB\n  );\n  if (edgeCurveA && edgeCurveB) {\n    return getCurveToCurveMeasureValues(\n      productA,\n      edgeCurveA,\n      instanceIdxA,\n      productB,\n      edgeCurveB,\n      instanceIdxB\n    );\n  }\n}\n\nexport async function faceToPointMeasureValues(\n  product: ProductData,\n  faceIdx: number,\n  instanceIdx: number,\n  point: vec3,\n  scale: number,\n  setting?: MeasureSettings\n): Promise<DuoMeasurementValues | undefined> {\n  const faceData = product.faces[faceIdx];\n  const surfaceData = product.surfaces[faceData.surface];\n  const surface = (await geometryFactory).getSurface(surfaceData, 1);\n  if (surface) {\n    const mat = matFromInstance(product.instances[instanceIdx]);\n\n    switch (surface.kind) {\n      case \"plane\": {\n        const [pointPlane, norm] = decomposePlane(\n          product,\n          faceData,\n          instanceIdx,\n          surface as Plane,\n          false\n        );\n\n        const d = vec3.dot(\n          norm,\n          vec3.subtract(vec3.create(), point, pointPlane)\n        );\n        const normalPoint = vec3.add(\n          vec3.create(),\n          point,\n          vec3.scale(vec3.create(), vec3.negate(vec3.create(), norm), d)\n        );\n\n        return {\n          drawKind: \"measureResult\",\n          normalDistance: Math.abs(d),\n          distanceX: 0,\n          distanceY: 0,\n          distanceZ: 0,\n          normalPoints: [point, normalPoint],\n        };\n      }\n      case \"cylinder\": {\n        const cylinderMeasure = setting ? setting.cylinderMeasure : \"center\";\n        const cylinder = surfaceData as CylinderData;\n        const [cylinderOrigo, cylinderEnd] = await cylinderCenterLine(\n          product,\n          faceData,\n          cylinder,\n          mat,\n          cylinderMeasure\n        );\n\n        const projectedPoint = vec3.create();\n        const { pos: p1 } = closestPointToLine(\n          point,\n          cylinderOrigo,\n          cylinderEnd,\n          projectedPoint\n        );\n        const diff = vec3.sub(vec3.create(), point, p1);\n        const canUseCylinderSettings =\n          vec3.equals(projectedPoint, p1) &&\n          fullCircleCylinder(product, faceData);\n\n        if (\n          (cylinderMeasure == \"closest\" || cylinderMeasure == \"furthest\") &&\n          canUseCylinderSettings\n        ) {\n          vec3.normalize(diff, diff);\n          vec3.scale(diff, diff, cylinder.radius * scale);\n          if (cylinderMeasure == \"closest\") {\n            vec3.add(p1, p1, diff);\n          } else {\n            vec3.sub(p1, p1, diff);\n          }\n          vec3.sub(diff, point, p1);\n        }\n\n        return {\n          drawKind: \"measureResult\",\n          distance: vec3.length(diff),\n          distanceX: Math.abs(diff[0]),\n          distanceY: Math.abs(diff[1]),\n          distanceZ: Math.abs(diff[2]),\n          measureInfoA: { point, validMeasureSettings: canUseCylinderSettings },\n          measureInfoB: { point: p1, validMeasureSettings: canUseCylinderSettings }\n        };\n      }\n    }\n  }\n}\n\nfunction curveToPointMeasureValues(\n  product: ProductData,\n  curve: Curve3D,\n  instanceIdx: number,\n  point: vec3\n): DuoMeasurementValues | undefined {\n  const mat = matFromInstance(product.instances[instanceIdx]);\n  if (curve.kind == \"line\") {\n    const line = curve as Line3D;\n    const start = vec3.create();\n    const end = vec3.create();\n    const dir = vec3.create();\n    curve.eval(line.beginParam, start, dir);\n    curve.eval(line.endParam, end, undefined);\n    vec3.transformMat4(start, start, mat);\n    vec3.transformMat4(end, end, mat);\n    const projectedPoint = vec3.create();\n    const { pos: closestPointOnLine } = closestPointToLine(\n      point,\n      start,\n      end,\n      projectedPoint\n    );\n    return toMeasureValues(point, closestPointOnLine);\n  } else if (curve.kind == \"arc\") {\n    const closestPoint = closestPointToArc(point, curve as Arc3D, mat);\n    return toMeasureValues(point, closestPoint);\n  } else if (curve.kind == \"lineStrip\") {\n    const invMat = mat4.invert(mat4.create(), mat);\n    const localSpaceP = vec3.transformMat4(vec3.create(), point, invMat);\n    const t = curve.invert(localSpaceP);\n    const closestPoint = vec3.create();\n    curve.eval(t, closestPoint, undefined);\n    vec3.transformMat4(closestPoint, closestPoint, mat);\n    return toMeasureValues(point, closestPoint, undefined, t);\n  }\n}\n\nexport async function edgeToPointMeasureValues(\n  product: ProductData,\n  edgeIdx: number,\n  instanceIdx: number,\n  point: vec3\n): Promise<DuoMeasurementValues | undefined> {\n  const curve = (await geometryFactory).getCurve3DFromEdge(product, edgeIdx);\n  if (curve) {\n    return curveToPointMeasureValues(product, curve, instanceIdx, point);\n  }\n}\n\nexport async function segmentToPointMeasureValues(\n  product: ProductData,\n  segIdx: number,\n  instanceIdx: number,\n  point: vec3\n): Promise<DuoMeasurementValues | undefined> {\n  const curve = (await geometryFactory).getCurve3DFromSegment(product, segIdx);\n  if (curve) {\n    return curveToPointMeasureValues(product, curve, instanceIdx, point);\n  }\n}\n\nfunction lineToPlaneMeasure(\n  lineSegment: LineSegment3D,\n  plane: Plane,\n  planeProduct: ProductData,\n  planeFacedata: FaceData,\n  faceInstance: number\n): DuoMeasurementValues | undefined {\n  const [planePoint, planeNorm] = decomposePlane(\n    planeProduct,\n    planeFacedata,\n    faceInstance,\n    plane\n  );\n  const lineLength = vec3.dist(lineSegment.start, lineSegment.end);\n  const linePoint = vec3.scaleAndAdd(\n    vec3.create(),\n    lineSegment.start,\n    lineSegment.dir,\n    lineLength\n  );\n  const parallel = Math.abs(vec3.dot(lineSegment.dir, planeNorm)) < 0.001;\n  if (parallel) {\n    const d1 = vec3.dot(planeNorm, planePoint);\n    const d2 = vec3.dot(planeNorm, linePoint);\n    const d = d1 - d2;\n    const normalPointFromLine = vec3.add(\n      vec3.create(),\n      linePoint,\n      vec3.scale(vec3.create(), planeNorm, d)\n    );\n\n    return {\n      drawKind: \"measureResult\",\n      distance: Math.abs(d),\n      distanceX: 0,\n      distanceY: 0,\n      distanceZ: 0,\n      normalPoints: [normalPointFromLine, linePoint]\n    };\n  }\n}\n\nasync function lineToCylinderMeasure(\n  seg: LineSegment3D,\n  cylinder: CylinderData,\n  cylinderProduct: ProductData,\n  cylinderFaceData: FaceData,\n  cylinderMat: mat4,\n  cylinderScale: number,\n  cylinderMeasure: CylinerMeasureType\n): Promise<DuoMeasurementValues> {\n  const [cylinderOrigo, cylinderEnd] = await cylinderCenterLine(\n    cylinderProduct,\n    cylinderFaceData,\n    cylinder,\n    cylinderMat,\n    cylinderMeasure\n  );\n  const cylinderDir = vec3.sub(vec3.create(), cylinderEnd, cylinderOrigo);\n  vec3.normalize(cylinderDir, cylinderDir);\n  const parallel =\n    vec3.equals(cylinderDir, seg.dir) ||\n    vec3.equals(cylinderDir, vec3.negate(vec3.create(), seg.dir));\n\n  const [distance, pointA, pointB] = closestProjectedPoints(\n    cylinderOrigo,\n    cylinderEnd,\n    seg.start,\n    seg.end\n  );\n  if (!parallel) {\n    const crossPoint = closestPointsToIntersection(\n      cylinderOrigo,\n      cylinderEnd,\n      seg.start,\n      seg.end\n    );\n    const { pos: crossPointA } = closestPointToLine(\n      crossPoint,\n      cylinderOrigo,\n      cylinderEnd\n    );\n    const { pos: crossPointB } = closestPointToLine(\n      crossPoint,\n      seg.start,\n      seg.end\n    );\n    if (distance > vec3.dist(crossPointA, crossPointB)) {\n      vec3.copy(pointA, crossPointA);\n      vec3.copy(pointB, crossPointB);\n    }\n  }\n  const diff = vec3.sub(vec3.create(), pointB, pointA);\n\n  const canUseCylinderSettings =\n    parallel && fullCircleCylinder(cylinderProduct, cylinderFaceData);\n\n  if (\n    (cylinderMeasure == \"closest\" || cylinderMeasure == \"furthest\") &&\n    canUseCylinderSettings\n  ) {\n    vec3.normalize(diff, diff);\n    vec3.scale(diff, diff, cylinder.radius * cylinderScale);\n    if (cylinderMeasure == \"closest\") {\n      vec3.add(pointA, pointA, diff);\n    } else {\n      vec3.sub(pointA, pointA, diff);\n    }\n    vec3.sub(diff, pointB, pointA);\n  }\n  return {\n    drawKind: \"measureResult\",\n    distance: vec3.length(diff),\n    distanceX: Math.abs(diff[0]),\n    distanceY: Math.abs(diff[1]),\n    distanceZ: Math.abs(diff[2]),\n    measureInfoA: { point: pointA, validMeasureSettings: canUseCylinderSettings },\n    measureInfoB: { point: pointB, validMeasureSettings: canUseCylinderSettings }\n  };\n}\n\nasync function getCurveToSurfaceMeasureValues(\n  curve: Curve3D,\n  productA: ProductData,\n  curveInstanceIdx: number,\n  productB: ProductData,\n  faceIdx: number,\n  faceInstanceIdx: number,\n  setting?: MeasureSettings\n) {\n  const faceData = productB.faces[faceIdx];\n  const surfaceData = productB.surfaces[faceData.surface];\n  const surface = (await geometryFactory).getSurface(surfaceData, 1);\n  if (surface) {\n    const kindCombo = `${curve.kind}_${surface.kind}`;\n    switch (kindCombo) {\n      case \"line_plane\": {\n        const line = curve as Line3D;\n        const lineMat = matFromInstance(productA.instances[curveInstanceIdx]);\n        const plane = surface as Plane;\n        return lineToPlaneMeasure(\n          lineToSegment(line, lineMat),\n          plane,\n          productB,\n          faceData,\n          faceInstanceIdx\n        );\n      }\n      case \"lineStrip_plane\": {\n        const stripMat = matFromInstance(productA.instances[curveInstanceIdx]);\n        const strip = curve as LineStrip3D;\n        const segments = strip.toSegments(stripMat);\n        let minDist = 1000000;\n        let bestMeasureValues: undefined | DuoMeasurementValues = undefined;\n        const plane = surface as Plane;\n        for (const seg of segments) {\n          const measureValue = lineToPlaneMeasure(\n            seg,\n            plane,\n            productB,\n            faceData,\n            faceInstanceIdx\n          );\n          if (measureValue && measureValue.distance && measureValue.distance < minDist) {\n            bestMeasureValues = measureValue;\n            minDist = measureValue.distance;\n          }\n        }\n        return bestMeasureValues;\n      }\n      case \"line_cylinder\": {\n        const line = curve as Line3D;\n        const lineMat = matFromInstance(productA.instances[curveInstanceIdx]);\n\n        const cylinder = surfaceData as CylinderData;\n        const cylinderMat = matFromInstance(\n          productB.instances[faceInstanceIdx]\n        );\n        return await lineToCylinderMeasure(\n          lineToSegment(line, lineMat),\n          cylinder,\n          productB,\n          faceData,\n          cylinderMat,\n          unitToScale(productB.units),\n          setting ? setting.cylinderMeasure : \"center\"\n        );\n      }\n      case \"lineStrip_cylinder\": {\n        const stripMat = matFromInstance(productA.instances[curveInstanceIdx]);\n        const cylinderMat = matFromInstance(\n          productB.instances[faceInstanceIdx]\n        );\n        const strip = curve as LineStrip3D;\n        const segments = strip.toSegments(stripMat);\n        let minDist = 1000000;\n        let bestMeasureValues: undefined | DuoMeasurementValues = undefined;\n        for (const seg of segments) {\n          const measureValue = await lineToCylinderMeasure(\n            seg,\n            surfaceData as CylinderData,\n            productB,\n            faceData,\n            cylinderMat,\n            unitToScale(productB.units),\n            setting ? setting.cylinderMeasure : \"center\"\n          );\n          if (measureValue.distance && measureValue.distance < minDist) {\n            bestMeasureValues = measureValue;\n            minDist = measureValue.distance;\n          }\n        }\n        return bestMeasureValues;\n      }\n    }\n  }\n}\n\nexport async function getEdgeToFaceMeasureValues(\n  productA: ProductData,\n  edgeIdx: number,\n  edgeInstanceIdx: number,\n  productB: ProductData,\n  faceIdx: number,\n  faceInstanceIdx: number,\n  setting?: MeasureSettings\n): Promise<DuoMeasurementValues | undefined> {\n  const edgeCurve = (await geometryFactory).getCurve3DFromEdge(\n    productA,\n    edgeIdx\n  );\n  if (edgeCurve) {\n    return getCurveToSurfaceMeasureValues(\n      edgeCurve,\n      productA,\n      edgeInstanceIdx,\n      productB,\n      faceIdx,\n      faceInstanceIdx,\n      setting\n    );\n  }\n}\n\nexport async function getSegmentToFaceMeasureValues(\n  productA: ProductData,\n  segIdx: number,\n  segInstanceIdx: number,\n  productB: ProductData,\n  faceIdx: number,\n  faceInstanceIdx: number,\n  setting?: MeasureSettings\n): Promise<DuoMeasurementValues | undefined> {\n  const segCurve = (await geometryFactory).getCurve3DFromSegment(\n    productA,\n    segIdx\n  );\n  if (segCurve) {\n    return getCurveToSurfaceMeasureValues(\n      segCurve,\n      productA,\n      segInstanceIdx,\n      productB,\n      faceIdx,\n      faceInstanceIdx,\n      setting\n    );\n  }\n}\n\nfunction planeToPlaneMeasure(\n  productA: ProductData,\n  faceDataA: FaceData,\n  instanceA: number,\n  planeA: Plane,\n  productB: ProductData,\n  faceDataB: FaceData,\n  instanceB: number,\n  planeB: Plane\n): DuoMeasurementValues | undefined {\n  const [pointPlaneA, normA] = decomposePlane(\n    productA,\n    faceDataA,\n    instanceA,\n    planeA,\n    true\n  );\n  const [pointPlaneB, normB] = decomposePlane(\n    productB,\n    faceDataB,\n    instanceB,\n    planeB\n  );\n\n  const dot = Math.abs(vec3.dot(normA, normB));\n  if (dot > 0.999) {\n    const d = vec3.dot(\n      normA,\n      vec3.subtract(vec3.create(), pointPlaneB, pointPlaneA)\n    );\n    const normalPointB = vec3.add(\n      vec3.create(),\n      pointPlaneA,\n      vec3.scale(vec3.create(), normA, d)\n    );\n    const normalPointA = vec3.copy(vec3.create(), pointPlaneA);\n\n    //swapAxis(pointA);\n    //swapAxis(pointB);\n    return {\n      drawKind: \"measureResult\",\n      distance: Math.abs(d),\n      distanceX: 0,\n      distanceY: 0,\n      distanceZ: 0,\n      normalPoints: [normalPointA, normalPointB],\n    };\n  }\n}\n\nasync function cylinderToCylinderMeasure(\n  cylinderA: CylinderData,\n  matA: mat4,\n  productA: ProductData,\n  faceDataA: FaceData,\n  scaleA: number,\n  cylinderB: CylinderData,\n  matB: mat4,\n  productB: ProductData,\n  faceDataB: FaceData,\n  scaleB: number,\n  cylinderMeasureA: CylinerMeasureType,\n  cylinderMeasureB: CylinerMeasureType\n): Promise<DuoMeasurementValues> {\n  const [cylinderOrigoA, cylinderEndA] = await cylinderCenterLine(\n    productA,\n    faceDataA,\n    cylinderA,\n    matA,\n    cylinderMeasureA\n  );\n  const dirA = vec3.sub(vec3.create(), cylinderEndA, cylinderOrigoA);\n  vec3.normalize(dirA, dirA);\n\n  const [cylinderOrigoB, cylinderEndB] = await cylinderCenterLine(\n    productB,\n    faceDataB,\n    cylinderB,\n    matB,\n    cylinderMeasureB\n  );\n  const dirB = vec3.sub(vec3.create(), cylinderEndB, cylinderOrigoB);\n  vec3.normalize(dirB, dirB);\n\n  const parallel =\n    vec3.equals(dirA, dirB) ||\n    vec3.equals(dirA, vec3.negate(vec3.create(), dirB));\n  let [distance, pointA, pointB] = closestProjectedPoints(\n    cylinderOrigoA,\n    cylinderEndA,\n    cylinderOrigoB,\n    cylinderEndB\n  );\n\n  const diff = vec3.sub(vec3.create(), pointA, pointB);\n\n  const canUseCylinderSettings =\n    parallel &&\n    fullCircleCylinder(productA, faceDataA) &&\n    fullCircleCylinder(productB, faceDataB);\n\n  let angle: { radians: number, angleDrawInfo: [vec3, vec3, vec3], additionalLine: [vec3, vec3] | undefined } | undefined = undefined;\n\n  if (!parallel) {\n    const intersectionPoint = closestPointsToIntersection(\n      cylinderOrigoA,\n      cylinderEndA,\n      cylinderOrigoB,\n      cylinderEndB\n    );\n    const { pos: crossPointA } = closestPointToLine(\n      intersectionPoint,\n      cylinderOrigoA,\n      cylinderEndA\n    );\n    const { pos: crossPointB } = closestPointToLine(\n      intersectionPoint,\n      cylinderOrigoB,\n      cylinderEndB\n    );\n    if (vec3.dist(pointA, pointB) > vec3.dist(crossPointA, crossPointB)) {\n      vec3.sub(diff, crossPointB, crossPointA);\n      pointA = vec3.clone(crossPointA);\n      pointB = vec3.clone(crossPointB);\n    }\n\n\n    if (vec3.length(diff) < 0.5) {\n      let negate = false;\n      //For correct angle calculation\n      if (vec3.dist(pointA, cylinderEndA) < vec3.dist(pointA, cylinderOrigoA)) {\n        vec3.negate(dirA, dirA);\n      }\n      if (vec3.dist(pointB, cylinderEndB) < vec3.dist(pointB, cylinderOrigoB)) {\n        negate = true;\n        vec3.negate(dirB, dirB);\n      }\n\n      let radians = vec3.angle(dirA, dirB);\n      if (radians > Math.PI) {\n        radians = Math.PI * 2 - radians;\n      }\n\n      let addAdditionalLine = false;\n      if (radians > Math.PI / 2) {\n        radians = Math.PI - radians;\n        if (negate) {\n          vec3.negate(dirB, dirB);\n        } else {\n          vec3.negate(dirA, dirA);\n        }\n        addAdditionalLine = true;\n      }\n\n      const center = vec3.add(vec3.create(), pointA, pointB);\n      vec3.scale(center, center, 0.5);\n      const anglePa = vec3.add(vec3.create(), center, dirA);\n      const anglePb = vec3.add(vec3.create(), center, dirB);\n      angle = {\n        radians, angleDrawInfo: [center, anglePa, anglePb],\n        additionalLine: addAdditionalLine ? [vec3.clone(center), vec3.clone(anglePa)] : undefined\n      }\n    }\n  } else {\n    vec3.normalize(diff, diff);\n    const radiusDirA = vec3.scale(\n      vec3.create(),\n      diff,\n      cylinderA.radius * scaleA * -1\n    );\n    const radiusDirB = vec3.scale(\n      vec3.create(),\n      diff,\n      cylinderB.radius * scaleB\n    );\n    if (cylinderMeasureA == \"closest\") {\n      vec3.add(pointA, pointA, radiusDirA);\n    } else if (cylinderMeasureA == \"furthest\") {\n      vec3.sub(pointA, pointA, radiusDirA);\n    }\n    if (cylinderMeasureB == \"closest\") {\n      vec3.add(pointB, pointB, radiusDirB);\n    } else if (cylinderMeasureB == \"furthest\") {\n      vec3.sub(pointB, pointB, radiusDirB);\n    }\n    vec3.sub(diff, pointB, pointA);\n  }\n\n  return {\n    drawKind: \"measureResult\",\n    distance: vec3.length(diff),\n    distanceX: Math.abs(diff[0]),\n    distanceY: Math.abs(diff[1]),\n    distanceZ: Math.abs(diff[2]),\n    measureInfoA: { point: pointA, validMeasureSettings: canUseCylinderSettings },\n    measureInfoB: { point: pointB, validMeasureSettings: canUseCylinderSettings },\n    angle,\n  };\n}\n\nfunction cylinderToPlaneMeasure(\n  cylinder: CylinderData,\n  cylinderInstanceMat: mat4,\n  plane: Plane,\n  planeProduct: ProductData,\n  planeFace: FaceData,\n  planeInstance: number,\n  scale: number,\n  canUseCylinderSettings: boolean,\n  cylinderMeasure: CylinerMeasureType\n): DuoMeasurementValues | undefined {\n  const cylinderNormalMat = mat3.normalFromMat4(\n    mat3.create(),\n    cylinderInstanceMat\n  );\n  const cylinderMat = mat4.fromValues(\n    ...(cylinder.transform as Parameters<typeof mat4.fromValues>)\n  );\n  const cylinderPoint = mat4.getTranslation(vec3.create(), cylinderMat);\n  vec3.transformMat4(cylinderPoint, cylinderPoint, cylinderInstanceMat);\n  const cylinderDir = vec3.fromValues(\n    cylinderMat[8],\n    cylinderMat[9],\n    cylinderMat[10]\n  );\n  vec3.transformMat3(cylinderDir, cylinderDir, cylinderNormalMat);\n  vec3.normalize(cylinderDir, cylinderDir);\n\n  const [planePoint, planeNorm] = decomposePlane(\n    planeProduct,\n    planeFace,\n    planeInstance,\n    plane\n  );\n  const dot = vec3.dot(cylinderDir, planeNorm);\n  const parallel = dot < 0.000001 && dot > -0.0001;\n  if (parallel) {\n    const d1 = vec3.dot(planeNorm, planePoint);\n    const d2 = vec3.dot(planeNorm, cylinderPoint);\n    let d = d2 - d1;\n    if (cylinderMeasure == \"closest\") {\n      d = d > 0 ? d - cylinder.radius * scale : d + cylinder.radius * scale;\n    } else if (cylinderMeasure == \"furthest\") {\n      d = d > 0 ? d + cylinder.radius * scale : d - cylinder.radius * scale;\n    }\n    const cylinerPlanePoint = vec3.add(\n      vec3.create(),\n      planePoint,\n      vec3.scale(vec3.create(), planeNorm, d)\n    );\n\n    return {\n      drawKind: \"measureResult\",\n      normalDistance: Math.abs(d),\n      distanceX: 0,\n      distanceY: 0,\n      distanceZ: 0,\n      normalPoints: [planePoint, cylinerPlanePoint],\n      measureInfoA: { validMeasureSettings: canUseCylinderSettings },\n      measureInfoB: { validMeasureSettings: canUseCylinderSettings }\n    };\n  }\n}\n\nexport async function getSegmentToSegmentMeasureValues(\n  productA: ProductData,\n  segIdxA: number,\n  instanceIdxA: number,\n  productB: ProductData,\n  segIdxB: number,\n  instanceIdxB: number\n): Promise<DuoMeasurementValues | undefined> {\n  let curveA = (await geometryFactory).getCurve3DFromSegment(productA, segIdxA);\n  let curveB = (await geometryFactory).getCurve3DFromSegment(productB, segIdxB);\n  if (curveA && curveB) {\n    return getCurveToCurveMeasureValues(\n      productA,\n      curveA,\n      instanceIdxA,\n      productB,\n      curveB,\n      instanceIdxB\n    );\n  }\n  return undefined;\n}\n\nexport async function getSegmentToEdgeMeasureValues(\n  productA: ProductData,\n  segIdx: number,\n  instanceIdxA: number,\n  productB: ProductData,\n  edgeIdx: number,\n  instanceIdxB: number\n): Promise<DuoMeasurementValues | undefined> {\n  let curveA = (await geometryFactory).getCurve3DFromSegment(productA, segIdx);\n  let curveB = (await geometryFactory).getCurve3DFromEdge(productB, edgeIdx);\n  if (curveA && curveB) {\n    return getCurveToCurveMeasureValues(\n      productA,\n      curveA,\n      instanceIdxA,\n      productB,\n      curveB,\n      instanceIdxB\n    );\n  }\n  return undefined;\n}\n\nexport async function getFaceToFaceMeasureValues(\n  productA: ProductData,\n  faceIdxA: number,\n  instanceIdxA: number,\n  productB: ProductData,\n  faceIdxB: number,\n  instanceIdxB: number,\n  settingA?: MeasureSettings,\n  settingB?: MeasureSettings\n): Promise<DuoMeasurementValues | undefined> {\n  const faceDataA = productA.faces[faceIdxA];\n  const surfaceDataA = productA.surfaces[faceDataA.surface];\n  let surfaceA = {\n    surf: (await geometryFactory).getSurface(surfaceDataA, 1),\n    instanceIdx: instanceIdxA,\n    faceData: faceDataA,\n    data: surfaceDataA,\n    product: productA,\n    setting: settingA,\n  };\n\n  const faceDataB = productB.faces[faceIdxB];\n  const surfaceDataB = productB.surfaces[faceDataB.surface];\n  let surfaceB = {\n    surf: (await geometryFactory).getSurface(surfaceDataB, 1),\n    instanceIdx: instanceIdxB,\n    faceData: faceDataB,\n    data: surfaceDataB,\n    product: productB,\n    setting: settingB,\n  };\n\n  if (surfaceA.surf && surfaceB.surf) {\n    const entities = [surfaceA, surfaceB];\n    entities.sort((a, b) => a.surf!.kind.localeCompare(b.surf!.kind));\n    [surfaceA, surfaceB] = entities;\n    const kindCombo = `${surfaceA.surf!.kind}_${surfaceB.surf!.kind}`;\n    switch (kindCombo) {\n      case \"plane_plane\":\n        return planeToPlaneMeasure(\n          surfaceA.product,\n          surfaceA.faceData,\n          surfaceA.instanceIdx,\n          surfaceA.surf as Plane,\n          surfaceB.product,\n          surfaceB.faceData,\n          surfaceB.instanceIdx,\n          surfaceB.surf as Plane\n        );\n\n      case \"cylinder_cylinder\": {\n        const cylinderA = surfaceA.data as CylinderData;\n        const matA = matFromInstance(\n          surfaceA.product.instances[surfaceA.instanceIdx]\n        );\n\n        const cylinderB = surfaceB.data as CylinderData;\n        const matB = matFromInstance(\n          surfaceB.product.instances[surfaceB.instanceIdx]\n        );\n\n        return cylinderToCylinderMeasure(\n          cylinderA,\n          matA,\n          surfaceA.product,\n          surfaceA.faceData,\n          unitToScale(surfaceA.product.units),\n          cylinderB,\n          matB,\n          surfaceB.product,\n          surfaceB.faceData,\n          unitToScale(surfaceB.product.units),\n          surfaceA.setting ? surfaceA.setting.cylinderMeasure : \"center\",\n          surfaceB.setting ? surfaceB.setting.cylinderMeasure : \"center\"\n        );\n      }\n\n      case \"cylinder_plane\": {\n        const cylinder = surfaceA.data as CylinderData;\n        const cylinderInstanceMat = matFromInstance(\n          surfaceA.product.instances[surfaceA.instanceIdx]\n        );\n        const canUseCylinderSettings = fullCircleCylinder(\n          surfaceA.product,\n          surfaceA.faceData\n        );\n\n        const plane = surfaceB.surf as Plane;\n        return cylinderToPlaneMeasure(\n          cylinder,\n          cylinderInstanceMat,\n          plane,\n          surfaceB.product,\n          surfaceB.faceData,\n          surfaceB.instanceIdx,\n          unitToScale(surfaceA.product.units),\n          canUseCylinderSettings,\n          surfaceA.setting && canUseCylinderSettings\n            ? surfaceA.setting.cylinderMeasure\n            : \"center\"\n        );\n      }\n    }\n  }\n}\n\nexport async function evalCurve(\n  product: ProductData,\n  pathIdx: number,\n  instanceIdx: number,\n  paramter: number,\n  pathKind: \"edge\" | \"curveSegment\"\n): Promise<[ReadonlyVec3, ReadonlyVec3] | undefined> {\n  const curve =\n    pathKind == \"edge\"\n      ? (await geometryFactory).getCurve3DFromEdge(product, pathIdx)\n      : (await geometryFactory).getCurve3DFromSegment(product, pathIdx);\n  if (curve) {\n    paramter /= unitToScale(product.units);\n    const pos = vec3.create();\n    const dir = vec3.create();\n    curve.eval(paramter, pos, dir);\n    const mat = matFromInstance(product.instances[instanceIdx]);\n    const normalMat = mat3.normalFromMat4(mat3.create(), mat);\n    vec3.transformMat3(dir, dir, normalMat);\n    vec3.transformMat4(pos, pos, mat);\n    vec3.normalize(dir, dir);\n    vec3.negate(dir, dir);\n    return [pos, dir];\n  }\n}\n", "/*\nprecomputation:\nfor each body\n    compute vertex positions, normals, tangents etc - as needed\n    (compute triangle normals)\n    create edge topology map\n\n\nbuild list of forward facing polygons (from faces)\nfor each (other) poly\n  intersect with subject\n  if intersect is not empty and intersection lies in front of subject\n     subtract intersection from subject poly\n\n\nper camera angle:\nproject 3D points onto 2D image plane using fixed point integers for robust intersection tests (but retain z component for depth tests)\ndetermine triangle facings/windings\nfor each edge\n    if outline edge (has both a forward and backward facing triangle attached)\n        store edge in list of outline edges (possibly using some sort of accelleration structure)\nfor each triangle\n    if facing forward\n        for each triangle edge\n            does any edge edge intersect outline edges that lies in front of triangle?\n                yes: split edges into visible and hidden portions\n                    also sever topological connection to create triangle islands\n                    store visibility info in each triangle half\n\n\n\nhow about we just found the outline polygons for each face?\n  only consider forward facing triangles\n  then we slice it by all other outline polygons and test visibility of each sub poly\n\n\njs: https://github.com/mfogel/polygon-clipping (uses floats and gets rounding problems, but might do for a quick prototype)\nc++: https://github.com/Geri-Borbas/Clipper (uses large ints, but possibly a little out of date and not sure we can extract all subregions)\nc++: https://www.boost.org/doc/libs/1_72_0/libs/polygon/doc/gtl_polygon_set_concept.htm (uses ints or snapped floats. made by intel, but old'ish. flexible interface with potentially useful functions for LOD etc.)\n\n*/\n\nimport { mat3, glMatrix, ReadonlyMat4, ReadonlyVec2, ReadonlyVec3, vec2, vec3 } from \"gl-matrix\";\nimport type { Face } from \"./face\";\nimport type { Triangulation } from \"./brep\";\nimport type { Surface } from \"./surfaces\";\nimport type { Edge } from \"./edge\";\nimport type { Curve3D } from \"./curves\";\n\nglMatrix.setMatrixArrayType(Array);\n\nconst epsilon = 1e-4;\n\ninterface Topology {\n    readonly triangles: readonly Triangle[];\n    readonly vertices: readonly SurfaceVertex[];\n    readonly edges: readonly EdgeInfo[];\n}\n\ntype Index = number;\ntype IndexPair = readonly [Index, Index];\ntype IndexTriplet = readonly [Index, Index, Index];\ntype EdgeKey = bigint;\n\ntype SurfaceVertex = {\n    pos: ReadonlyVec3;\n    uv: ReadonlyVec2; // parametric uv coord\n    normal: ReadonlyVec3;\n};\n\ntype EdgeVertex = {\n    pos: ReadonlyVec3;\n    t: number;\n    tangent: ReadonlyVec3;\n};\n\ninterface EdgeInfo {\n    readonly vertices: IndexPair; // pair of vertex indices\n    readonly triangles: readonly [Index] | [Index, Index]; // pair of triangle indices (if last one is 0, then the edge is non-manifold)\n}\n\ninterface Triangle {\n    readonly vertices: IndexTriplet;\n    readonly edges: IndexTriplet; // negative indices indicates that the edge direction is reversed, i.e. this is the second triangle that refer to it.\n    readonly normal: ReadonlyVec3;\n}\n\ninterface Strip {\n    startEdge: number;\n    endEdge: number; // parametric uv coord\n    strip: ReadonlyVec3[];\n}\n\nfunction constructEdgeKey(a: number, b: number): EdgeKey {\n    if (a > b) {\n        [b, a] = [a, b];\n    }\n    return BigInt(a) | (BigInt(b) << 32n);\n}\n\nfunction deconstructEdgeKey(edgeKey: EdgeKey): readonly [number, number] {\n    const a = Number(BigInt.asUintN(32, edgeKey));\n    const b = Number(BigInt.asUintN(32, edgeKey >> 32n));\n    return [a, b] as const;\n}\n\nfunction evalTriangulation(surface: Surface, triangulation: Triangulation, productMatrix?: ReadonlyMat4) {\n    const vertices: SurfaceVertex[] = [];\n    const productNormalMatrix = productMatrix ? mat3.normalFromMat4(mat3.create(), productMatrix) : undefined;\n    for (let i = 0; i < triangulation.vertices.length; i += 2) {\n        // const uv = triangulation.vertices.slice(i, i + 2) as unknown as readonly [number, number];\n        const uv = vec2.fromValues(triangulation.vertices[i], triangulation.vertices[i + 1]);\n        const pos = vec3.create();\n        const normal = vec3.create();\n        surface.evalPosition(pos, uv);\n        surface.evalNormal(normal, uv);\n        if (productMatrix && productNormalMatrix) {\n            //const rotMat = mat3.fromMat4(mat3.create(), productMatrix);\n            vec3.transformMat4(pos, pos, productMatrix);\n            //vec3.transformMat3(pos, pos, rotMat);\n            vec3.transformMat3(normal, normal, productNormalMatrix);\n            vec3.normalize(normal, normal);\n        }\n        vertices.push({ pos, uv, normal });\n    }\n    return vertices;\n}\n\nfunction evalTesselation(curve: Curve3D, transform: ReadonlyMat4) {\n    const vertices: EdgeVertex[] = [];\n    const normalMat = mat3.normalFromMat4(mat3.create(), transform);\n    for (const t of curve.tesselationParameters) {\n        const pos = vec3.create();\n        const tangent = vec3.create();\n        curve.eval(t, pos, tangent);\n\n        vec3.transformMat4(pos, pos, transform);\n        vec3.transformMat3(tangent, tangent, normalMat);\n        vec3.normalize(tangent, tangent);\n\n        vertices.push({ pos, t, tangent });\n    }\n    return vertices;\n}\n\nfunction createTopology(face: Face): Topology {\n    const edges: EdgeInfo[] = [];\n    const edgeMap = new Map<bigint, number>();\n    const triangles: Triangle[] = [];\n    const { surface, triangulation } = face;\n\n    const vertices = evalTriangulation(surface, triangulation, face.geometryTransformation);\n\n    const vertexRemap = vertices.map((_, i) => i);\n    for (const seam of face.seams) {\n        for (const [a, b] of seam.vertexIndexPairs) {\n            vertexRemap[b] = a;\n            console.assert(vec3.distance(vertices[a].pos, vertices[b].pos) < 1e-4);\n        }\n    }\n\n    const { indices } = triangulation;\n    for (let i = 0; i < indices.length; i += 3) {\n        const triangleIndex = triangles.length;\n        const vi = indices.slice(i, i + 3).map((vi) => vertexRemap[vi]);\n        if (face.sense == -1) {\n            vi.reverse();\n        }\n        const [v0, v1, v2] = vi;\n\n        const ab = vec3.subtract(vec3.create(), vertices[v1].pos, vertices[v0].pos);\n        const ac = vec3.subtract(vec3.create(), vertices[v2].pos, vertices[v0].pos);\n\n        const normal = vec3.create();\n        vec3.cross(normal, ab, ac);\n        const l2 = vec3.dot(normal, normal);\n        if (l2 == 0) continue; // skip degenerate triangles\n        vec3.normalize(normal, normal);\n\n        console.assert(vec3.dot(normal, vertices[v0].normal) > 0);\n        console.assert(vec3.dot(normal, vertices[v1].normal) > 0);\n        console.assert(vec3.dot(normal, vertices[v2].normal) > 0);\n\n        function addEdge(v0: number, v1: number) {\n            const key = constructEdgeKey(v0, v1);\n            let edgeIndex = edgeMap.get(key);\n            if (undefined === edgeIndex) {\n                edgeIndex = edges.length;\n                edgeMap.set(key, edgeIndex);\n                edges.push({\n                    vertices: [v0, v1],\n                    triangles: [triangleIndex],\n                });\n            } else {\n                const { triangles } = edges[edgeIndex];\n                console.assert(triangles.length == 1);\n                (<[Index]>edges[edgeIndex].triangles).push(triangleIndex);\n                edgeIndex = edgeIndex;\n            }\n            return edgeIndex;\n        }\n        const e0 = addEdge(v0, v1);\n        const e1 = addEdge(v1, v2);\n        const e2 = addEdge(v2, v0);\n\n        const p0 = vertices[v0].pos;\n        const p1 = vertices[v1].pos;\n        const p2 = vertices[v2].pos;\n\n        const triangle: Triangle = {\n            vertices: [v0, v1, v2] as const,\n            edges: [e0, e1, e2] as const,\n            normal,\n        } as const;\n        triangles.push(triangle);\n    }\n\n    return {\n        triangles,\n        vertices,\n        edges,\n    };\n}\n\nfunction triangleWinding(indices: readonly [number, number, number], vertices: readonly ReadonlyVec3[]) {\n    const [ia, ib, ic] = indices;\n    const [ax, ay] = vertices[ia];\n    const [bx, by] = vertices[ib];\n    const [cx, cy] = vertices[ic];\n    const x1 = bx - ax;\n    const y1 = by - ay;\n    const x2 = cx - ax;\n    const y2 = cy - ay;\n    const cp = x1 * y2 - y1 * x2;\n    return cp > 0 ? 1 : -1;\n}\n\nfunction triangleVertexFacing(indices: readonly [number, number, number], normals: readonly ReadonlyVec3[]) {\n    const [ia, ib, ic] = indices;\n    const az = normals[ia][2];\n    const bz = normals[ib][2];\n    const cz = normals[ic][2];\n    if (az > epsilon && bz > epsilon && cz > epsilon) {\n        return 1;\n    } else if (az < epsilon && bz < epsilon && cz < epsilon) {\n        return -1;\n    }\n    return 0;\n}\n\nfunction edgeVertexStraddling(indices: readonly [number, number], normals: readonly ReadonlyVec3[]) {\n    const [ia, ib] = indices;\n    const az = normals[ia][2];\n    const bz = normals[ib][2];\n    if (az > epsilon && bz > epsilon) {\n        return 0;\n    } else if (az < epsilon && bz < epsilon) {\n        return 0;\n    }\n    return Math.sign(az - bz);\n}\n\nfunction edgeVertexFacing(indices: readonly [number, number], normals: readonly ReadonlyVec3[]) {\n    const [ia, ib] = indices;\n    const az = normals[ia][2];\n    const bz = normals[ib][2];\n    if (az > epsilon && bz > epsilon) {\n        return 1;\n    } else if (az < epsilon && bz < epsilon) {\n        return -1;\n    }\n    return 0;\n}\n\nfunction edgeStraddleParameter(indices: readonly [number, number], normals: readonly ReadonlyVec3[]) {\n    const [ia, ib] = indices;\n    const az = normals[ia][2];\n    const bz = normals[ib][2];\n    let t = (az - epsilon) / (az - bz);\n    return t < 0 ? 0 : t > 1 ? 1 : t;\n}\n\nexport type PathInfo = { path: string; centerDepth: number; originalIndex: number; instanceIndex: number; kind: \"edge\" | \"face\" };\n\nexport function getEdgeStrip(edge: Edge, sense: number): ReadonlyVec3[] {\n    const v = evalTesselation(edge.curve, edge.geometryTransformation).map((v) => v.pos);\n    return sense > 0 ? v : v.reverse();\n}\n\nexport function getBrepEdges(edges: readonly (Edge | undefined)[], worldViewMatrix: ReadonlyMat4): PathInfo[] {\n    const paths: PathInfo[] = [];\n    for (let i = 0; i < edges.length; ++i) {\n        const edge = edges[i];\n        if (!edge) {\n            continue;\n        }\n        const vertices = evalTesselation(edge.curve, edge.geometryTransformation);\n        const verticiesVS = vertices.map((v) => vec3.transformMat4(vec3.create(), v.pos, worldViewMatrix));\n        const pathParts: string[] = [];\n        let [x, y] = verticiesVS[0];\n        pathParts.push(`M ${x} ${y}`);\n        for (let i = 1; i < vertices.length; ++i) {\n            [x, y] = verticiesVS[i];\n            pathParts.push(`L ${x} ${y}`);\n        }\n        const path = pathParts.join(\" \");\n        //TODO: Check if closed\n\n        paths.push({ path, centerDepth: 0, originalIndex: i, instanceIndex: edge.instanceIndex, kind: \"edge\" });\n    }\n    return paths;\n}\n\nexport function getBrepFaces(faces: readonly Face[], worldViewMatrix: ReadonlyMat4): PathInfo[] {\n    // const towardsCamera = camera.backward;\n\n    const paths: PathInfo[] = [];\n\n    for (let i = 0; i < faces.length; ++i) {\n        const face = faces[i];\n        const { loops } = getProjectedLoops(face, worldViewMatrix);\n\n        // const loops = triangles.filter((t, i) => triangleFacings[i] > 0).map(t => t.vertices);\n\n        // create rendercontext path from loops\n        // const path = new Path2D();\n        let minDepth = Number.MAX_VALUE;\n        let maxDepth = Number.MIN_VALUE;\n        const pathParts: string[] = [];\n\n        function polygonWinding(loop: readonly ReadonlyVec3[]) {\n            let totalArea = 0;\n            for (let i = 0; i < loop.length; ++i) {\n                const a = loop[i];\n                const b = loop[(i + 1) % loop.length];\n                const cp = (b[0] - a[0]) * (b[1] + a[1]);\n                //const cp = a[0] * b[1] - a[1] * b[0];\n                totalArea += cp;\n            }\n            console.assert(totalArea != 0);\n            return Math.sign(totalArea) as 1 | -1;\n        }\n\n        function endPath() {\n            const path = pathParts.join(\" \");\n            const centerDepth = (minDepth + maxDepth) / 2;\n            paths.push({ path, centerDepth, originalIndex: i, instanceIndex: face.instanceIndex, kind: \"face\" });\n        }\n\n        const windings: number[] = [];\n\n        for (const loopWS of loops) {\n            const loopVS = loopWS.map((v) => vec3.transformMat4(vec3.create(), v, worldViewMatrix));\n            const winding = -polygonWinding(loopVS);\n            windings.push(winding);\n            //todo winding > 0 more than one split loops\n            for (const v of loopVS) {\n                const depth = v[2];\n                if (minDepth > depth) {\n                    minDepth = depth;\n                }\n                if (maxDepth < depth) {\n                    maxDepth = depth;\n                }\n            }\n            const [x, y] = loopVS[loopVS.length - 1];\n            pathParts.push(`M ${x} ${y}`);\n            for (const v of loopVS) {\n                const [x, y] = v;\n                pathParts.push(`L ${x} ${y}`);\n            }\n        }\n\n        endPath();\n    }\n\n    return paths;\n}\n\nfunction getContourEdges(topology: Topology, normalsVS: readonly ReadonlyVec3[]) {\n    const { edges, triangles, vertices } = topology;\n\n    const edgeStraddle = edges.map((e) => edgeVertexStraddling(e.vertices, normalsVS));\n    const straddlingTriangleIndices = triangles.map((t, i) => i).filter((i) => triangleVertexFacing(triangles[i].vertices, normalsVS) == 0);\n    const remainingTriangles = new Set<number>(straddlingTriangleIndices);\n\n    const straddlePoints = edges.map((e, i) => {\n        if (edgeStraddle[i] == 0) {\n            return undefined;\n        }\n        const t = edgeStraddleParameter(e.vertices, normalsVS);\n        const va = vertices[e.vertices[0]];\n        const vb = vertices[e.vertices[1]];\n        return vec3.lerp(vec3.create(), va.pos, vb.pos, t) as ReadonlyVec3;\n    });\n\n    function traverseContourEdges(edge: number) {\n        const edgeStrip: number[] = [];\n        edgeStrip.push(edge);\n        let currentEdge = edge;\n        let run = true;\n        while (run) {\n            run = false;\n            for (const triangleIndex of edges[currentEdge].triangles) {\n                if (remainingTriangles.delete(triangleIndex)) {\n                    const triangle = triangles[triangleIndex];\n                    const straddleEdges = triangle.edges.filter((i) => edgeStraddle[i] != 0 && i != currentEdge);\n                    console.assert(straddleEdges.length == 1);\n                    currentEdge = straddleEdges[0];\n                    edgeStrip.push(currentEdge);\n                    run = true;\n                    break;\n                }\n            }\n        }\n        return edgeStrip;\n    }\n\n    function isContourLoop(edgeStart: number, edgeEnd: number) {\n        const start = edges[edgeStart].triangles;\n        const end = edges[edgeEnd].triangles;\n        return start.some((i) => end.some((j) => j == i));\n    }\n\n    function createStripFromStraddleEdges(loop: number[]) {\n        const strip: ReadonlyVec3[] = [];\n        for (const index of loop) {\n            strip.push(straddlePoints[index]!);\n        }\n        return strip;\n    }\n\n    const strips: number[][] = [];\n    const loops: ReadonlyVec3[][] = [];\n\n    while (remainingTriangles.size > 0) {\n        const keys = [...remainingTriangles.keys()];\n        //const triangleIndex = keys[Math.floor(Math.random() * keys.length)];\n        const triangleIndex = remainingTriangles.keys().next().value as number;\n        remainingTriangles.delete(triangleIndex);\n\n        const triangle = triangles[triangleIndex];\n        const triangleEdges = triangle.edges;\n        const straddleEdges = triangleEdges.filter((i) => edgeStraddle[i] != 0);\n        straddleEdges.sort((a, b) => edgeStraddle[a] - edgeStraddle[b]);\n\n        const leftStrip = traverseContourEdges(straddleEdges[0]);\n        const rightStrip = traverseContourEdges(straddleEdges[1]);\n        const combinedStrip = [...rightStrip.reverse(), ...leftStrip];\n        if (isContourLoop(combinedStrip[0], combinedStrip[combinedStrip.length - 1])) {\n            loops.push(createStripFromStraddleEdges(combinedStrip));\n        } else {\n            strips.push(combinedStrip);\n        }\n    }\n\n    const contourStrips = strips.map((s) => {\n        return { startEdge: s[0], endEdge: s[s.length - 1], strip: s.map((i) => straddlePoints[i]!) };\n    });\n\n    return { loops, contourStrips };\n}\n\nfunction getTrimEdges(topology: Topology, normalsVS: readonly ReadonlyVec3[], facing: number = 1) {\n    const { edges } = topology;\n    const edgeFacing = edges.map((e) => edgeVertexFacing(e.vertices, normalsVS));\n\n    const edgeIndices = edges.map((e, i) => i);\n    const trimEdgeIndices = edgeIndices.filter((i) => edges[i].triangles.length === 1 && edgeFacing[i] * facing >= 0);\n    return trimEdgeIndices;\n}\n\nfunction getTrimStrips(topology: Topology, normalsVS: readonly ReadonlyVec3[]) {\n    const { edges, vertices } = topology;\n\n    const trimEdgeIndices = getTrimEdges(topology, normalsVS);\n\n    const trimEdgesMap = new Map<number, [number, number]>();\n\n    const edgeReferences = new Array<number>(edges.length).fill(0);\n    for (const trimEdgeIndex of trimEdgeIndices) {\n        const trimEdge = edges[trimEdgeIndex];\n        let [va, vb] = trimEdge.vertices;\n        console.assert(!trimEdgesMap.has(va));\n        ++edgeReferences[va];\n        --edgeReferences[vb];\n        trimEdgesMap.set(va, [vb, trimEdgeIndex]);\n    }\n\n    const beginEdges = edgeReferences.map((count, index) => ({ index, count })).filter((e) => e.count == 1);\n\n    const trimLoops: ReadonlyVec3[][] = [];\n    const trimStrips: Strip[] = [];\n    function traverseEdges(startKey: number) {\n        let strip: ReadonlyVec3[] = [];\n        let head = startKey;\n        const value = trimEdgesMap.get(head)!;\n        const startEdge = value[1];\n        let endEdge = value[1];\n        do {\n            strip.push(vertices[head].pos);\n            const tail = head;\n            const value = trimEdgesMap.get(tail) as [number, number];\n            trimEdgesMap.delete(tail);\n            if (value === undefined) {\n                break;\n            }\n            head = value[0];\n            endEdge = value[1];\n            console.assert(strip.length < 100000); // infinite loop?\n        } while (head != startKey);\n        if (head == startKey) {\n            endEdge = startEdge;\n            return { kind: \"loop\", strip } as const;\n        } else {\n            strip = strip.slice(1, strip.length - 1);\n        }\n        return { kind: \"strip\", startEdge, endEdge, strip } as const;\n    }\n\n    for (const beginEdge of beginEdges) {\n        const strip = traverseEdges(beginEdge.index);\n        if (strip.kind === \"strip\") {\n            trimStrips.push(strip);\n        } else {\n            console.assert(false);\n        }\n    }\n\n    while (trimEdgesMap.size > 0) {\n        const key = trimEdgesMap.keys().next().value as number;\n        const { kind, strip } = traverseEdges(key);\n        trimLoops.push(strip);\n        console.assert(kind == \"loop\");\n    }\n    return { trimLoops, trimStrips };\n}\n\nfunction* loopsFromStrips(combinedStrips: Strip[]) {\n    while (combinedStrips.length > 0) {\n        const loop: ReadonlyVec3[] = [];\n        let current = combinedStrips.pop()!;\n        const loopStartEdge = current.startEdge;\n        loop.push(...current.strip);\n        for (; ;) {\n            let foundIndex: number | undefined = undefined;\n            for (let i = 0; i < combinedStrips.length; ++i) {\n                const { startEdge } = combinedStrips[i];\n                if (startEdge == current.endEdge) {\n                    foundIndex = i;\n                    break;\n                }\n            }\n            if (foundIndex !== undefined) {\n                current = combinedStrips[foundIndex];\n                loop.push(...current.strip);\n                combinedStrips.splice(foundIndex, 1);\n            } else {\n                break;\n            }\n        }\n        if (loopStartEdge === current.endEdge) {\n            yield loop;\n        } else {\n            console.error(\"Unable to join to loop\");\n        }\n    }\n}\n\nfunction projectFace(topology: Topology, worldViewMatrix: ReadonlyMat4) {\n    const { vertices } = topology;\n    const positionsVS = new Array<vec3>(vertices.length);\n    for (let i = 0; i < vertices.length; i++) {\n        positionsVS[i] = vec3.create();\n        vec3.transformMat4(positionsVS[i], vertices[i].pos, worldViewMatrix);\n    }\n\n    const normalsVS = new Array<vec3>(vertices.length);\n    const worldViewMatrixNormal = mat3.normalFromMat4(mat3.create(), worldViewMatrix);\n    for (let i = 0; i < vertices.length; i++) {\n        normalsVS[i] = vec3.create();\n        vec3.transformMat3(normalsVS[i], vertices[i].normal, worldViewMatrixNormal);\n    }\n\n    const cameraDir = vec3.fromValues(0, 0, 1);\n    vec3.transformMat3(cameraDir, cameraDir, worldViewMatrixNormal);\n    return { positionsVS, normalsVS };\n}\n\nexport function getProjectedLoops(face: Face, worldViewMatrix: ReadonlyMat4) {\n    const topology = createTopology(face);\n\n    const { normalsVS, positionsVS } = projectFace(topology, worldViewMatrix);\n    const loops: ReadonlyVec3[][] = [];\n\n    const { trimLoops, trimStrips } = getTrimStrips(topology, normalsVS);\n    loops.push(...trimLoops);\n\n    const { loops: contourLoops, contourStrips } = getContourEdges(topology, normalsVS);\n    loops.push(...contourLoops);\n\n    const combinedStrips = [...contourStrips, ...trimStrips];\n    loops.push(...loopsFromStrips(combinedStrips));\n\n    //DEBUG CODE\n    const { vertices, triangles, edges } = topology;\n    const trimEdges = getTrimEdges(topology, normalsVS, 0).map((i) => edges[i].vertices);\n    ///\n\n    return { loops, trimLoops, contourLoops, trimEdges, vertices, positionsVS };\n}\n", "import type {\n  CameraValues,\n  CylinderValues,\n  EdgeValues,\n  FaceValues,\n  MeasureSettings,\n  PlaneValues,\n} from \"@novorender/measure-api\";\nimport type { ObjectId } from \"@novorender/webgl-api\";\nimport { mat3, ReadonlyVec3, vec2, vec3 } from \"gl-matrix\";\nimport type { AABB2, CylinderData, FaceData, LoopData, ProductData, SurfaceData } from \"./brep\";\nimport { cylinderCenterLine } from \"./calculations\";\nimport { geometryFactory, matFromInstance, unitToScale } from \"./loader\";\nimport { epsilon } from \"./scene\";\nimport type { Surface } from \"./surfaces\";\n\nexport async function extractCurveValues(\n  product: ProductData,\n  pathIdx: number,\n  instanceIdx: number,\n  pathKind: \"edge\" | \"curveSegment\"\n): Promise<EdgeValues | undefined> {\n  const start = vec3.create();\n  const end = vec3.create();\n\n  const parameterData =\n    pathKind == \"edge\"\n      ? product.edges[pathIdx]\n      : product.curveSegments[pathIdx];\n  if (parameterData.curve3D != undefined) {\n    const curveData = product.curves3D[parameterData.curve3D];\n    switch (curveData.kind) {\n      case \"line\": {\n        const mat = matFromInstance(product.instances[instanceIdx]);\n        const edgeCurve =\n          pathKind == \"edge\"\n            ? (await geometryFactory).getCurve3DFromEdge(product, pathIdx)\n            : (await geometryFactory).getCurve3DFromSegment(product, pathIdx);\n        edgeCurve?.eval(parameterData.parameterBounds[0], start, undefined);\n        edgeCurve?.eval(parameterData.parameterBounds[1], end, undefined);\n        const dir = vec3.subtract(vec3.create(), end, start);\n\n        vec3.transformMat4(start, start, mat);\n        vec3.transformMat4(end, end, mat);\n\n        let dist = vec3.len(dir);\n        dist *= unitToScale(product.units);\n        vec3.normalize(dir, dir);\n        return { kind: \"line\", distance: dist, gradient: dir, start, end };\n      }\n      case \"circle\": {\n        const totalAngle =\n          parameterData.parameterBounds[1] - parameterData.parameterBounds[0];\n        return {\n          kind: \"arc\",\n          radius: curveData.radius * unitToScale(product.units),\n          totalAngle,\n        };\n      }\n      case \"lineStrip\": {\n        const closed = vec3.equals(\n          curveData.vertices[0],\n          curveData.vertices[curveData.vertices.length - 1]\n        );\n        return {\n          kind: \"lineStrip\",\n          totalLength: closed\n            ? undefined\n            : (parameterData.parameterBounds[1] -\n              parameterData.parameterBounds[0]) *\n            unitToScale(product.units),\n        };\n      }\n    }\n  }\n}\n\nexport async function extractPlaneValues(prodId: ObjectId, faceIdx: number, product: ProductData, instanceIdx: number, faceData: FaceData, surf: Surface, scale: number): Promise<PlaneValues> {\n  type MutableAABB2 = { readonly min: vec2; readonly max: vec2 };\n  function union(out: MutableAABB2, a: AABB2) {\n    vec2.min(out.min, out.min, a.min);\n    vec2.max(out.max, out.max, a.max);\n  }\n\n  const loopToEdges = async (\n    loop: LoopData\n  ): Promise<{\n    edges: EdgeValues[];\n    useRadius: boolean;\n    radius: number | undefined;\n  }> => {\n    let useRadius = true;\n    let radius = 0.0 as number | undefined;\n    let edges: EdgeValues[] = [];\n    for (const halfEdgeIdx of loop.halfEdges) {\n      const halfEdgeData = product.halfEdges[halfEdgeIdx];\n      const edgeValue = await extractCurveValues(\n        product,\n        halfEdgeData.edge,\n        instanceIdx,\n        \"edge\"\n      );\n      if (edgeValue) {\n        if (useRadius) {\n          if (edgeValue.kind != \"arc\") {\n            useRadius = false;\n            radius = undefined;\n          } else {\n            radius = Math.max(edgeValue.radius, radius as number) * scale;\n          }\n        }\n        edges.push(edgeValue);\n      }\n    }\n    return {\n      edges,\n      useRadius,\n      radius,\n    };\n  };\n\n  const mat = matFromInstance(product.instances[instanceIdx]);\n  function addVertexFromIndex(points: ReadonlyVec3[], index: number) {\n    const v = vec3.clone(product!.vertices[index].position);\n    vec3.transformMat4(v as vec3, v, mat);\n    points.push(v);\n  }\n  let hasWidthAndHeight = true;\n  const loop = product.loops[faceData.outerLoop];\n  const aabb = {\n    min: vec2.fromValues(Number.MAX_VALUE, Number.MAX_VALUE),\n    max: vec2.fromValues(-Number.MAX_VALUE, -Number.MAX_VALUE),\n  };\n  let verts: ReadonlyVec3[] = [];\n  for (const halfEdgeIdx of loop.halfEdges) {\n    const aabb2 = (await geometryFactory).getHalfEdgeAABB(product, halfEdgeIdx);\n    if (!aabb2) {\n      break;\n    }\n    union(aabb, aabb2);\n\n    const halfEdgeData = product.halfEdges[halfEdgeIdx];\n    const edgeData = product.edges[halfEdgeData.edge];\n    if (edgeData.vertices) {\n      if (halfEdgeData.direction === 1) {\n        addVertexFromIndex(verts, edgeData.vertices[0]);\n      } else {\n        addVertexFromIndex(verts, edgeData.vertices[1]);\n      }\n    }\n  }\n\n  const normal = vec3.create();\n  const normalMat = mat3.normalFromMat4(mat3.create(), mat);\n  surf.evalNormal(normal, [0, 0]);\n  vec3.transformMat3(normal, normal, normalMat);\n  const xyNormal = vec3.fromValues(0, 0, 1);\n  const dotXyPlane = Math.abs(vec3.dot(normal, xyNormal));\n  let heightAboveXyPlane: number | undefined = undefined;\n  if (1 - dotXyPlane < epsilon) {\n    const pos = vec3.create();\n    surf.evalPosition(pos, [0, 0]);\n    vec3.scale(pos, pos, 1 / scale);\n    vec3.transformMat4(pos, pos, mat);\n    heightAboveXyPlane = pos[2];\n  }\n\n  let outerEdges = await loopToEdges(loop);\n\n  let innerEdges: EdgeValues[][] = [];\n  let innerRadius = undefined as number | undefined;\n  if (faceData.innerLoops) {\n    let useInnerRadius = true;\n    innerRadius = 0.0;\n    for (const innerLoopIdx of faceData.innerLoops) {\n      const innerLoop = product.loops[innerLoopIdx];\n      const edgeResult = await loopToEdges(innerLoop);\n      innerEdges.push(edgeResult.edges);\n      useInnerRadius = edgeResult.useRadius && useInnerRadius;\n      if (edgeResult.radius) {\n        innerRadius = Math.max(innerRadius as number, edgeResult.radius);\n      }\n    }\n    if (!useInnerRadius) {\n      innerRadius = undefined;\n    }\n  }\n\n  let width = undefined;\n  let height = undefined;\n  if (!outerEdges.useRadius) {\n    width = (aabb.max[0] - aabb.min[0]) * scale;\n    height = (aabb.max[1] - aabb.min[1]) * scale;\n  }\n\n  return {\n    kind: \"plane\",\n    width,\n    height,\n    outerRadius: outerEdges.radius,\n    innerRadius,\n    normal: normal,\n    area: faceData.area ? faceData.area * scale * scale : undefined,\n    vertices: verts as vec3[],\n    outerEdges: outerEdges.edges,\n    innerEdges,\n    heightAboveXyPlane,\n    entity: {\n      ObjectId: prodId, drawKind: \"face\", pathIndex: faceIdx, instanceIndex: instanceIdx\n    }\n  };\n}\n\nexport async function extractCylinderValues(prodId: ObjectId, faceIdx: number, product: ProductData, instanceIdx: number,\n  faceData: FaceData, cylinderData: CylinderData, scale: number, setting?: MeasureSettings): Promise<CylinderValues> {\n\n  const mat = matFromInstance(product.instances[instanceIdx]);\n  const [cylinderOrigo, cylinderEnd] = await cylinderCenterLine(\n    product,\n    faceData,\n    cylinderData,\n    mat,\n    setting ? setting.cylinderMeasure : \"center\"\n  );\n  return {\n    kind: \"cylinder\",\n    radius: cylinderData.radius * scale,\n    centerLineStart: cylinderOrigo,\n    centerLineEnd: cylinderEnd,\n    entity: {\n      ObjectId: prodId, drawKind: \"face\", pathIndex: faceIdx, instanceIndex: instanceIdx\n    }\n  };\n}\n\n\nexport async function extractFaceValues(\n  prodId: ObjectId,\n  product: ProductData,\n  faceIdx: number,\n  instanceIdx: number,\n  setting?: MeasureSettings\n): Promise<FaceValues | undefined> {\n\n  const faceData = product.faces[faceIdx];\n  const scale = unitToScale(product.units);\n  const surfaceData = product.surfaces[faceData.surface];\n  const surf = (await geometryFactory).getSurface(\n    surfaceData,\n    faceData.facing,\n    scale\n  );\n  switch (surf.kind) {\n    case \"plane\": {\n      return await extractPlaneValues(prodId, faceIdx, product, instanceIdx, faceData, surf, scale);\n    }\n    case \"cylinder\": {\n      const cylinderData = surfaceData as CylinderData;\n      return await extractCylinderValues(prodId, faceIdx, product, instanceIdx, faceData, cylinderData, scale, setting);\n    }\n  }\n}\n\nexport async function extractCameraValuesFromFace(\n  product: ProductData,\n  faceIdx: number,\n  instanceIdx: number,\n  cameraDir: vec3,\n  setting?: MeasureSettings\n): Promise<CameraValues | undefined> {\n  const faceData = product.faces[faceIdx];\n  const surfaceData = product.surfaces[faceData.surface];\n  switch (surfaceData.kind) {\n    case \"cylinder\": {\n      const cylinderA = surfaceData as CylinderData;\n      const mat = matFromInstance(product.instances[instanceIdx]);\n      const [cylinderOrigo, cylinderEnd] = await cylinderCenterLine(\n        product,\n        faceData,\n        cylinderA,\n        mat,\n        setting ? setting.cylinderMeasure : \"center\"\n      );\n      const cylinderDir = vec3.sub(vec3.create(), cylinderEnd, cylinderOrigo);\n      vec3.normalize(cylinderDir, cylinderDir);\n      const dotCamera = vec3.dot(cameraDir, cylinderDir);\n      if (Math.abs(dotCamera) > 0.8) {\n        let position: vec3;\n        if (dotCamera < 0) {\n          position = cylinderEnd;\n        } else {\n          vec3.negate(cylinderDir, cylinderDir);\n          position = cylinderOrigo;\n        }\n        return { normal: cylinderDir, position };\n      }\n      const position = vec3.lerp(\n        vec3.create(),\n        cylinderOrigo,\n        cylinderEnd,\n        0.5\n      );\n\n      const xAxis = vec3.cross(\n        vec3.create(),\n        cylinderDir,\n        vec3.fromValues(1, 0, 0)\n      );\n      const dotX = vec3.dot(cameraDir, xAxis);\n      const absDotX = Math.abs(dotX);\n      const yAxis = vec3.cross(\n        vec3.create(),\n        cylinderDir,\n        vec3.fromValues(0, 1, 0)\n      );\n      const dotY = vec3.dot(cameraDir, yAxis);\n      const absDotY = Math.abs(dotY);\n      const zAxis = vec3.cross(\n        vec3.create(),\n        cylinderDir,\n        vec3.fromValues(0, 0, 1)\n      );\n      const dotZ = vec3.dot(cameraDir, zAxis);\n      const absDotZ = Math.abs(dotZ);\n\n      if (absDotX > absDotY && absDotX > absDotZ) {\n        if (dotX > 0) {\n          vec3.negate(xAxis, xAxis);\n        }\n        return { normal: xAxis, position };\n      } else if (absDotY > absDotZ) {\n        if (dotY > 0) {\n          vec3.negate(yAxis, yAxis);\n        }\n        return { normal: yAxis, position };\n      } else {\n        if (dotZ > 0) {\n          vec3.negate(zAxis, zAxis);\n        }\n        return { normal: zAxis, position };\n      }\n    }\n  }\n}\n", "import type { EdgeValues, FaceValues, ObjectId } from \"@novorender/measure-api\";\nimport type { LoopData, ProductData, ShellData } from \"./brep\";\nimport { extractCurveValues, extractFaceValues } from \"./extract_values\";\nimport { matFromInstance } from \"./loader\";\n\nexport interface ParametricEdge {\n  index: number;\n  values: EdgeValues | undefined;\n}\n\nexport interface ParametricFace {\n  index: number;\n  values: FaceValues | undefined;\n  outerLoop: ParametricEdge[];\n  innerLoops?: ParametricEdge[][];\n}\n\nexport interface ParametricSolid {\n  volume?: number;\n  outerShell: ParametricFace[];\n  innerShells?: ParametricFace[][];\n}\n\nexport interface ParametricGeometry {\n  index: number;\n  solids: ParametricSolid[];\n}\n\nexport interface ParametricProduct {\n  geometries: ParametricGeometry[];\n}\n\nexport async function toParametricProduct(prodId: ObjectId, product: ProductData) {\n  const handleLoop = async (\n    loop: LoopData,\n    instanceIdx: number\n  ): Promise<ParametricEdge[] | undefined> => {\n    const loopEdges: ParametricEdge[] = [];\n    for (const halfEdgeIdx of loop.halfEdges) {\n      const halfEdge = product!.halfEdges[halfEdgeIdx];\n      loopEdges.push({\n        index: halfEdge.edge,\n        values: await extractCurveValues(\n          product,\n          halfEdge.edge,\n          instanceIdx,\n          \"edge\"\n        ),\n      });\n    }\n    return loopEdges;\n  };\n  const handleShell = async (\n    shellData: ShellData,\n    instanceIdx: number\n  ): Promise<ParametricFace[] | undefined> => {\n    const outerFaces: ParametricFace[] = [];\n    for (const faceIdx of shellData.faces) {\n      const faceData = product.faces[faceIdx];\n      const outerLoop = await handleLoop(\n        product.loops[faceData.outerLoop],\n        instanceIdx\n      );\n      if (outerLoop == undefined) {\n        return undefined;\n      }\n      let innerLoops: ParametricEdge[][] | undefined = undefined;\n      if (faceData.innerLoops) {\n        innerLoops = [];\n        for (const loopIdx of faceData.innerLoops) {\n          const innerLoop = await handleLoop(\n            product.loops[loopIdx],\n            instanceIdx\n          );\n          if (innerLoop == undefined) {\n            return undefined;\n          }\n          innerLoops.push(innerLoop);\n        }\n      }\n      outerFaces.push({\n        index: faceIdx,\n        outerLoop,\n        innerLoops,\n        values: await extractFaceValues(prodId, product, faceIdx, instanceIdx),\n      });\n      return outerFaces;\n    }\n  };\n  const geometries: ParametricGeometry[] = [];\n  for (let i = 0; i < product.instances.length; ++i) {\n    const instanceData = product.instances[i];\n    const mat = matFromInstance(instanceData);\n    const geometryData = product.geometries[instanceData.geometry as number];\n    const solids: ParametricSolid[] = [];\n    let volume = 0;\n    if (geometryData.shells) {\n      for (const shellIdx of geometryData.shells) {\n        const shellData = product.shells[shellIdx];\n        if (shellData.volume) {\n          volume += shellData.volume;\n        }\n\n        const outerFaces = await handleShell(shellData, i);\n        if (outerFaces) {\n          solids.push({\n            volume: volume == 0 ? undefined : volume,\n            outerShell: outerFaces,\n          });\n        } else {\n          return undefined;\n        }\n      }\n    }\n    if (geometryData.solids) {\n      for (const solidIdx of geometryData.solids) {\n        const solidData = product.solids[solidIdx];\n        const outerShellData = product.shells[solidData.outerShell];\n        if (outerShellData.volume) {\n          volume += outerShellData.volume;\n        }\n\n        const outerShell = await handleShell(outerShellData, i);\n        if (outerShell == undefined) {\n          return undefined;\n        }\n        let innerShells: ParametricFace[][] | undefined = undefined;\n        if (solidData.innerShells) {\n          innerShells = [];\n          for (const shellIdx of solidData.innerShells) {\n            const innerShellData = product.shells[shellIdx];\n            if (innerShellData.volume) {\n              volume -= innerShellData.volume;\n            }\n            const innerShell = await handleShell(innerShellData, i);\n            if (innerShell == undefined) {\n              return undefined;\n            }\n            innerShells.push(innerShell);\n          }\n        }\n        solids.push({\n          volume: volume == 0 ? undefined : volume,\n          outerShell,\n          innerShells,\n        });\n      }\n    }\n    geometries.push({ index: i, solids });\n  }\n  return { geometries };\n}\n", "import type { MeasureSettings, Profile } from \"@novorender/measure-api\";\nimport { ReadonlyVec2, ReadonlyVec3, vec2, vec3 } from \"gl-matrix\";\nimport type { ProductData } from \"./brep\";\nimport { cylinderCenterLine } from \"./calculations\";\nimport type { Curve3D, LineStrip3D, NurbsCurve3D } from \"./curves\";\nimport { crawlInstance, matFromInstance } from \"./loader\";\nimport { getProfile, reduceLineStrip } from \"./util\";\n\nexport function slopeFromProfile(profile: ReadonlyVec2[]): number[] {\n  const slopes: number[] = [];\n  if (profile.length > 0) {\n    for (let i = 1; i < profile.length; ++i) {\n      const prevP = profile[i - 1];\n      const p = profile[i];\n      const segLen = p[0] - prevP[0];\n      const heightDiff = p[1] - prevP[1];\n      slopes.push(heightDiff / segLen);\n    }\n  }\n  return slopes;\n}\n\nexport function topAndBottomFromProfile(profile: ReadonlyVec2[]) {\n  let top = Number.MIN_SAFE_INTEGER;\n  let bottom = Number.MAX_SAFE_INTEGER;\n  for (const v of profile) {\n    top = Math.max(top, v[1]);\n    bottom = Math.min(bottom, v[1]);\n  }\n  return { top, bottom };\n}\n\nexport function reduceProfile(profile: ReadonlyVec2[]): Profile {\n  const slopeEpsilon = 1e-4;\n  const slopes: number[] = [];\n  const newProfile: ReadonlyVec2[] = [];\n  var elevations = topAndBottomFromProfile(profile);\n  let startElevation = 0;\n  let endElevation = 0;\n  startElevation = profile[0][1];\n  endElevation = profile[profile.length - 1][1];\n  if (profile.length > 1) {\n    let prevSlope = 0;\n    newProfile.push(profile[0]);\n    slopes.push(prevSlope);\n    for (let i = 1; i < profile.length; ++i) {\n      const prevP = profile[i - 1];\n      const p = profile[i];\n      const segLen = p[0] - prevP[0];\n      const heightDiff = p[1] - prevP[1];\n      const slope = heightDiff / segLen;\n      if (Math.abs(slope - prevSlope) > slopeEpsilon) {\n        slopes.push(prevSlope);\n        newProfile.push(prevP);\n      }\n      prevSlope = slope;\n    }\n    newProfile.push(profile[profile.length - 1]);\n    slopes.push(prevSlope);\n  }\n  return {\n    profilePoints: newProfile,\n    slopes,\n    startElevation,\n    endElevation,\n    top: elevations.top,\n    bottom: elevations.bottom,\n  };\n}\n\nexport function getCurveSegmentProfile(\n  product: ProductData,\n  curveSeg: Curve3D,\n  instanceIdx: number\n): Profile | undefined {\n  if (curveSeg && curveSeg.kind == \"lineStrip\") {\n    const lineStrip = curveSeg as LineStrip3D;\n    const mat = matFromInstance(product.instances[instanceIdx]);\n    const profile = lineStrip.toProfile(mat);\n    return reduceProfile(profile);\n  }\n  if (curveSeg && curveSeg.kind == \"nurbs\") {\n    const nurbs = curveSeg as NurbsCurve3D;\n\n    const vertices: ReadonlyVec3[] = [];\n    let parameters: readonly number[] = [];\n    if (nurbs.order == 2) {\n      for (let i = 1; i < nurbs.knots.length; ++i) {\n        (parameters as number[]).push(nurbs.knots[i]);\n      }\n      vertices.push(...nurbs.controlPoints);\n    } else {\n      parameters = nurbs.tesselationParameters;\n      for (const p of nurbs.tesselationParameters) {\n        const v = vec3.create();\n        nurbs.eval(p, v, undefined);\n        vertices.push(v);\n      }\n    }\n\n    const mat = matFromInstance(product.instances[instanceIdx]);\n    const profile = getProfile(reduceLineStrip(vertices), parameters, mat);\n    var elevations = topAndBottomFromProfile(profile);\n    return {\n      profilePoints: profile,\n      slopes: slopeFromProfile(profile),\n      startElevation: profile[0][1],\n      endElevation: profile[profile.length - 1][1],\n      top: elevations.top,\n      bottom: elevations.bottom,\n    };\n  }\n}\n\nexport async function getCylinderProfile(\n  product: ProductData,\n  faceIdx: number,\n  instanceIdx: number,\n  setting?: MeasureSettings\n): Promise<Profile | undefined> {\n  const face = product.faces[faceIdx];\n  const surfaceData = product.surfaces[face.surface];\n  if (surfaceData.kind == \"cylinder\") {\n    const mat = matFromInstance(product.instances[instanceIdx]);\n    const [start, end] = await cylinderCenterLine(\n      product,\n      face,\n      surfaceData,\n      mat,\n      setting ? setting.cylinderMeasure : \"center\"\n    );\n    const profile = [\n      vec2.fromValues(0, start[2]),\n      vec2.fromValues(\n        vec2.distance(\n          vec2.fromValues(start[0], start[1]),\n          vec2.fromValues(end[0], end[1])\n        ),\n        end[2]\n      ),\n    ];\n    var elevations = topAndBottomFromProfile(profile);\n\n    return {\n      profilePoints: profile,\n      slopes: slopeFromProfile(profile),\n      top: elevations.top,\n      bottom: elevations.bottom,\n      startElevation: profile[0][1],\n      endElevation: profile[profile.length - 1][1],\n    };\n  }\n}\n\nexport async function addCenterLinesFromCylinders(\n  product: ProductData,\n  centerLines: {\n    start: ReadonlyVec3;\n    end: ReadonlyVec3;\n    radius: number;\n    prev: number | undefined;\n    next: number | undefined;\n  }[],\n  scale: number,\n  setting?: MeasureSettings\n) {\n  const smallLines: {\n    start: vec3;\n    end: vec3;\n    radius: number;\n    checked: boolean\n  }[] = [];\n\n  const faceInstances = new Array<Array<number>>(product.instances.length);\n\n  for (let i = 0; i < product.instances.length; ++i) {\n    const instanceData = product.instances[i];\n    const faces = new Array<number>();\n    function faceFunc(faceIdx: number) {\n      faces.push(faceIdx);\n    }\n\n    if (typeof instanceData.geometry == \"number\") {\n      //check geom is number\n      crawlInstance(product, instanceData, false, faceFunc);\n    }\n    faceInstances[i] = faces;\n  }\n\n  const cylinderMeasureSettings = setting ? setting.cylinderMeasure : \"center\";\n  for (let i = 0; i < faceInstances.length; ++i) {\n    const mat = matFromInstance(product.instances[i]);\n    for (const faceIdx of faceInstances[i]) {\n      const face = product.faces[faceIdx];\n      const surfaceData = product.surfaces[face.surface];\n      if (surfaceData.kind == \"cylinder\") {\n        const [start, end] = await cylinderCenterLine(\n          product,\n          face,\n          surfaceData,\n          mat,\n          cylinderMeasureSettings\n        );\n        const scaledRadius = surfaceData.radius * scale;\n        let add = true;\n        const small = vec3.dist(start, end) < scaledRadius;\n\n        for (let centerline of small ? smallLines : centerLines) {\n          const threshold = Math.abs(centerline.radius - scaledRadius) + 0.15;\n          if (\n            vec3.distance(start, centerline.start) < threshold &&\n            vec3.distance(end, centerline.end) < threshold\n          ) {\n            add = false;\n            if (cylinderMeasureSettings === \"top\") {\n              if (centerline.radius < scaledRadius) {\n                centerline.radius = scaledRadius;\n                centerline.start = start;\n                centerline.end = end;\n              }\n            } else if (centerline.radius > scaledRadius) {\n              centerline.radius = scaledRadius;\n              centerline.start = start;\n              centerline.end = end;\n            }\n            break;\n          }\n        }\n        if (add) {\n          if (small) {\n            smallLines.push({\n              start,\n              end,\n              radius: scaledRadius,\n              checked: false\n            });\n          }\n          else {\n            centerLines.push({\n              start,\n              end,\n              radius: scaledRadius,\n              next: undefined,\n              prev: undefined,\n            });\n          }\n        }\n      }\n    }\n  }\n  for (let i = 0; i < smallLines.length; ++i) {\n    const testLine = smallLines[i];\n    let add = false;\n    if (testLine.checked) {\n      continue;\n    }\n    for (let j = i + 1; j < smallLines.length; ++j) {\n      if (smallLines[j].checked) {\n        continue;\n      }\n      const dist = vec3.dist(smallLines[j].start, testLine.end);\n      const flippedDist = vec3.dist(smallLines[j].end, testLine.end);\n\n      if (dist < testLine.radius && dist < flippedDist) {\n        vec3.copy(testLine.end, smallLines[j].end);\n        smallLines[j].checked = true;\n        j = i + 1;\n        add = true;\n        continue;\n      }\n      if (flippedDist < testLine.radius) {\n        vec3.copy(testLine.end, smallLines[j].start);\n        smallLines[j].checked = true;\n        j = i + 1;\n        add = true;\n        continue;\n      }\n    }\n    if (add) {\n      centerLines.push({\n        start: testLine.start,\n        end: testLine.end,\n        radius: testLine.radius,\n        next: undefined,\n        prev: undefined,\n      });\n    }\n  }\n}\n\nexport function centerLinesToLinesTrip(\n  centerLines: {\n    start: ReadonlyVec3;\n    end: ReadonlyVec3;\n    radius: number;\n    prev: number | undefined;\n    next: number | undefined;\n  }[]\n) {\n  const compare = (\n    a: ReadonlyVec3,\n    radiusA: number,\n    b: ReadonlyVec3,\n    radiusB: number\n  ) => {\n    const dist = vec3.distance(a, b);\n    return dist < (radiusA + radiusB) / 2;\n  };\n\n  let startSegment:\n    | {\n      start: ReadonlyVec3;\n      end: ReadonlyVec3;\n      prev: number | undefined;\n      next: number | undefined;\n    }\n    | undefined = undefined;\n  for (let i = 0; i < centerLines.length; ++i) {\n    const currentSegment = centerLines[i];\n    let findNext = currentSegment.next == undefined;\n    let findPrev = currentSegment.prev == undefined;\n    for (let j = i + 1; j < centerLines.length; ++j) {\n      if (!findPrev && !findNext) {\n        break;\n      }\n      const checkSegment = centerLines[j];\n      if (\n        findPrev &&\n        compare(\n          currentSegment.start,\n          currentSegment.radius,\n          checkSegment.end,\n          checkSegment.radius\n        )\n      ) {\n        checkSegment.next = i;\n        currentSegment.prev = j;\n        findPrev = false;\n      }\n      if (\n        findNext &&\n        compare(\n          currentSegment.end,\n          currentSegment.radius,\n          checkSegment.start,\n          checkSegment.radius\n        )\n      ) {\n        checkSegment.prev = i;\n        currentSegment.next = j;\n        findNext = false;\n      }\n    }\n    if (findNext && i != centerLines.length - 1) {\n      for (let j = i + 1; j < centerLines.length; ++j) {\n        const checkSegment = centerLines[j];\n        if (\n          compare(\n            currentSegment.end,\n            currentSegment.radius,\n            checkSegment.end,\n            checkSegment.radius\n          )\n        ) {\n          const tmp = checkSegment.start;\n          checkSegment.start = checkSegment.end;\n          checkSegment.end = tmp;\n          checkSegment.prev = i;\n          currentSegment.next = j;\n          break;\n        }\n      }\n    }\n    if (findPrev && i != centerLines.length - 1) {\n      for (let j = i + 1; j < centerLines.length; ++j) {\n        const checkSegment = centerLines[j];\n        if (\n          compare(\n            currentSegment.start,\n            currentSegment.radius,\n            checkSegment.start,\n            checkSegment.radius\n          )\n        ) {\n          const tmp = checkSegment.start;\n          checkSegment.start = checkSegment.end;\n          checkSegment.end = tmp;\n          checkSegment.next = i;\n          currentSegment.prev = j;\n          break;\n        }\n      }\n    }\n    if (findPrev) {\n      if (currentSegment.next === undefined ||\n        (startSegment != undefined && startSegment.prev === undefined)) {\n        continue;\n      }\n      startSegment = currentSegment;\n    }\n  }\n  const lineStrip: ReadonlyVec3[] = [];\n  if (startSegment && startSegment.next === undefined) {\n    const len = vec3.distance(startSegment.start, startSegment.end);\n    lineStrip.push(vec3.clone(startSegment.start));\n    lineStrip.push(vec3.clone(startSegment.end));\n  } else if (startSegment && startSegment.next !== undefined) {\n    let workingSegment = startSegment;\n    lineStrip.push(vec3.clone(startSegment.start));\n    lineStrip.push(vec3.clone(startSegment.end));\n    let prevEnd = startSegment.end;\n    while (workingSegment.next !== undefined) {\n      workingSegment = centerLines[workingSegment.next];\n      prevEnd = workingSegment.end;\n      lineStrip.push(vec3.clone(workingSegment.end));\n    }\n  }\n  return lineStrip;\n}\n", "import type { ManholeMeasureValues, ObjectId, PlaneValues } from \"@novorender/measure-api\";\nimport { mat4, ReadonlyVec3, vec3 } from \"gl-matrix\";\nimport type { CylinderData, FaceData, PlaneData, ProductData, SurfaceData } from \"./brep\";\nimport { cylinderLength } from \"./calculations\";\nimport { extractCylinderValues, extractFaceValues, extractPlaneValues } from \"./extract_values\";\nimport { crawlInstance, geometryFactory, matFromInstance, unitToScale } from \"./loader\";\nimport type { Surface } from \"./surfaces\";\n\ntype PlaneEntity = { faceData: FaceData; instanceIdx: number, planeData: SurfaceData, faceIdx: number }\ntype CylinderEntity = { faceData: FaceData; instanceIdx: number, cylinderData: CylinderData, faceIdx: number }\n\nexport async function manholeMeasure(product: ProductData, prodId: ObjectId): Promise<ManholeMeasureValues | undefined> {\n    let top: { elevation: number; entity: PlaneEntity } | undefined = undefined;\n    let botInner: { elevation: number; radius: number | undefined, entity: PlaneEntity } | undefined = undefined;\n    let botOuter: { elevation: number; radius: number | undefined, entity: PlaneEntity } | undefined = undefined;\n    let outer: { radius: number; entity: CylinderEntity } | undefined = undefined;\n    let inner: { radius: number; entity: CylinderEntity } | undefined = undefined;\n\n    const botInnerCandiates: { elevation: number; radius: number | undefined, entity: PlaneEntity }[] = [];\n\n    for (let i = 0; i < product.instances.length; ++i) {\n        const instanceData = product.instances[i];\n        const instanceMat = matFromInstance(instanceData);\n\n        function faceFuncPlane(faceIdx: number) {\n            if (product) {\n                const face = product.faces[faceIdx];\n                let radius: number | undefined = undefined;\n                const outerLoop = product.loops[face.outerLoop];\n                if (outerLoop.halfEdges.length == 1) {\n                    const halfEdge = product.halfEdges[outerLoop.halfEdges[0]];\n                    const edge = product.edges[halfEdge.edge];\n                    if (edge.curve3D != undefined) {\n                        const curve = product.curves3D[edge.curve3D];\n                        if (curve.kind == \"circle\") {\n                            radius = curve.radius;\n                        }\n                    }\n                }\n                const surf = product.surfaces[face.surface];\n                if (surf.kind == \"plane\") {\n                    const transform = mat4.fromValues(\n                        ...(surf.transform as Parameters<typeof mat4.fromValues>)\n                    );\n                    mat4.multiply(transform, instanceMat, transform);\n                    const planeDir = vec3.fromValues(transform[8], transform[9], transform[10]);\n                    if (Math.abs(vec3.dot(planeDir, vec3.fromValues(0, 0, 1))) < 0.8) {\n                        return;\n                    }\n                    const planePos = vec3.fromValues(0, 0, 0);\n                    vec3.transformMat4(planePos, planePos, transform);\n                    if (top === undefined || botInner === undefined || botOuter === undefined) {\n                        top = { elevation: planePos[2], entity: { faceData: face, instanceIdx: i, planeData: surf, faceIdx } };\n                        botInner = { elevation: planePos[2], radius, entity: { faceData: face, instanceIdx: i, planeData: surf, faceIdx } };\n                        botOuter = { elevation: planePos[2], radius, entity: { faceData: face, instanceIdx: i, planeData: surf, faceIdx } };\n                    } else {\n                        if (top.elevation < planePos[2]) {\n                            top = { elevation: planePos[2], entity: { faceData: face, instanceIdx: i, planeData: surf, faceIdx } };\n                        }\n                        else {\n                            let setOuter = false;\n                            if (radius === undefined) {\n                                setOuter = botOuter.elevation > planePos[2]\n                            } else {\n                                if (botOuter.radius == undefined) {\n                                    setOuter = botOuter.elevation > planePos[2];\n                                }\n                                else {\n                                    setOuter = radius > botOuter.radius || (botOuter.radius === radius && botOuter.elevation > planePos[2]);\n                                }\n                            }\n                            if (setOuter) {\n                                botOuter = { elevation: planePos[2], radius, entity: { faceData: face, instanceIdx: i, planeData: surf, faceIdx } };\n                            }\n                            if (radius != undefined) {\n                                botInnerCandiates.push({ elevation: planePos[2], radius, entity: { faceData: face, instanceIdx: i, planeData: surf, faceIdx } });\n                            }\n\n                        }\n                    }\n                }\n            }\n        }\n\n        if (typeof instanceData.geometry == \"number\") {\n            //check geom is number\n            crawlInstance(product, instanceData, false, faceFuncPlane);\n            botInnerCandiates.forEach(plane => {\n                const { radius, elevation } = plane;\n                if (botInner && botOuter && radius) {\n                    let setInner = false;\n                    if (botInner.radius == undefined) {\n                        setInner = radius != undefined || botOuter.elevation > elevation\n                    }\n                    else {\n                        setInner = botOuter.radius != undefined && botOuter.radius >= radius && botInner.elevation > elevation && elevation > botOuter.elevation;\n                    }\n                    if (setInner) {\n                        botInner = plane;\n                    }\n                }\n            });\n        }\n    }\n\n    top = top as { elevation: number; entity: PlaneEntity } | undefined;\n    botOuter = botOuter as { elevation: number; radius: number | undefined, entity: PlaneEntity } | undefined;\n    if (!top || !botOuter) {\n        return undefined;\n    }\n    if (top.elevation == botOuter.elevation) {\n        return undefined;\n    }\n    const totalLength = top.elevation - botOuter.elevation;\n    const scale = unitToScale(product.units);\n    if (totalLength * scale < 0.1) {\n        return undefined;\n    }\n\n    const getCylinderTopBot = (origo: ReadonlyVec3, dir: ReadonlyVec3, l: number, transformElevation: number) => {\n        const flipped = dir[2] <= 0;\n        const t = vec3.scaleAndAdd(vec3.create(), origo, dir, flipped ? l * -1 : l);\n        return t[2] > origo[2] ? [t[2] + transformElevation, origo[2] + transformElevation] : [origo[2] + transformElevation, t[2] + transformElevation];\n    }\n\n\n    let letInnerCylinderTopBot: number[] | undefined = undefined;\n    for (let i = 0; i < product.instances.length; ++i) {\n        const instanceData = product.instances[i];\n        function faceFuncCylinder(faceIdx: number) {\n            if (product) {\n                const face = product.faces[faceIdx];\n                const surf = product.surfaces[face.surface];\n                if (surf.kind == \"cylinder\") {\n                    const cylinderMtx = mat4.fromValues(\n                        ...(surf.transform as Parameters<typeof mat4.fromValues>)\n                    );\n                    const cylinderOrigo = mat4.getTranslation(vec3.create(), cylinderMtx);\n                    const cylinderDir = vec3.fromValues(\n                        cylinderMtx[8],\n                        cylinderMtx[9],\n                        cylinderMtx[10]\n                    );\n\n                    if (Math.abs(vec3.dot(cylinderDir, vec3.fromValues(0, 0, 1))) < 0.8) {\n                        return;\n                    }\n                    const transformElevation = instanceData.transformation ? instanceData.transformation[14] : 0;\n\n                    const len = Math.abs(cylinderLength(product, face, cylinderOrigo, cylinderDir));\n                    if (len > totalLength / 4) {\n                        if (outer == undefined || inner == undefined) {\n                            outer = { radius: surf.radius, entity: { faceData: face, instanceIdx: i, cylinderData: surf, faceIdx } };\n                            inner = { radius: surf.radius, entity: { faceData: face, instanceIdx: i, cylinderData: surf, faceIdx } };\n                            letInnerCylinderTopBot = getCylinderTopBot(cylinderOrigo, cylinderDir, len, transformElevation);\n                        } else {\n                            if (outer.radius < surf.radius) {\n                                outer = { radius: surf.radius, entity: { faceData: face, instanceIdx: i, cylinderData: surf, faceIdx } };\n                            } else if (inner.radius > surf.radius) {\n                                inner = { radius: surf.radius, entity: { faceData: face, instanceIdx: i, cylinderData: surf, faceIdx } };\n                                letInnerCylinderTopBot = getCylinderTopBot(cylinderOrigo, cylinderDir, len, transformElevation);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (typeof instanceData.geometry == \"number\") {\n            //check geom is number\n            crawlInstance(product, instanceData, false, faceFuncCylinder);\n        }\n    }\n\n\n\n    if (top && botOuter && outer && inner && botInner) {\n        const scale = unitToScale(product.units);\n        top = top as { elevation: number; entity: PlaneEntity };\n        const topPlane = (await geometryFactory).getSurface(\n            top.entity.planeData,\n            top.entity.faceData.facing,\n            scale\n        );\n        botOuter = botOuter as { elevation: number; radius: number | undefined, entity: PlaneEntity };\n        botInner = botInner as { elevation: number; radius: number | undefined, entity: PlaneEntity };\n        inner = inner as { radius: number; entity: CylinderEntity };\n        outer = outer as { radius: number; entity: CylinderEntity };\n        const oneCylinder = inner.radius === outer.radius;\n        if (oneCylinder) {\n            botInner = undefined;\n        }\n        else if (letInnerCylinderTopBot) {\n            if (botInner.elevation >= letInnerCylinderTopBot[0]) {\n                botInner = undefined;\n            }\n        }\n\n\n        const botOuterPlane = (await geometryFactory).getSurface(\n            botOuter.entity.planeData,\n            botOuter.entity.faceData.facing,\n            scale\n        );\n\n        const botInnerPlane = botInner ? (await geometryFactory).getSurface(\n            botInner.entity.planeData,\n            botInner.entity.faceData.facing,\n            scale\n        ) : undefined;\n\n        return {\n            drawKind: \"manhole\",\n            ObjectId: prodId,\n            top: await extractPlaneValues(prodId, top.entity.faceIdx, product, top.entity.instanceIdx, top.entity.faceData, topPlane, scale),\n            topElevation: top.elevation,\n            bottomOuter: await extractPlaneValues(prodId, botOuter.entity.faceIdx, product, botOuter.entity.instanceIdx, botOuter.entity.faceData, botOuterPlane, scale),\n            bottomOuterElevation: botOuter.elevation,\n            bottomInner: botInner ? await extractPlaneValues(prodId, botInner.entity.faceIdx, product, botInner.entity.instanceIdx, botInner.entity.faceData, botInnerPlane as Surface, scale) : undefined,\n            bottomInnerElevation: botInner ? botInner.elevation : letInnerCylinderTopBot ? letInnerCylinderTopBot[1] : undefined,\n            inner: oneCylinder ? undefined : await extractCylinderValues(prodId, inner.entity.faceIdx, product, inner.entity.instanceIdx, inner.entity.faceData, inner.entity.cylinderData, scale),\n            innerRadius: oneCylinder ? undefined : inner.radius,\n            outer: await extractCylinderValues(prodId, outer.entity.faceIdx, product, outer.entity.instanceIdx, outer.entity.faceData, outer.entity.cylinderData, scale),\n            outerRadius: outer.radius,\n            internal: {\n                top: top.entity.faceData,\n                bottomOuter: botOuter.entity.faceData,\n                bottomInner: botInner ? botInner.entity.faceData : undefined,\n                inner: oneCylinder ? undefined : inner.entity.faceData,\n                outer: outer.entity.faceData,\n            }\n        }\n    }\n    return undefined;\n}", "import type { DrawObject, DrawPart, DrawVoid, ManholeMeasureValues, MeasureSettings } from \"@novorender/measure-api\";\nimport { ReadonlyVec3, vec2, vec3 } from \"gl-matrix\";\nimport type { CylinderData, FaceData, LoopData, ProductData } from \"./brep\";\nimport { cylinderCenterLine } from \"./calculations\";\nimport { geometryFactory, matFromInstance } from \"./loader\";\nimport { getEdgeStrip } from \"./outline\";\n\nexport async function getCylinderDrawParts(product: ProductData, instanceIdx: number, cylinderData: CylinderData,\n    face: FaceData, setting?: MeasureSettings) {\n    const drawParts: DrawPart[] = [];\n    const loop = product.loops[face.outerLoop];\n    const mat = matFromInstance(product.instances[instanceIdx]);\n    const [cylinderOrigo, cylinderEnd] = await cylinderCenterLine(\n        product,\n        face,\n        cylinderData,\n        mat,\n        setting ? setting.cylinderMeasure : \"center\"\n    );\n    const diff = vec3.sub(vec3.create(), cylinderEnd, cylinderOrigo);\n    const length = vec3.length(diff);\n    const planarLength = vec2.len(vec2.fromValues(diff[0], diff[1]));\n    const epsilon = 1e-3;\n    const dir = vec3.normalize(vec3.create(), diff);\n    const vertical = Math.abs(Math.abs(dir[2]) - 1) < epsilon;\n    drawParts.push({\n        vertices3D: [cylinderOrigo, cylinderEnd],\n        drawType: \"lines\",\n        elevation: {\n            from: cylinderOrigo[1],\n            to: cylinderEnd[1],\n            horizontalDisplay: diff[2] < planarLength,\n        },\n        text: [[`L ${length.toFixed(3)}m   \u2300 ${(cylinderData.radius * 2).toFixed(3)}m   ${vertical ? \"\" : `% ${((Math.abs(diff[2] / planarLength)) * 100).toFixed(2)}`}`]]\n    });\n    for (const halfEdgeIdx of loop.halfEdges) {\n        const halfEdgeData = product.halfEdges[halfEdgeIdx];\n        const edgeData = product.edges[halfEdgeData.edge];\n        if (edgeData.virtual) {\n            continue;\n        }\n        const edgeCurve = (await geometryFactory).getCurve3DFromEdge(\n            product,\n            halfEdgeData.edge\n        );\n        if (edgeCurve) {\n            const edge = {\n                curve: edgeCurve,\n                geometryTransformation: matFromInstance(\n                    product.instances[instanceIdx]\n                ),\n                instanceIndex: instanceIdx,\n            };\n            drawParts.push({\n                vertices3D: getEdgeStrip(edge, 1),\n                drawType: \"lines\",\n            });\n        }\n    }\n\n    drawParts.push({ drawType: 'text', vertices3D: [cylinderEnd], text: `Z: ${cylinderEnd[2].toFixed(3)}m` })\n    drawParts.push({ drawType: 'text', vertices3D: [cylinderOrigo], text: `Z: ${cylinderOrigo[2].toFixed(3)}m` })\n\n    return drawParts;\n}\n\nexport async function getSurfaceDrawParts(product: ProductData, instanceIdx: number, face: FaceData) {\n    const loop = product.loops[face.outerLoop];\n    const drawParts: DrawPart[] = [];\n    async function loopToVertices(loop: LoopData): Promise<{ vertices: ReadonlyVec3[], text: string[] }> {\n        const vertices: ReadonlyVec3[] = [];\n        const text: string[] = [];\n        if (product) {\n            let first = true;\n            for (const halfEdgeIdx of loop.halfEdges) {\n                const halfEdgeData = product.halfEdges[halfEdgeIdx];\n\n                const edgeCurve = (await geometryFactory).getCurve3DFromEdge(\n                    product,\n                    halfEdgeData.edge\n                );\n                if (edgeCurve) {\n                    const useLabels = edgeCurve.kind == \"line\" || edgeCurve.kind == \"lineStrip\" || edgeCurve.kind == \"nurbs\";\n                    const edge = {\n                        curve: edgeCurve,\n                        geometryTransformation: matFromInstance(\n                            product.instances[instanceIdx]\n                        ),\n                        instanceIndex: instanceIdx,\n                    };\n                    const edgeStrip = getEdgeStrip(edge, halfEdgeData.direction);\n                    let i = first ? 0 : 1;\n                    const startIdx = first ? 0 : vertices.length - 1;\n                    first = false;\n                    for (; i < edgeStrip.length; ++i) {\n                        vertices.push(edgeStrip[i]);\n                        if (i == 0 && startIdx == 0) {\n                            continue;\n                        }\n                        if (useLabels) {\n                            text.push(vec3.dist(vertices[startIdx + i - 1], vertices[startIdx + i]).toFixed(3));\n                        } else {\n                            text.push(\"\");\n                        }\n                    }\n                }\n            }\n        }\n        return { vertices, text };\n    }\n\n    const text: string[][] = [];\n    const { vertices: outerVerts, text: outerTexts } = await loopToVertices(loop);\n    text.push(outerTexts);\n\n    const voids: DrawVoid[] = [];\n    if (face.innerLoops) {\n        for (const innerLoopIdx of face.innerLoops) {\n            const innerLoop = product.loops[innerLoopIdx];\n            const { vertices: innerVerts, text: innerTexts } = await loopToVertices(innerLoop);\n            text.push(innerTexts);\n            voids.push({ vertices3D: innerVerts });\n        }\n    }\n    drawParts.push({ vertices3D: outerVerts, drawType: \"filled\", voids, text: text.length > 0 ? text : undefined });\n    return drawParts;\n}\n\nexport async function getManholeDrawObjects(product: ProductData, manhole: ManholeMeasureValues) {\n    const drawObjects: DrawObject[] = [];\n    drawObjects.push({\n        kind: \"plane\", parts: await getSurfaceDrawParts(product, manhole.top.entity!.instanceIndex, manhole.internal.top)\n    });\n    drawObjects.push({\n        kind: \"plane\", parts: await getSurfaceDrawParts(product, manhole.bottomOuter.entity!.instanceIndex, manhole.internal.bottomOuter)\n    });\n    if (manhole.bottomInner && manhole.internal.bottomInner) {\n        drawObjects.push({\n            kind: \"plane\", parts: await getSurfaceDrawParts(product, manhole.bottomInner.entity!.instanceIndex, manhole.internal.bottomInner)\n        });\n    }\n    const outerCylinder = product.surfaces[manhole.internal.outer.surface] as CylinderData;\n    drawObjects.push({\n        kind: \"plane\", parts: await getCylinderDrawParts(product, manhole.outer.entity!.instanceIndex, outerCylinder, manhole.internal.outer)\n    });\n    if (manhole.internal.inner && manhole.inner) {\n        const innerCylinder = product.surfaces[manhole.internal.inner.surface] as CylinderData;\n        drawObjects.push({\n            kind: \"plane\", parts: await getCylinderDrawParts(product, manhole.inner.entity!.instanceIndex, innerCylinder, manhole.internal.inner)\n        });\n    }\n    return drawObjects;\n}\n", "import type { CollisionValues, MeasureSettings } from \"@novorender/measure-api\";\nimport { mat4, vec3, vec4 } from \"gl-matrix\";\nimport type { CylinderData, FaceData, ProductData } from \"./brep\";\nimport { cylinderCenterLine, fullCircleCylinder } from \"./calculations\";\nimport { geometryFactory, matFromInstance, unitToScale } from \"./loader\";\n\nexport async function getFaceToFaceCollisionValues(\n    productA: ProductData,\n    faceIdxA: number,\n    instanceIdxA: number,\n    productB: ProductData,\n    faceIdxB: number,\n    instanceIdxB: number,\n    setting?: MeasureSettings\n): Promise<CollisionValues | undefined> {\n    const faceDataA = productA.faces[faceIdxA];\n    const surfaceDataA = productA.surfaces[faceDataA.surface];\n    let surfaceA = {\n        surf: (await geometryFactory).getSurface(surfaceDataA, 1),\n        instanceIdx: instanceIdxA,\n        faceData: faceDataA,\n        data: surfaceDataA,\n        product: productA,\n    };\n\n    const faceDataB = productB.faces[faceIdxB];\n    const surfaceDataB = productB.surfaces[faceDataB.surface];\n    let surfaceB = {\n        surf: (await geometryFactory).getSurface(surfaceDataB, 1),\n        instanceIdx: instanceIdxB,\n        faceData: faceDataB,\n        data: surfaceDataB,\n        product: productB,\n    };\n    if (surfaceA.surf && surfaceB.surf) {\n        if (surfaceA.surf.kind == \"cylinder\" && surfaceB.surf.kind == \"cylinder\") {\n            if (!fullCircleCylinder(productA, faceDataA) || !fullCircleCylinder(productB, faceDataB)) {\n                return undefined;\n            }\n            const cylinderA = surfaceA.data as CylinderData;\n            const matA = matFromInstance(\n                surfaceA.product.instances[surfaceA.instanceIdx]\n            );\n\n            const cylinderB = surfaceB.data as CylinderData;\n            const matB = matFromInstance(\n                surfaceB.product.instances[surfaceB.instanceIdx]\n            );\n\n            return getCylinderToCylnderCollisionValues(cylinderA,\n                matA,\n                surfaceA.product,\n                surfaceA.faceData,\n                unitToScale(surfaceA.product.units),\n                cylinderB,\n                matB,\n                surfaceB.product,\n                surfaceB.faceData,\n                unitToScale(surfaceB.product.units),\n                setting);\n        }\n    }\n    return undefined;\n\n}\n\ntype Ray = {\n    start: vec3;\n    dir: vec3;\n}\n\nfunction rayCyllinderCollision(ray: Ray, cylinderStart: vec3, cylinderDir: vec3, cylinderRad: number): vec3 | undefined {\n    const parallel = vec3.equals(ray.dir, cylinderDir);\n    if (parallel) { //Valid collision for parallel cylinders is probably unlikely so not handled\n        return undefined;\n    }\n\n    const rc = vec3.sub(vec3.create(), ray.start, cylinderStart);\n    const n = vec3.cross(vec3.create(), ray.dir, cylinderDir);\n    const ln = vec3.len(n);\n    vec3.normalize(n, n);\n    const d = Math.abs(vec3.dot(rc, n));\n    if (d <= cylinderRad) {\n        const o = vec3.cross(vec3.create(), rc, cylinderDir);\n        const t = -vec3.dot(o, n) / ln;\n        const o2 = vec3.cross(vec3.create(), n, cylinderDir)\n        vec3.normalize(o2, o2);\n        const s = Math.abs(Math.sqrt(cylinderRad * cylinderRad - d * d) / vec3.dot(ray.dir, o2));\n        const tIn = t - s;\n        const tOut = t + s;\n        const param = tIn < tOut ? tIn : tOut;\n        const centerCol = vec3.scaleAndAdd(vec3.create(), ray.start, ray.dir, param);\n        return centerCol;\n    }\n    return undefined;\n}\n\nasync function getCylinderToCylnderCollisionValues(\n    cylinderA: CylinderData,\n    matA: mat4,\n    productA: ProductData,\n    faceDataA: FaceData,\n    scaleA: number,\n    cylinderB: CylinderData,\n    matB: mat4,\n    productB: ProductData,\n    faceDataB: FaceData,\n    scaleB: number,\n    setting?: MeasureSettings\n): Promise<CollisionValues | undefined> {\n    const tolerance = 0.5;\n    const [cylinderStartA, cylinderEndA] = await cylinderCenterLine(\n        productA,\n        faceDataA,\n        cylinderA,\n        matA,\n    );\n    const dirA = vec3.sub(vec3.create(), cylinderEndA, cylinderStartA);\n    vec3.normalize(dirA, dirA);\n\n    const [cylinderStartB, cylinderEndB] = await cylinderCenterLine(\n        productB,\n        faceDataB,\n        cylinderB,\n        matB,\n    );\n    const dirB = vec3.sub(vec3.create(), cylinderEndB, cylinderStartB);\n    vec3.normalize(dirB, dirB);\n\n    const radB = cylinderB.radius * scaleB;\n    const radA = cylinderA.radius * scaleA;\n    const ray = { start: cylinderStartA, dir: dirA };\n    if (vec3.dist(ray.start, cylinderStartB) < vec3.dist(cylinderEndA, cylinderStartB)) { //inside so need to flip\n        ray.start = cylinderEndA;\n        vec3.negate(ray.dir, ray.dir);\n    }\n\n    if (Math.abs(vec3.dot(ray.dir, dirB)) > 0.99) {\n        return undefined;\n    }\n\n    const colCenter = rayCyllinderCollision(ray, cylinderStartB, dirB, radB);\n    if (colCenter) {\n        const cylLen = vec3.dist(cylinderStartA, cylinderEndA) + tolerance;\n        const p = vec4.fromValues(ray.dir[0], ray.dir[1], ray.dir[2], - vec3.dot(colCenter, ray.dir));\n        if (Math.abs(vec4.dot(p, vec4.fromValues(ray.start[0], ray.start[1], ray.start[2], 1))) > cylLen) {\n            return undefined;\n        }\n        if (!setting || setting?.cylinderMeasure === \"center\") {\n            return { point: colCenter };\n        }\n        let side = vec3.fromValues(1, 0, 0);\n        if (vec3.dot(ray.dir, side) === 1) {\n            side = vec3.fromValues(0, 0, 1);\n        }\n        const up = vec3.cross(vec3.create(), ray.dir, side);\n        vec3.normalize(up, up);\n        const d = 1 / Math.abs(vec3.dot(up, dirB));\n        if (setting.cylinderMeasure === \"top\") {\n            const top = vec3.scaleAndAdd(vec3.create(), colCenter, dirB, radA * d);\n            return { point: top };\n\n        }\n        const bottom = vec3.scaleAndAdd(vec3.create(), colCenter, dirB, -radA * d);\n        return { point: bottom };\n    }\n    return undefined;\n}", "import type { MeasureEntity, PointEntity, SnapTolerance } from \"@novorender/measure-api\";\nimport { mat4, ReadonlyMat4, ReadonlyVec3, vec2, vec3 } from \"gl-matrix\";\nimport type { AABB3, EdgeData, ProductData } from \"./brep\";\nimport { isInsideAABB } from \"./calculations\";\nimport type { Line3D, Arc3D, NurbsCurve3D, LineStrip3D, Curve3D } from \"./curves\";\nimport { crawlInstance, geometryFactory, matFromInstance, unitToScale } from \"./loader\";\nimport type { Surface } from \"./surfaces\";\n\nexport interface EntityPicker {\n    instanceIdx: number;\n    worldToObject: ReadonlyMat4;\n}\n\n\nexport interface EdgePickInfo {\n    idx: number;\n    curve: Curve3D;\n    data: EdgeData;\n}\n\nexport interface SegmentPickInfo {\n    idx: number;\n    readonly curve: Curve3D;\n}\n\nexport interface PickSegments extends EntityPicker {\n    segments: SegmentPickInfo[];\n}\n\nexport interface PickEdges extends EntityPicker {\n    instanceMat: ReadonlyMat4;\n    edges: EdgePickInfo[];\n}\n\nexport interface FacePickInfo {\n    idx: number;\n    aabb: AABB3;\n    surface: Surface;\n}\n\nexport interface PickFaces extends EntityPicker {\n    instanceMat: ReadonlyMat4;\n    faces: FacePickInfo[];\n}\n\nexport interface PickInterface {\n    objectId: number;\n    unitScale: number;\n    segments: PickSegments[];\n    edges: PickEdges[];\n    faces: PickFaces[];\n}\n\nexport async function getPickInterface(product: ProductData, objectId: number): Promise<PickInterface> {\n    const edgeInstances = new Array<Array<number>>(product.instances.length);\n    const faceInstances = new Array<Array<number>>(product.instances.length);\n    const curveSegmentInstances = new Array<readonly number[]>(\n        product.instances.length\n    );\n\n    for (let i = 0; i < product.instances.length; ++i) {\n        const instanceData = product.instances[i];\n\n        const edges = new Array<number>();\n        const faces = new Array<number>();\n\n        function faceFunc(faceIdx: number) {\n            faces.push(faceIdx);\n            if (product) {\n                const face = product.faces[faceIdx];\n                const loops = [face.outerLoop, ...(face.innerLoops ?? [])];\n                for (const loopIdx of loops) {\n                    const loop = product.loops[loopIdx];\n                    for (const halfEdgeIdx of loop.halfEdges) {\n                        const halfEdge = product.halfEdges[halfEdgeIdx];\n                        edges.push(halfEdge.edge);\n                    }\n                }\n            }\n        }\n\n        if (typeof instanceData.geometry == \"number\") {\n            //check geom is number\n            crawlInstance(product, instanceData, false, faceFunc);\n        }\n        const geometryData =\n            product.geometries[instanceData.geometry as number];\n        if (geometryData.compoundCurve) {\n            curveSegmentInstances[i] = geometryData.compoundCurve;\n        } else {\n            curveSegmentInstances[i] = [];\n        }\n\n        edgeInstances[i] = edges;\n        faceInstances[i] = faces;\n    }\n\n    const segments: PickSegments[] = [];\n    for (let i = 0; i < curveSegmentInstances.length; ++i) {\n        const instanceData = product.instances[i];\n        const instanceMat = matFromInstance(instanceData);\n        const worldToObject = mat4.invert(mat4.create(), instanceMat);\n        const curves: SegmentPickInfo[] = [];\n\n        for (const segmentIdx of curveSegmentInstances[i]) {\n            const curve = (await geometryFactory).getCurve3DFromSegment(\n                product,\n                segmentIdx\n            );\n            if (curve) {\n                curves.push({ idx: segmentIdx, curve: curve as Curve3D })\n            }\n        }\n        if (curves.length > 0) {\n            segments.push({ segments: curves, instanceIdx: i, worldToObject });\n        }\n    }\n\n    const edges: PickEdges[] = [];\n    for (let i = 0; i < edgeInstances.length; ++i) {\n        const InstanceData = product.instances[i];\n        const instanceMat = matFromInstance(InstanceData);\n        const worldToObject = mat4.invert(mat4.create(), instanceMat);\n\n        const curves: EdgePickInfo[] = [];\n        for (const edgeIdx of edgeInstances[i]) {\n            const edgeData = product.edges[edgeIdx];\n            if (edgeData.virtual) {\n                continue;\n            }\n            const curve = (await geometryFactory).getCurve3DFromEdge(\n                product,\n                edgeIdx,\n                1\n            );\n            if (curve) {\n                curves.push({ data: edgeData, idx: edgeIdx, curve: curve as Curve3D });\n            }\n        }\n        if (curves.length > 0) {\n            edges.push({ instanceIdx: i, worldToObject, instanceMat, edges: curves })\n        }\n    }\n\n    const faces: PickFaces[] = [];\n    for (let i = 0; i < faceInstances.length; ++i) {\n        const InstanceData = product.instances[i];\n        const instanceMat = matFromInstance(InstanceData);\n        const worldToObject = mat4.invert(mat4.create(), instanceMat);\n        const surfaces: FacePickInfo[] = [];\n        for (const faceIdx of faceInstances[i]) {\n            const faceData = product.faces[faceIdx];\n            const surfaceData = product.surfaces[faceData.surface];\n            const surface = (await geometryFactory).getSurface(surfaceData, 1);\n            surfaces.push({ aabb: faceData.aabb, idx: faceIdx, surface: surface as Surface })\n        }\n        faces.push({ instanceIdx: i, worldToObject, faces: surfaces, instanceMat });\n    }\n\n    return { objectId, edges, segments, faces, unitScale: unitToScale(product.units) };\n}\n\nexport function pick(pickInterface: PickInterface, position: ReadonlyVec3, tolerance: SnapTolerance): { entity: MeasureEntity, connectionPoint: vec3 } | undefined {\n    const flippedPos = vec3.copy(vec3.create(), position);\n    const edgeTolerance = tolerance.edge ? tolerance.edge / pickInterface.unitScale : undefined;\n    const segmentTolerance = tolerance.segment ? tolerance.segment / pickInterface.unitScale : undefined;\n    const faceTolerance = tolerance.face ? tolerance.face / pickInterface.unitScale : undefined;\n    const pointTolerance = tolerance.point ? tolerance.point / pickInterface.unitScale : undefined;\n\n    if (segmentTolerance) {\n        for (const instanceSeg of pickInterface.segments) {\n            const localPoint = vec3.transformMat4(\n                vec3.create(),\n                flippedPos,\n                instanceSeg.worldToObject\n            );\n            for (const seg of instanceSeg.segments) {\n                const t = seg.curve.invert(localPoint);\n                const curvePoint = vec3.create();\n                seg.curve.eval(t, curvePoint, undefined);\n                const dist = vec3.dist(curvePoint, localPoint);\n                if (dist < segmentTolerance) {\n                    return {\n                        entity: {\n                            ObjectId: pickInterface.objectId,\n                            drawKind: \"curveSegment\",\n                            pathIndex: seg.idx,\n                            instanceIndex: instanceSeg.instanceIdx,\n                            parameter: t,\n                        },\n                        connectionPoint: curvePoint\n                    };\n                }\n            }\n        }\n    }\n\n    let closestCandidate: { entity: MeasureEntity, connectionPoint: vec3 } | undefined = undefined;\n    let closestDistance = Number.MAX_VALUE;\n    let pointSelected = false;\n\n    if (edgeTolerance || pointTolerance) {\n        let aabbTol = 0;\n        if (edgeTolerance && pointTolerance) {\n            aabbTol = pointTolerance > edgeTolerance ? pointTolerance : edgeTolerance;\n        } else {\n            aabbTol = edgeTolerance ? edgeTolerance : pointTolerance ? pointTolerance : 0;\n        }\n        for (const instanceEdge of pickInterface.edges) {\n            const localPoint = vec3.transformMat4(\n                vec3.create(),\n                flippedPos,\n                instanceEdge.worldToObject\n            );\n            for (const edge of instanceEdge.edges) {\n                if (isInsideAABB(localPoint, edge.data.aabb, aabbTol)) {\n                    const t = edge.curve.invert(localPoint);\n                    const curvePoint = vec3.create();\n                    if (edge.data.vertices && edge.curve.kind != \"arc\" && pointTolerance) {\n                        const distToStart = Math.abs(edge.data.parameterBounds[0] - t);\n                        if (distToStart < pointTolerance && distToStart < closestDistance) {\n\n                            edge.curve.eval(\n                                edge.data.parameterBounds[0],\n                                curvePoint,\n                                undefined\n                            );\n                            const actualDistance = vec3.dist(curvePoint, localPoint);\n                            if (actualDistance < pointTolerance && actualDistance < closestDistance) {\n                                pointSelected = true;\n                                closestDistance = actualDistance;\n                                vec3.transformMat4(curvePoint, curvePoint, instanceEdge.instanceMat);\n                                closestCandidate = {\n                                    entity: {\n                                        ObjectId: pickInterface.objectId,\n                                        drawKind: \"vertex\",\n                                        pathIndex: edge.data.vertices[0],\n                                        instanceIndex: instanceEdge.instanceIdx,\n                                        parameter: vec3.clone(curvePoint),\n                                    },\n                                    connectionPoint: vec3.clone(curvePoint)\n                                }\n                            }\n                            const distToEnd = Math.abs(edge.data.parameterBounds[1] - t);\n                            if (distToEnd < pointTolerance && distToEnd < closestDistance) {\n                                edge.curve.eval(\n                                    edge.data.parameterBounds[1],\n                                    curvePoint,\n                                    undefined\n                                );\n                                const actualDistance = vec3.dist(curvePoint, localPoint);\n                                if (actualDistance < pointTolerance && actualDistance < closestDistance) {\n                                    pointSelected = true;\n                                    closestDistance = actualDistance;\n                                    vec3.transformMat4(curvePoint, curvePoint, instanceEdge.instanceMat);\n                                    closestCandidate = {\n                                        entity: {\n                                            ObjectId: pickInterface.objectId,\n                                            drawKind: \"vertex\",\n                                            pathIndex: edge.data.vertices[1],\n                                            instanceIndex: instanceEdge.instanceIdx,\n                                            parameter: vec3.clone(curvePoint),\n                                        },\n                                        connectionPoint: vec3.clone(curvePoint)\n                                    };\n                                }\n                            }\n                        }\n                    }\n                    if (!pointSelected && edgeTolerance) {\n                        edge.curve.eval(t, curvePoint, undefined);\n                        const dist = vec3.dist(curvePoint, localPoint);\n                        if (dist < edgeTolerance && dist < closestDistance) {\n                            closestDistance = dist;\n                            vec3.transformMat4(curvePoint, curvePoint, instanceEdge.instanceMat);\n                            closestCandidate = {\n                                entity: {\n                                    ObjectId: pickInterface.objectId,\n                                    drawKind: \"edge\",\n                                    pathIndex: edge.idx,\n                                    instanceIndex: instanceEdge.instanceIdx,\n                                    parameter: t,\n                                },\n                                connectionPoint: curvePoint\n                            };\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (closestCandidate) {\n        return closestCandidate;\n    }\n\n    if (faceTolerance) {\n        for (const faceInstance of pickInterface.faces) {\n            const localPoint = vec3.transformMat4(\n                vec3.create(),\n                flippedPos,\n                faceInstance.worldToObject\n            );\n            for (const face of faceInstance.faces) {\n                if (isInsideAABB(localPoint, face.aabb, faceTolerance)) {\n                    const uv = vec2.create();\n                    face.surface.invert(uv, localPoint);\n                    const surfacePoint = vec3.create();\n                    face.surface.evalPosition(surfacePoint, uv);\n\n                    const dist = vec3.dist(surfacePoint, localPoint);\n                    if (dist < closestDistance && dist < faceTolerance) {\n                        vec3.transformMat4(surfacePoint, surfacePoint, faceInstance.instanceMat);\n                        closestCandidate = {\n                            entity: {\n                                ObjectId: pickInterface.objectId,\n                                drawKind: \"face\",\n                                pathIndex: face.idx,\n                                instanceIndex: faceInstance.instanceIdx,\n                                parameter: uv,\n                            },\n                            connectionPoint: surfacePoint\n                        };\n                        closestDistance = dist;\n                    }\n                }\n            }\n        }\n    }\n    return closestCandidate;\n}", "import type { CrossSlope, RoadCrossSection, RoadProfile, RoadProfiles } from \"@novorender/measure-api\";\nimport { mat3, ReadonlyVec3, vec2, vec3 } from \"gl-matrix\";\nimport { Downloader } from \"../util\";\nimport type { CrossSections } from \"./cross_section\";\n\nexport class RoadTool {\n    data = new Map<string, CrossSections | null>();\n    readonly downloader;\n    constructor(readonly baseUrl: URL) {\n        const crossUrl = baseUrl;\n        crossUrl.pathname += \"road/\";\n        this.downloader = new Downloader(crossUrl);\n    }\n\n    findShoulderIndex(codes: number[]) {\n        let leftShoulder = 0;\n        let rightShoulder = 0;\n        let handleLeft = true;\n        for (let i = 0; i < codes.length; ++i) {\n            const code = codes[i];\n            if (code == 10) {\n                handleLeft = false;\n            }\n            if (code == 2) {\n                if (handleLeft) {\n                    leftShoulder = i;\n                } else {\n                    rightShoulder = i;\n                    break;\n                }\n            }\n        }\n        return { leftShoulder, rightShoulder }\n    }\n\n    async downloadSections(name: string): Promise<CrossSections | null> {\n        try {\n            return await this.downloader.downloadJson(name);\n        } catch {\n            return null;\n        }\n    }\n\n    private async getCrossSections(name: string): Promise<CrossSections | undefined> {\n        if (this.data.size > 20) {\n            this.data.clear();\n        }\n        let crossSection = this.data.get(name);\n        if (crossSection === undefined) {\n            crossSection = await this.downloadSections(`${name}.json`);\n            this.data.set(name, crossSection);\n        }\n        return crossSection ?? undefined;\n    }\n\n    async getCrossSection(name: string, param: number): Promise<RoadCrossSection | undefined> {\n        const crossSections = await this.getCrossSections(name);\n        if (crossSections) {\n            const { intervals, sections, labels, codes } = crossSections;\n\n            let left: number = 0;\n            let right: number = intervals.length - 1;\n\n            const sectionFromIndex = (index: number) => {\n                if (index !== 0 && labels[sections[index - 1].l].length === 1) {\n                    return undefined\n                }\n\n                let pts: ReadonlyVec3[];\n                let centerDir: vec3;\n                const sec = sections[index];\n                const centerIdx = crossSections.codes[sec.l].findIndex((c) => c == 10);\n                const currCenter = sec.p[centerIdx];\n                if (index == 0) {\n                    pts = sec.p;\n                    const nextSec = sections[index + 1];\n                    const nextCenterIdx = nextSec.l == sec.l ? centerIdx : crossSections.codes[nextSec.l].findIndex((c) => c == 10);\n                    const nextCenter = nextSec.p[nextCenterIdx];\n                    centerDir = vec3.sub(vec3.create(), nextCenter, currCenter);\n                    vec3.normalize(centerDir, centerDir);\n                } else {\n                    const internalParam = Math.abs(param - intervals[index - 1]);\n                    if (internalParam > 10) {\n                        return undefined;\n                    }\n                    const prevSec = sections[index - 1];\n                    const nextCenterIdx = prevSec.l == sec.l ? centerIdx : crossSections.codes[prevSec.l].findIndex((c) => c == 10);\n                    const prevCenter = prevSec.p[nextCenterIdx];\n                    centerDir = vec3.sub(vec3.create(), currCenter, prevCenter);\n                    vec3.normalize(centerDir, centerDir);\n\n                    pts = prevSec.l == sec.l ? prevSec.p.map((p, i) => {\n                        const nextP = sec.p[i];\n                        const dir = vec3.sub(vec3.create(), nextP, p);\n                        vec3.normalize(dir, dir);\n                        return vec3.scaleAndAdd(vec3.create(), p, dir, internalParam);\n                    }) : sec.p;\n                }\n                const up = vec3.fromValues(0, 0, 1);\n                const right = vec3.cross(vec3.create(), up, centerDir);\n                vec3.normalize(right, right);\n                vec3.cross(centerDir, right, up);\n                vec3.normalize(centerDir, centerDir);\n                const mat = mat3.fromValues(\n                    right[0], right[1], right[2],\n                    up[0], up[1], up[2],\n                    centerDir[0], centerDir[1], centerDir[2]\n                );\n\n                const points2D = pts.map((p) => {\n                    const _p = vec3.transformMat3(vec3.create(), p, mat);\n                    return vec2.fromValues(_p[0], _p[1]);\n                });\n\n                const points = pts.map((p) => {\n                    const _p = vec3.clone(p);\n                    return _p;\n                });\n\n                const sectionCodes = codes[sec.l];\n\n                const { leftShoulder, rightShoulder } = this.findShoulderIndex(sectionCodes)\n                const cp = vec3.clone(pts[centerIdx]);\n                const lp = vec3.clone(pts[leftShoulder]);\n                const rp = vec3.clone(pts[rightShoulder]);\n\n                const cp2d = vec2.fromValues(cp[0], cp[1]);\n                const lp2d = vec2.fromValues(lp[0], lp[1]);\n                const rp2d = vec2.fromValues(rp[0], rp[1]);\n                const slopeL = Math.abs(cp[2] - lp[2]) / vec2.dist(cp2d, lp2d);\n                const slopeR = Math.abs(cp[2] - rp[2]) / vec2.dist(cp2d, rp2d);\n\n                const slopes = {\n                    left: { slope: slopeL, start: lp, end: cp },\n                    right: { slope: slopeR, start: cp, end: rp }\n                };\n\n                return { points, labels: labels[sec.l], points2D, slopes, codes: sectionCodes };\n            }\n\n            while (left <= right) {\n                const mid: number = Math.floor((left + right) / 2);\n                const midParam = intervals[mid];\n                if (mid === intervals.length - 1) {\n                    if (midParam < param) {\n                        return sectionFromIndex(mid);\n                    }\n                    return undefined;\n                }\n                if (Math.abs(midParam - param) < 0.001) {\n                    return sectionFromIndex(mid);\n                }\n                if (param < midParam) {\n                    right = mid - 1;\n                }\n                else {\n                    const nextParam = intervals[mid + 1];\n                    if (param < nextParam) {\n                        return sectionFromIndex(mid + 1);\n                    }\n                    left = mid + 1;\n                }\n\n            }\n        }\n    }\n\n    async getRoadProfiles(name: string): Promise<RoadProfiles | undefined> {\n        const crossSections = await this.getCrossSections(name);\n        if (crossSections) {\n            if (crossSections.heightmaps.length != 0) {\n                const profiles: RoadProfile[] = [];\n                profiles.push({ name: crossSections.name, elevations: crossSections.centerLine.map(p => p[2]) });\n                for (const map of crossSections.heightmaps) {\n                    profiles.push(map);\n                }\n            }\n        }\n        return undefined;\n    }\n\n    async getCrossSlope(name: string): Promise<CrossSlope | undefined> {\n        const crossSections = await this.getCrossSections(name);\n        if (crossSections) {\n            const left: number[] = [];\n            const right: number[] = [];\n            crossSections.sections.forEach(section => {\n                const sectionCodes = crossSections.codes[section.l];\n                const { leftShoulder, rightShoulder } = this.findShoulderIndex(sectionCodes);\n                const centerIdx = sectionCodes.findIndex((c) => c == 10);\n                const cp = vec3.clone(section.p[centerIdx]);\n                const lp = vec3.clone(section.p[leftShoulder]);\n                const rp = vec3.clone(section.p[rightShoulder]);\n\n                const cp2d = vec2.fromValues(cp[0], cp[1]);\n                const lp2d = vec2.fromValues(lp[0], lp[1]);\n                const rp2d = vec2.fromValues(rp[0], rp[1]);\n                left.push(cp[2] - lp[2] / vec2.dist(cp2d, lp2d));\n                right.push(cp[2] - rp[2] / vec2.dist(cp2d, rp2d));\n            });\n            return { intervals: crossSections.intervals, left, right };\n        }\n        return undefined;\n    }\n\n    // async getRoadProfiles(name: string): Promise<RoadProfiles | undefined> {\n    //     const crossSections = await this.getCrossSections(name);\n    //     if (crossSections) {\n\n    //         const profiles: RoadProfile[] = [];\n\n    //         const addOrAppend = (codes: number[], points: ReadonlyVec2[][], labels: string[]) => {\n    //             for (let i = 0; i < codes.length; ++i) {\n    //                 const side = codes[i] == 10 ? \"center\" : labels[i][0] === '-' ? \"left\" : \"right\";\n    //                 const p = profiles.find((p) => p.code == codes[i] && p.side == side && p.label == labels[i]);\n    //                 if (p) {\n    //                     p.points.push(...points[i]);\n    //                 } else {\n    //                     profiles.push({ code: codes[i], label: labels[i], points: points[i], side });\n    //                 }\n    //             }\n    //         }\n\n    //         let currentCodes = crossSections.codes[0];\n    //         let currentLabels = crossSections.labels[0];\n    //         let currentPoints: ReadonlyVec2[][] = [];\n    //         let currentLabelsIdx = 0;\n    //         for (let i = 0; i < crossSections.intervals.length; ++i) {\n    //             const section = crossSections.sections[i];\n    //             if (currentLabelsIdx != section.l) {\n    //                 addOrAppend(currentCodes, currentPoints, currentLabels);\n    //                 currentCodes = crossSections.codes[section.l];\n    //                 currentLabels = crossSections.labels[section.l];\n    //                 currentLabelsIdx = section.l\n    //                 currentPoints = [];\n    //             }\n    //             if (currentPoints.length == 0) {\n    //                 for (let j = 0; j < section.p.length; ++j) {\n    //                     currentPoints.push([]);\n    //                 }\n    //             }\n    //             const currentParam = crossSections.intervals[i];\n    //             for (let j = 0; j < section.p.length; ++j) {\n    //                 currentPoints[j].push(vec2.fromValues(currentParam, section.p[j][2]));\n    //             }\n    //         }\n    //         addOrAppend(currentCodes, currentPoints, currentLabels);\n    //         return { name: crossSections.centerLine, profiles };\n    //     }\n    // }\n}", "import {\n  glMatrix,\n  mat3,\n  mat4,\n  ReadonlyMat4,\n  ReadonlyVec2,\n  ReadonlyVec3,\n  vec2,\n  vec3,\n} from \"gl-matrix\";\nimport type {\n  BrepStatus,\n  CollisionValues,\n  CrossSlope,\n  DrawObject,\n  DrawPart,\n  DuoMeasurementValues,\n  ManholeMeasureValues,\n  MeasureEntity,\n  MeasureSettings,\n  ObjectId,\n  RoadCrossSection,\n  RoadProfiles,\n  SnapTolerance,\n} from \"@novorender/measure-api\";\nimport type {\n  CylinderData,\n  ProductData,\n} from \"./brep\";\nimport {\n  cylinderCenterLine,\n  edgeToPointMeasureValues,\n  faceToPointMeasureValues,\n  getSegmentToSegmentMeasureValues,\n  getSegmentToEdgeMeasureValues,\n  getEdgeToEdgeMeasureValues,\n  getEdgeToFaceMeasureValues,\n  getFaceToFaceMeasureValues,\n  getSegmentToFaceMeasureValues,\n  segmentToPointMeasureValues,\n  evalCurve,\n} from \"./calculations\";\nimport {\n  geometryFactory,\n  unitToScale,\n  matFromInstance,\n} from \"./loader\";\nimport { getBrepEdges, getBrepFaces, getEdgeStrip, PathInfo } from \"./outline\";\nimport {\n  Downloader,\n  getProfile,\n  reduceLineStrip,\n  swapCylinderImpl,\n} from \"./util\";\nimport {\n  ParametricProduct,\n  toParametricProduct,\n} from \"./parametric_product\";\nimport type {\n  CameraValues,\n  EdgeValues,\n  FaceValues,\n  ParameterBounds,\n  Profile,\n} from \"@novorender/measure-api\";\nimport {\n  addCenterLinesFromCylinders,\n  centerLinesToLinesTrip,\n  getCurveSegmentProfile,\n  getCylinderProfile,\n  reduceProfile,\n} from \"./profile\";\nimport {\n  extractCameraValuesFromFace,\n  extractCurveValues,\n  extractFaceValues,\n} from \"./extract_values\";\nimport { manholeMeasure } from \"./manhole\";\nimport { getCylinderDrawParts, getManholeDrawObjects, getSurfaceDrawParts } from \"./draw_objects\";\nimport { getFaceToFaceCollisionValues } from \"./collision\";\nimport { getPickInterface, pick, PickInterface } from \"./snaps\";\nimport { RoadTool } from \"./roads/scene\";\nimport type { CrossSection } from \"./roads/cross_section\";\n\nglMatrix.setMatrixArrayType(Array);\nexport const epsilon = 0.0001;\n\nexport class MeasureTool {\n  readonly downloader;\n  crossSectionTool: RoadTool;\n  data = new Map<ObjectId, ProductData | null>();\n  snapObjects = new Array<PickInterface>();\n  nextSnapIdx = 0;\n  constructor(readonly baseUrl: URL) {\n    const brepUrl = new URL(baseUrl);\n    brepUrl.pathname += \"brep/\";\n    this.downloader = new Downloader(brepUrl);\n    this.crossSectionTool = new RoadTool(baseUrl);\n  }\n\n  async getSnapInterface(id: number, product: ProductData | undefined): Promise<PickInterface | undefined> {\n    for (const pickInterface of this.snapObjects) {\n      if (pickInterface.objectId == id) {\n        return pickInterface;\n      }\n    }\n    if (product) {\n      if (this.nextSnapIdx == 6) {\n        this.nextSnapIdx = 0;\n      }\n      const snapInterface = await getPickInterface(product, id);\n      this.snapObjects[this.nextSnapIdx++] = snapInterface;\n      return snapInterface;\n    }\n  }\n\n  async downloadBrep(name: string): Promise<ProductData | null> {\n    try {\n      return await this.downloader.downloadJson(name);\n    } catch {\n      return null;\n    }\n  }\n\n  private async getProduct(\n    id: ObjectId\n  ): Promise<ProductData | undefined> {\n    let product = this.data.get(id);\n    if (product === undefined) {\n      product = await this.downloadBrep(`${id}.json`);\n      if (product && product.instances === undefined) {\n        this.data.set(id, null);\n        return undefined;\n      }\n      this.data.set(id, product);\n    }\n    return product ?? undefined;\n  }\n\n  async getCameraValuesFromFace(\n    id: ObjectId,\n    faceIdx: number,\n    instanceIdx: number,\n    cameraDir: vec3\n  ): Promise<CameraValues | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      return extractCameraValuesFromFace(\n        product,\n        faceIdx,\n        instanceIdx,\n        cameraDir\n      );\n    }\n    return undefined;\n  }\n\n  async getFaces(\n    id: ObjectId,\n    viewWorldMatrix: ReadonlyMat4\n  ): Promise<PathInfo[]> {\n    const product = await this.getProduct(id);\n    if (product) {\n      const worldViewMatrix = mat4.create();\n      mat4.invert(worldViewMatrix, viewWorldMatrix);\n      const faces = (await geometryFactory).getFaces(product);\n      const paths = getBrepFaces(faces, worldViewMatrix).filter(\n        (p) => p.path.length > 0\n      );\n      paths.sort((a, b) => a.centerDepth - b.centerDepth);\n      return paths;\n    }\n    return [];\n  }\n\n  async getProductObject(\n    productId: number\n  ): Promise<ParametricProduct | undefined> {\n    const product = await this.getProduct(productId);\n    if (product) {\n      return toParametricProduct(productId, product);\n    }\n    return undefined;\n  }\n\n  async getSnaps(productId: number) {\n    const product = await this.getProduct(productId);\n    if (product) {\n    }\n    return undefined;\n  }\n\n  async getParameterBoundsForCurve(\n    id: ObjectId,\n    pathIdx: number,\n    pathKind: \"edge\" | \"curveSegment\"\n  ): Promise<ParameterBounds | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      const parameterData =\n        pathKind == \"edge\"\n          ? product.edges[pathIdx]\n          : product.curveSegments[pathIdx];\n      const scale = unitToScale(product.units);\n      return {\n        start: parameterData.parameterBounds[0] * scale,\n        end: parameterData.parameterBounds[1] * scale,\n      };\n    }\n    return undefined;\n  }\n\n  async evalCurve(\n    id: ObjectId,\n    pathIdx: number,\n    instanceIdx: number,\n    parameter: number,\n    pathKind: \"edge\" | \"curveSegment\"\n  ): Promise<[ReadonlyVec3, ReadonlyVec3] | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      return evalCurve(product, pathIdx, instanceIdx, parameter, pathKind);\n    }\n    return undefined;\n  }\n\n  async getCylinderCurve(\n    id: ObjectId,\n    faceIdx: number,\n    instanceIdx: number,\n    setting?: MeasureSettings\n  ): Promise<[ParameterBounds, [ReadonlyVec3, ReadonlyVec3]] | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      const faceData = product.faces[faceIdx];\n      const scale = unitToScale(product.units);\n      const surfaceData = product.surfaces[faceData.surface];\n      const surface = (await geometryFactory).getSurface(\n        surfaceData,\n        faceData.facing,\n        scale\n      );\n      if (surface.kind == \"cylinder\") {\n        const cylinderData = surfaceData as CylinderData;\n        const mat = matFromInstance(product.instances[instanceIdx]);\n        const [cylinderOrigo, cylinderEnd] = await cylinderCenterLine(\n          product,\n          faceData,\n          cylinderData,\n          mat,\n          setting ? setting.cylinderMeasure : \"center\"\n        );\n        return [\n          { start: 0, end: vec3.dist(cylinderOrigo, cylinderEnd) },\n          [cylinderOrigo, cylinderEnd],\n        ];\n      }\n    }\n    return undefined;\n  }\n\n\n  async pickEntity(id: ObjectId, position: vec3, tolerance?: SnapTolerance):\n    Promise<{ entity: MeasureEntity, status: BrepStatus, connectionPoint?: vec3 }> {\n    const product = await this.getProduct(id);\n    if (product) {\n      const snapInterface = await this.getSnapInterface(id, product);\n      if (snapInterface) {\n        const tol = tolerance ?? { edge: 0.032, segment: 0.12, face: 0.07, point: 0.032 };\n        const pickedEntity = pick(snapInterface, position, tol);\n        if (pickedEntity) {\n          return { entity: pickedEntity.entity, status: \"loaded\", connectionPoint: pickedEntity.connectionPoint };\n        }\n      }\n    }\n    return {\n      entity: { ObjectId: id, parameter: position, drawKind: \"vertex\" }, status: \"missing\"\n    };\n  }\n\n  async pickEntityOnCurrentObject(id: ObjectId, position: vec3, tolerance: SnapTolerance):\n    Promise<{ entity: MeasureEntity | undefined, status: BrepStatus, connectionPoint?: vec3 }> {\n    const product = this.data.get(id);\n    if (product === null) {\n      return {\n        entity: undefined, status: \"missing\"\n      }\n    }\n    const snapInterface = await this.getSnapInterface(id, undefined);\n    if (snapInterface) {\n      const p = pick(snapInterface, position, tolerance);\n      return { entity: p?.entity, status: \"loaded\", connectionPoint: p?.connectionPoint };\n    }\n    return {\n      entity: undefined, status: \"unknown\"\n    }\n  }\n\n  async getEdges(\n    id: ObjectId,\n    viewWorldMatrix: ReadonlyMat4\n  ): Promise<PathInfo[]> {\n    const product = await this.getProduct(id);\n    if (product) {\n      const worldViewMatrix = mat4.create();\n      mat4.invert(worldViewMatrix, viewWorldMatrix);\n      const edges = (await geometryFactory).getEdges(product);\n      const paths = getBrepEdges(edges, worldViewMatrix).filter(\n        (p) => p.path.length > 0\n      );\n      return paths;\n    }\n    return [];\n  }\n\n  async getPaths(\n    id: ObjectId,\n    worldViewMatrix: ReadonlyMat4\n  ): Promise<PathInfo[]> {\n    const product = await this.getProduct(id);\n    if (product) {\n      const faces = (await geometryFactory).getFaces(product);\n      const facePaths = getBrepFaces(faces, worldViewMatrix).filter(\n        (p) => p.path.length > 0\n      );\n      facePaths.sort((a, b) => a.centerDepth - b.centerDepth);\n      const edges = (await geometryFactory).getEdges(product);\n      const edgePaths = getBrepEdges(edges, worldViewMatrix).filter(\n        (p) => p.path.length > 0\n      );\n\n      return [...facePaths, ...edgePaths];\n    }\n    return [];\n  }\n\n  async viableFollowPathEntity(\n    id: ObjectId\n  ): Promise<MeasureEntity | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      if (product.curveSegments && product.curveSegments.length > 0) {\n        if (product.curveSegments.length === 1) {\n          return {\n            ObjectId: id,\n            drawKind: \"curveSegment\",\n            pathIndex: 0,\n            instanceIndex: 0,\n            parameter: 0,\n          };\n        }\n      }\n    }\n  }\n\n  async getTesselatedEdge(\n    id: ObjectId,\n    edgeIdx: number,\n    instanceIdx: number\n  ): Promise<ReadonlyVec3[]> {\n    const product = await this.getProduct(id);\n    if (product) {\n      const edgeCurve = (await geometryFactory).getCurve3DFromEdge(\n        product,\n        edgeIdx\n      );\n      if (edgeCurve) {\n        const edge = {\n          curve: edgeCurve,\n          geometryTransformation: matFromInstance(\n            product.instances[instanceIdx]\n          ),\n          instanceIndex: instanceIdx,\n        };\n        return getEdgeStrip(edge, 1);\n      }\n    }\n    return [];\n  }\n\n  async tesselateCurveSegment(\n    id: ObjectId,\n    curveSegmentIdx: number,\n    instanceIdx: number\n  ): Promise<ReadonlyVec3[]> {\n    const product = await this.getProduct(id);\n    if (product) {\n      const curveSeg = (await geometryFactory).getCurve3DFromSegment(\n        product,\n        curveSegmentIdx\n      );\n      if (curveSeg) {\n        const curve = {\n          curve: curveSeg,\n          geometryTransformation: matFromInstance(\n            product.instances[instanceIdx]\n          ),\n          instanceIndex: instanceIdx,\n        };\n        return getEdgeStrip(curve, 1);\n      }\n    }\n    return [];\n  }\n\n  async curveSegmentProfile(\n    id: ObjectId,\n    curveSegmentIdx: number,\n    instanceIdx: number\n  ): Promise<Profile | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      const curveSeg = (await geometryFactory).getCurve3DFromSegment(\n        product,\n        curveSegmentIdx\n      );\n      if (curveSeg) {\n        return getCurveSegmentProfile(product, curveSeg, instanceIdx);\n      }\n    }\n    return undefined;\n  }\n\n  async cylinderProfile(\n    id: ObjectId,\n    faceIdx: number,\n    instanceIdx: number,\n    setting?: MeasureSettings\n  ): Promise<Profile | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      return await getCylinderProfile(product, faceIdx, instanceIdx, setting);\n    }\n    return undefined;\n  }\n\n  async multiSelectProfile(\n    products: ObjectId[],\n    setting?: MeasureSettings\n  ): Promise<Profile | undefined | string> {\n    const centerLines: {\n      start: ReadonlyVec3;\n      end: ReadonlyVec3;\n      radius: number;\n      prev: number | undefined;\n      next: number | undefined;\n    }[] = [];\n    for (const id of products) {\n      const product = await this.getProduct(id);\n      if (product) {\n        if (product.curveSegments && product.curveSegments.length > 0) {\n          if (product.curveSegments.length === 1 && products.length === 1) {\n            const segProfile = await this.curveSegmentProfile(id, 0, 0);\n            if (segProfile) {\n              return segProfile;\n            }\n          } else {\n            return \"Multiple segments in profile\";\n          }\n        }\n\n        await addCenterLinesFromCylinders(\n          product,\n          centerLines,\n          unitToScale(product.units),\n          setting\n        );\n      }\n    }\n\n    const lineStrip = reduceLineStrip(centerLinesToLinesTrip(centerLines));\n    if (lineStrip.length > 1) {\n      const profile = getProfile(lineStrip, undefined, undefined);\n      return reduceProfile(profile);\n    }\n    return undefined;\n  }\n\n  async getLineStripFromCylinders(\n    products: ObjectId[],\n    setting?: MeasureSettings\n  ) {\n    const lineStrip = await this.cylindersToLinestrip(products, setting);\n    for (const p of lineStrip) {\n    }\n    return lineStrip;\n  }\n\n  async cylindersToLinestrip(\n    products: ObjectId[],\n    setting?: MeasureSettings\n  ): Promise<ReadonlyVec3[]> {\n    const centerLines: {\n      start: ReadonlyVec3;\n      end: ReadonlyVec3;\n      radius: number;\n      prev: number | undefined;\n      next: number | undefined;\n    }[] = [];\n    for (const id of products) {\n      const product = await this.getProduct(id);\n      if (product) {\n        await addCenterLinesFromCylinders(\n          product,\n          centerLines,\n          unitToScale(product.units),\n          setting\n        );\n      }\n    }\n    return reduceLineStrip(centerLinesToLinesTrip(centerLines));\n  }\n\n  async getFaceDrawObject(\n    id: ObjectId,\n    faceIdx: number,\n    instanceIdx: number,\n    setting?: MeasureSettings\n  ): Promise<DrawObject | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      const face = product.faces[faceIdx];\n      const surface = product.surfaces[face.surface];\n      let drawParts: DrawPart[] = [];\n      const kind = surface.kind == \"cylinder\" ? \"cylinder\" : \"plane\";\n      if (surface.kind == \"cylinder\") {\n        drawParts = await getCylinderDrawParts(product, instanceIdx, surface as CylinderData, face, setting);\n      } else {\n        drawParts = await getSurfaceDrawParts(product, instanceIdx, face);\n      }\n      return { kind, parts: drawParts };\n    }\n    return undefined;\n  }\n\n  async edgeToEdgeMeasure(\n    idA: ObjectId,\n    edgeIdxA: number,\n    instanceIdxA: number,\n    idB: ObjectId,\n    edgeIdxB: number,\n    instanceIdxB: number\n  ): Promise<DuoMeasurementValues | undefined> {\n    const productA = await this.getProduct(idA);\n    const productB = await this.getProduct(idB);\n    if (productA && productB) {\n      return await getEdgeToEdgeMeasureValues(\n        productA,\n        edgeIdxA,\n        instanceIdxA,\n        productB,\n        edgeIdxB,\n        instanceIdxB\n      );\n    }\n  }\n\n  async edgeToPointMeasure(\n    id: ObjectId,\n    edgeIdx: number,\n    instanceIdx: number,\n    point: vec3\n  ): Promise<DuoMeasurementValues | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      return await edgeToPointMeasureValues(\n        product,\n        edgeIdx,\n        instanceIdx,\n        point\n      );\n    }\n  }\n\n  async segmentToPointMeasure(\n    id: ObjectId,\n    segIdx: number,\n    instanceIdx: number,\n    point: vec3\n  ): Promise<DuoMeasurementValues | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      return await segmentToPointMeasureValues(\n        product,\n        segIdx,\n        instanceIdx,\n        point\n      );\n    }\n  }\n\n  async faceToPointMeasure(\n    id: ObjectId,\n    faceIdx: number,\n    instanceIdx: number,\n    point: vec3,\n    setting?: MeasureSettings\n  ): Promise<DuoMeasurementValues | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      return await faceToPointMeasureValues(\n        product,\n        faceIdx,\n        instanceIdx,\n        point,\n        unitToScale(product.units),\n        setting\n      );\n    }\n  }\n\n  async edgeToFaceMeasure(\n    idA: ObjectId,\n    edgeIdx: number,\n    edgeInstanceIdx: number,\n    idB: ObjectId,\n    faceIdx: number,\n    faceInstanceIdx: number,\n    setting?: MeasureSettings\n  ): Promise<DuoMeasurementValues | undefined> {\n    const productA = await this.getProduct(idA);\n    const productB = await this.getProduct(idB);\n    if (productA && productB) {\n      return await getEdgeToFaceMeasureValues(\n        productA,\n        edgeIdx,\n        edgeInstanceIdx,\n        productB,\n        faceIdx,\n        faceInstanceIdx,\n        setting\n      );\n    }\n    return undefined;\n  }\n\n  async faceToFaceMeasure(\n    idA: ObjectId,\n    faceIdxA: number,\n    instanceIdxA: number,\n    idB: ObjectId,\n    faceIdxB: number,\n    instanceIdxB: number,\n    settingA?: MeasureSettings,\n    settingB?: MeasureSettings\n  ): Promise<DuoMeasurementValues | undefined> {\n    const productA = await this.getProduct(idA);\n    const productB = await this.getProduct(idB);\n    if (productA && productB) {\n      return await getFaceToFaceMeasureValues(\n        productA,\n        faceIdxA,\n        instanceIdxA,\n        productB,\n        faceIdxB,\n        instanceIdxB,\n        settingA,\n        settingB\n      );\n    }\n    return undefined;\n  }\n\n  async segmentToSegmentMeasure(\n    idA: ObjectId,\n    segIdxA: number,\n    instanceIdxA: number,\n    idB: ObjectId,\n    segIdxB: number,\n    instanceIdxB: number\n  ): Promise<DuoMeasurementValues | undefined> {\n    const productA = await this.getProduct(idA);\n    const productB = await this.getProduct(idB);\n    if (productA && productB) {\n      return await getSegmentToSegmentMeasureValues(\n        productA,\n        segIdxA,\n        instanceIdxA,\n        productB,\n        segIdxB,\n        instanceIdxB\n      );\n    }\n    return undefined;\n  }\n\n  async segmentToEdgeMeasure(\n    idA: ObjectId,\n    segIdx: number,\n    segInstanceIdx: number,\n    idB: ObjectId,\n    edgeIdx: number,\n    edgeInstanceIdx: number\n  ): Promise<DuoMeasurementValues | undefined> {\n    const productA = await this.getProduct(idA);\n    const productB = await this.getProduct(idB);\n    if (productA && productB) {\n      return await getSegmentToEdgeMeasureValues(\n        productA,\n        segIdx,\n        segInstanceIdx,\n        productB,\n        edgeIdx,\n        edgeInstanceIdx\n      );\n    }\n    return undefined;\n  }\n\n  async segmentToFaceMeasure(\n    idA: ObjectId,\n    segIdx: number,\n    segInstanceIdx: number,\n    idB: ObjectId,\n    faceIdx: number,\n    faceInstanceIdx: number,\n    setting?: MeasureSettings\n  ): Promise<DuoMeasurementValues | undefined> {\n    const productA = await this.getProduct(idA);\n    const productB = await this.getProduct(idB);\n    if (productA && productB) {\n      return await getSegmentToFaceMeasureValues(\n        productA,\n        segIdx,\n        segInstanceIdx,\n        productB,\n        faceIdx,\n        faceInstanceIdx,\n        setting\n      );\n    }\n    return undefined;\n  }\n\n  async getCurveValues(\n    id: ObjectId,\n    pathIdx: number,\n    instanceIdx: number,\n    pathKind: \"edge\" | \"curveSegment\"\n  ): Promise<EdgeValues | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      return extractCurveValues(product, pathIdx, instanceIdx, pathKind);\n    }\n  }\n\n  async getFaceValues(\n    id: ObjectId,\n    faceIdx: number,\n    instanceIdx: number,\n    setting?: MeasureSettings\n  ): Promise<FaceValues | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      return extractFaceValues(id, product, faceIdx, instanceIdx, setting);\n    }\n  }\n\n  async getManholeValues(id: ObjectId): Promise<ManholeMeasureValues | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      return manholeMeasure(product, id);\n    }\n    return undefined;\n  }\n\n  async getManholeDrawObject(entity: ManholeMeasureValues) {\n    const product = await this.getProduct(entity.ObjectId);\n    if (product) {\n      return getManholeDrawObjects(product, entity);\n    }\n    return [];\n  }\n\n  async swapCylinder(\n    id: ObjectId,\n    faceIdx: number,\n    instanceIdx: number,\n    to: \"inner\" | \"outer\"\n  ): Promise<number | undefined> {\n    const product = await this.getProduct(id);\n    if (product) {\n      return swapCylinderImpl(product, faceIdx, instanceIdx, to);\n    }\n  }\n\n  async faceToFaceCollision(\n    idA: ObjectId,\n    faceIdxA: number,\n    instanceIdxA: number,\n    idB: ObjectId,\n    faceIdxB: number,\n    instanceIdxB: number,\n    setting?: MeasureSettings\n  ): Promise<CollisionValues | undefined> {\n    const productA = await this.getProduct(idA);\n    const productB = await this.getProduct(idB);\n    if (productA && productB) {\n      return await getFaceToFaceCollisionValues(\n        productA,\n        faceIdxA,\n        instanceIdxA,\n        productB,\n        faceIdxB,\n        instanceIdxB,\n        setting\n      );\n    }\n    return undefined;\n  }\n\n  //Road stuff\n  async getRoadProfile(roadId: string): Promise<RoadProfiles | undefined> {\n    return await this.crossSectionTool.getRoadProfiles(roadId);\n  }\n\n  async getRoadCrossSlope(roadId: string): Promise<CrossSlope | undefined> {\n    return await this.crossSectionTool.getCrossSlope(roadId);\n  }\n\n  async getCrossSection(roadId: string, profileNumber: number): Promise<RoadCrossSection | undefined> {\n    return await this.crossSectionTool.getCrossSection(roadId, profileNumber);\n  }\n}\n", "import * as Comlink from \"comlink\";\nimport { MeasureTool } from \"./scene\";\n\nclass Service {\n    scriptUrl: string | undefined;\n\n    initialize(scriptUrl: string) {\n        this.scriptUrl = scriptUrl;\n    }\n\n    terminate() {\n        if (\"DedicatedWorkerGlobalScope\" in self) {\n            self.close();\n        }\n    }\n\n    createMeasureTool(sceneUrl: string) {\n        const tool = new MeasureTool(new URL(sceneUrl, this.scriptUrl!));\n        return Comlink.proxy(tool);\n    }\n}\n\nconst service = new Service();\nComlink.expose(service);\n\nexport type { Service };\n"],
  "mappings": "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",
  "names": ["obj", "returnValue", "proxy", "equals", "scale", "equals", "add", "adjoint", "clone", "copy", "create", "determinant", "equals", "exactEquals", "frob", "fromQuat", "fromRotation", "fromScaling", "fromTranslation", "fromValues", "identity", "invert", "mul", "multiply", "multiplyScalar", "multiplyScalarAndAdd", "rotate", "scale", "set", "str", "sub", "subtract", "translate", "transpose", "create", "clone", "copy", "fromValues", "set", "identity", "transpose", "invert", "adjoint", "determinant", "multiply", "translate", "scale", "rotate", "len", "fromTranslation", "fromScaling", "fromRotation", "fromQuat", "str", "frob", "add", "subtract", "multiplyScalar", "multiplyScalarAndAdd", "exactEquals", "equals", "mul", "sub", "add", "clone", "copy", "create", "equals", "exactEquals", "fromValues", "mul", "multiply", "rotateX", "rotateY", "rotateZ", "scale", "set", "str", "sub", "subtract", "create", "clone", "fromValues", "copy", "set", "add", "subtract", "multiply", "scale", "len", "rotateX", "rotateY", "rotateZ", "str", "exactEquals", "equals", "sub", "mul", "add", "ceil", "clone", "copy", "create", "cross", "dist", "distance", "div", "divide", "dot", "equals", "exactEquals", "floor", "forEach", "fromValues", "inverse", "len", "length", "lerp", "max", "min", "mul", "multiply", "negate", "normalize", "random", "round", "scale", "scaleAndAdd", "set", "sqrDist", "sqrLen", "squaredDistance", "squaredLength", "str", "sub", "subtract", "transformMat4", "transformQuat", "zero", "create", "clone", "fromValues", "copy", "set", "add", "subtract", "multiply", "divide", "ceil", "floor", "min", "max", "round", "scale", "scaleAndAdd", "distance", "squaredDistance", "length", "squaredLength", "negate", "inverse", "normalize", "len", "dot", "cross", "lerp", "random", "transformMat4", "transformQuat", "zero", "str", "exactEquals", "equals", "sub", "mul", "div", "dist", "sqrDist", "sqrLen", "forEach", "add", "angle", "ceil", "clone", "copy", "create", "cross", "dist", "distance", "div", "divide", "dot", "equals", "exactEquals", "floor", "forEach", "fromValues", "inverse", "len", "length", "lerp", "max", "min", "mul", "multiply", "negate", "normalize", "random", "rotate", "round", "scale", "scaleAndAdd", "set", "sqrDist", "sqrLen", "squaredDistance", "squaredLength", "str", "sub", "subtract", "transformMat3", "transformMat4", "zero", "create", "clone", "fromValues", "copy", "set", "add", "subtract", "multiply", "divide", "ceil", "floor", "min", "max", "round", "scale", "scaleAndAdd", "distance", "squaredDistance", "length", "squaredLength", "negate", "inverse", "normalize", "len", "dot", "cross", "lerp", "random", "transformMat3", "transformMat4", "rotate", "angle", "zero", "str", "exactEquals", "equals", "sub", "mul", "div", "dist", "sqrDist", "sqrLen", "forEach", "Module", "err", "str", "ret", "len", "buffer", "max", "asm", "exports", "length", "degree", "dist", "origin", "direction", "tmp3", "scale", "tmp3", "scale", "origin", "direction", "h", "origin", "direction", "min", "max", "scale", "projectedPoint", "len", "dist", "origin", "direction", "len", "projectedPoint", "epsilon", "scale", "distance", "projectedPoint", "dot", "angle", "negate", "epsilon", "addEdge", "v0", "v1", "triangles", "vi", "epsilon", "v", "i", "polygonWinding", "endPath", "x", "y", "value", "dist", "scale", "loop", "epsilon", "position", "scale", "faceFunc", "add", "dist", "len", "faceFuncPlane", "scale", "faceFuncCylinder", "len", "length", "epsilon", "loop", "text", "faceFunc", "faces", "edges", "dist", "actualDistance", "right", "epsilon", "scale"]
}
